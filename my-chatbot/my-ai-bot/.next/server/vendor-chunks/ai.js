"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ai";
exports.ids = ["vendor-chunks/ai"];
exports.modules = {

/***/ "(ssr)/./node_modules/ai/react/dist/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/ai/react/dist/index.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   experimental_useAssistant: () => (/* binding */ experimental_useAssistant),\n/* harmony export */   useAssistant: () => (/* binding */ useAssistant),\n/* harmony export */   useChat: () => (/* binding */ useChat),\n/* harmony export */   useCompletion: () => (/* binding */ useCompletion)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! swr */ \"(ssr)/./node_modules/swr/core/dist/index.mjs\");\n/* harmony import */ var nanoid_non_secure__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! nanoid/non-secure */ \"(ssr)/./node_modules/nanoid/non-secure/index.js\");\n/* __next_internal_client_entry_do_not_use__ experimental_useAssistant,useAssistant,useChat,useCompletion auto */ // react/use-chat.ts\n\n\n// shared/stream-parts.ts\nvar textStreamPart = {\n    code: \"0\",\n    name: \"text\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"text\" parts expect a string value.');\n        }\n        return {\n            type: \"text\",\n            value\n        };\n    }\n};\nvar functionCallStreamPart = {\n    code: \"1\",\n    name: \"function_call\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"function_call\" in value) || typeof value.function_call !== \"object\" || value.function_call == null || !(\"name\" in value.function_call) || !(\"arguments\" in value.function_call) || typeof value.function_call.name !== \"string\" || typeof value.function_call.arguments !== \"string\") {\n            throw new Error('\"function_call\" parts expect an object with a \"function_call\" property.');\n        }\n        return {\n            type: \"function_call\",\n            value\n        };\n    }\n};\nvar dataStreamPart = {\n    code: \"2\",\n    name: \"data\",\n    parse: (value)=>{\n        if (!Array.isArray(value)) {\n            throw new Error('\"data\" parts expect an array value.');\n        }\n        return {\n            type: \"data\",\n            value\n        };\n    }\n};\nvar errorStreamPart = {\n    code: \"3\",\n    name: \"error\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"error\" parts expect a string value.');\n        }\n        return {\n            type: \"error\",\n            value\n        };\n    }\n};\nvar assistantMessageStreamPart = {\n    code: \"4\",\n    name: \"assistant_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"id\" in value) || !(\"role\" in value) || !(\"content\" in value) || typeof value.id !== \"string\" || typeof value.role !== \"string\" || value.role !== \"assistant\" || !Array.isArray(value.content) || !value.content.every((item)=>item != null && typeof item === \"object\" && \"type\" in item && item.type === \"text\" && \"text\" in item && item.text != null && typeof item.text === \"object\" && \"value\" in item.text && typeof item.text.value === \"string\")) {\n            throw new Error('\"assistant_message\" parts expect an object with an \"id\", \"role\", and \"content\" property.');\n        }\n        return {\n            type: \"assistant_message\",\n            value\n        };\n    }\n};\nvar assistantControlDataStreamPart = {\n    code: \"5\",\n    name: \"assistant_control_data\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"threadId\" in value) || !(\"messageId\" in value) || typeof value.threadId !== \"string\" || typeof value.messageId !== \"string\") {\n            throw new Error('\"assistant_control_data\" parts expect an object with a \"threadId\" and \"messageId\" property.');\n        }\n        return {\n            type: \"assistant_control_data\",\n            value: {\n                threadId: value.threadId,\n                messageId: value.messageId\n            }\n        };\n    }\n};\nvar dataMessageStreamPart = {\n    code: \"6\",\n    name: \"data_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"role\" in value) || !(\"data\" in value) || typeof value.role !== \"string\" || value.role !== \"data\") {\n            throw new Error('\"data_message\" parts expect an object with a \"role\" and \"data\" property.');\n        }\n        return {\n            type: \"data_message\",\n            value\n        };\n    }\n};\nvar toolCallStreamPart = {\n    code: \"7\",\n    name: \"tool_calls\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"tool_calls\" in value) || typeof value.tool_calls !== \"object\" || value.tool_calls == null || !Array.isArray(value.tool_calls) || value.tool_calls.some((tc)=>tc == null || typeof tc !== \"object\" || !(\"id\" in tc) || typeof tc.id !== \"string\" || !(\"type\" in tc) || typeof tc.type !== \"string\" || !(\"function\" in tc) || tc.function == null || typeof tc.function !== \"object\" || !(\"arguments\" in tc.function) || typeof tc.function.name !== \"string\" || typeof tc.function.arguments !== \"string\")) {\n            throw new Error('\"tool_calls\" parts expect an object with a ToolCallPayload.');\n        }\n        return {\n            type: \"tool_calls\",\n            value\n        };\n    }\n};\nvar messageAnnotationsStreamPart = {\n    code: \"8\",\n    name: \"message_annotations\",\n    parse: (value)=>{\n        if (!Array.isArray(value)) {\n            throw new Error('\"message_annotations\" parts expect an array value.');\n        }\n        return {\n            type: \"message_annotations\",\n            value\n        };\n    }\n};\nvar streamParts = [\n    textStreamPart,\n    functionCallStreamPart,\n    dataStreamPart,\n    errorStreamPart,\n    assistantMessageStreamPart,\n    assistantControlDataStreamPart,\n    dataMessageStreamPart,\n    toolCallStreamPart,\n    messageAnnotationsStreamPart\n];\nvar streamPartsByCode = {\n    [textStreamPart.code]: textStreamPart,\n    [functionCallStreamPart.code]: functionCallStreamPart,\n    [dataStreamPart.code]: dataStreamPart,\n    [errorStreamPart.code]: errorStreamPart,\n    [assistantMessageStreamPart.code]: assistantMessageStreamPart,\n    [assistantControlDataStreamPart.code]: assistantControlDataStreamPart,\n    [dataMessageStreamPart.code]: dataMessageStreamPart,\n    [toolCallStreamPart.code]: toolCallStreamPart,\n    [messageAnnotationsStreamPart.code]: messageAnnotationsStreamPart\n};\nvar StreamStringPrefixes = {\n    [textStreamPart.name]: textStreamPart.code,\n    [functionCallStreamPart.name]: functionCallStreamPart.code,\n    [dataStreamPart.name]: dataStreamPart.code,\n    [errorStreamPart.name]: errorStreamPart.code,\n    [assistantMessageStreamPart.name]: assistantMessageStreamPart.code,\n    [assistantControlDataStreamPart.name]: assistantControlDataStreamPart.code,\n    [dataMessageStreamPart.name]: dataMessageStreamPart.code,\n    [toolCallStreamPart.name]: toolCallStreamPart.code,\n    [messageAnnotationsStreamPart.name]: messageAnnotationsStreamPart.code\n};\nvar validCodes = streamParts.map((part)=>part.code);\nvar parseStreamPart = (line)=>{\n    const firstSeparatorIndex = line.indexOf(\":\");\n    if (firstSeparatorIndex === -1) {\n        throw new Error(\"Failed to parse stream string. No separator found.\");\n    }\n    const prefix = line.slice(0, firstSeparatorIndex);\n    if (!validCodes.includes(prefix)) {\n        throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n    }\n    const code = prefix;\n    const textValue = line.slice(firstSeparatorIndex + 1);\n    const jsonValue = JSON.parse(textValue);\n    return streamPartsByCode[code].parse(jsonValue);\n};\n// shared/read-data-stream.ts\nvar NEWLINE = \"\\n\".charCodeAt(0);\nfunction concatChunks(chunks, totalLength) {\n    const concatenatedChunks = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const chunk of chunks){\n        concatenatedChunks.set(chunk, offset);\n        offset += chunk.length;\n    }\n    chunks.length = 0;\n    return concatenatedChunks;\n}\nasync function* readDataStream(reader, { isAborted } = {}) {\n    const decoder = new TextDecoder();\n    const chunks = [];\n    let totalLength = 0;\n    while(true){\n        const { value } = await reader.read();\n        if (value) {\n            chunks.push(value);\n            totalLength += value.length;\n            if (value[value.length - 1] !== NEWLINE) {\n                continue;\n            }\n        }\n        if (chunks.length === 0) {\n            break;\n        }\n        const concatenatedChunks = concatChunks(chunks, totalLength);\n        totalLength = 0;\n        const streamParts2 = decoder.decode(concatenatedChunks, {\n            stream: true\n        }).split(\"\\n\").filter((line)=>line !== \"\").map(parseStreamPart);\n        for (const streamPart of streamParts2){\n            yield streamPart;\n        }\n        if (isAborted == null ? void 0 : isAborted()) {\n            reader.cancel();\n            break;\n        }\n    }\n}\n// shared/generate-id.ts\n\nvar generateId = (0,nanoid_non_secure__WEBPACK_IMPORTED_MODULE_2__.customAlphabet)(\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\", 7);\n// shared/parse-complex-response.ts\nfunction assignAnnotationsToMessage(message, annotations) {\n    if (!message || !annotations || !annotations.length) return message;\n    return {\n        ...message,\n        annotations: [\n            ...annotations\n        ]\n    };\n}\nasync function parseComplexResponse({ reader, abortControllerRef, update, onFinish, generateId: generateId2 = generateId, getCurrentDate = ()=>/* @__PURE__ */ new Date() }) {\n    const createdAt = getCurrentDate();\n    const prefixMap = {\n        data: []\n    };\n    let message_annotations = void 0;\n    for await (const { type, value } of readDataStream(reader, {\n        isAborted: ()=>(abortControllerRef == null ? void 0 : abortControllerRef.current) === null\n    })){\n        if (type === \"text\") {\n            if (prefixMap[\"text\"]) {\n                prefixMap[\"text\"] = {\n                    ...prefixMap[\"text\"],\n                    content: (prefixMap[\"text\"].content || \"\") + value\n                };\n            } else {\n                prefixMap[\"text\"] = {\n                    id: generateId2(),\n                    role: \"assistant\",\n                    content: value,\n                    createdAt\n                };\n            }\n        }\n        let functionCallMessage = null;\n        if (type === \"function_call\") {\n            prefixMap[\"function_call\"] = {\n                id: generateId2(),\n                role: \"assistant\",\n                content: \"\",\n                function_call: value.function_call,\n                name: value.function_call.name,\n                createdAt\n            };\n            functionCallMessage = prefixMap[\"function_call\"];\n        }\n        let toolCallMessage = null;\n        if (type === \"tool_calls\") {\n            prefixMap[\"tool_calls\"] = {\n                id: generateId2(),\n                role: \"assistant\",\n                content: \"\",\n                tool_calls: value.tool_calls,\n                createdAt\n            };\n            toolCallMessage = prefixMap[\"tool_calls\"];\n        }\n        if (type === \"data\") {\n            prefixMap[\"data\"].push(...value);\n        }\n        let responseMessage = prefixMap[\"text\"];\n        if (type === \"message_annotations\") {\n            if (!message_annotations) {\n                message_annotations = [\n                    ...value\n                ];\n            } else {\n                message_annotations.push(...value);\n            }\n            functionCallMessage = assignAnnotationsToMessage(prefixMap[\"function_call\"], message_annotations);\n            toolCallMessage = assignAnnotationsToMessage(prefixMap[\"tool_calls\"], message_annotations);\n            responseMessage = assignAnnotationsToMessage(prefixMap[\"text\"], message_annotations);\n        }\n        if (message_annotations == null ? void 0 : message_annotations.length) {\n            const messagePrefixKeys = [\n                \"text\",\n                \"function_call\",\n                \"tool_calls\"\n            ];\n            messagePrefixKeys.forEach((key)=>{\n                if (prefixMap[key]) {\n                    prefixMap[key].annotations = [\n                        ...message_annotations\n                    ];\n                }\n            });\n        }\n        const merged = [\n            functionCallMessage,\n            toolCallMessage,\n            responseMessage\n        ].filter(Boolean).map((message)=>({\n                ...assignAnnotationsToMessage(message, message_annotations)\n            }));\n        update(merged, [\n            ...prefixMap[\"data\"]\n        ]);\n    }\n    onFinish == null ? void 0 : onFinish(prefixMap);\n    return {\n        messages: [\n            prefixMap.text,\n            prefixMap.function_call,\n            prefixMap.tool_calls\n        ].filter(Boolean),\n        data: prefixMap.data\n    };\n}\n// shared/utils.ts\nfunction createChunkDecoder(complex) {\n    const decoder = new TextDecoder();\n    if (!complex) {\n        return function(chunk) {\n            if (!chunk) return \"\";\n            return decoder.decode(chunk, {\n                stream: true\n            });\n        };\n    }\n    return function(chunk) {\n        const decoded = decoder.decode(chunk, {\n            stream: true\n        }).split(\"\\n\").filter((line)=>line !== \"\");\n        return decoded.map(parseStreamPart).filter(Boolean);\n    };\n}\n// shared/call-chat-api.ts\nasync function callChatApi({ api, messages, body, streamMode = \"stream-data\", credentials, headers, abortController, restoreMessagesOnFailure, onResponse, onUpdate, onFinish, generateId: generateId2 }) {\n    var _a;\n    const response = await fetch(api, {\n        method: \"POST\",\n        body: JSON.stringify({\n            messages,\n            ...body\n        }),\n        headers: {\n            \"Content-Type\": \"application/json\",\n            ...headers\n        },\n        signal: (_a = abortController == null ? void 0 : abortController()) == null ? void 0 : _a.signal,\n        credentials\n    }).catch((err)=>{\n        restoreMessagesOnFailure();\n        throw err;\n    });\n    if (onResponse) {\n        try {\n            await onResponse(response);\n        } catch (err) {\n            throw err;\n        }\n    }\n    if (!response.ok) {\n        restoreMessagesOnFailure();\n        throw new Error(await response.text() || \"Failed to fetch the chat response.\");\n    }\n    if (!response.body) {\n        throw new Error(\"The response body is empty.\");\n    }\n    const reader = response.body.getReader();\n    switch(streamMode){\n        case \"text\":\n            {\n                const decoder = createChunkDecoder();\n                const resultMessage = {\n                    id: generateId2(),\n                    createdAt: /* @__PURE__ */ new Date(),\n                    role: \"assistant\",\n                    content: \"\"\n                };\n                while(true){\n                    const { done, value } = await reader.read();\n                    if (done) {\n                        break;\n                    }\n                    resultMessage.content += decoder(value);\n                    resultMessage.id = generateId2();\n                    onUpdate([\n                        {\n                            ...resultMessage\n                        }\n                    ], []);\n                    if ((abortController == null ? void 0 : abortController()) === null) {\n                        reader.cancel();\n                        break;\n                    }\n                }\n                onFinish == null ? void 0 : onFinish(resultMessage);\n                return {\n                    messages: [\n                        resultMessage\n                    ],\n                    data: []\n                };\n            }\n        case \"stream-data\":\n            {\n                return await parseComplexResponse({\n                    reader,\n                    abortControllerRef: abortController != null ? {\n                        current: abortController()\n                    } : void 0,\n                    update: onUpdate,\n                    onFinish (prefixMap) {\n                        if (onFinish && prefixMap.text != null) {\n                            onFinish(prefixMap.text);\n                        }\n                    },\n                    generateId: generateId2\n                });\n            }\n        default:\n            {\n                const exhaustiveCheck = streamMode;\n                throw new Error(`Unknown stream mode: ${exhaustiveCheck}`);\n            }\n    }\n}\n// shared/process-chat-stream.ts\nasync function processChatStream({ getStreamedResponse: getStreamedResponse2, experimental_onFunctionCall, experimental_onToolCall, updateChatRequest, getCurrentMessages }) {\n    while(true){\n        const messagesAndDataOrJustMessage = await getStreamedResponse2();\n        if (\"messages\" in messagesAndDataOrJustMessage) {\n            let hasFollowingResponse = false;\n            for (const message of messagesAndDataOrJustMessage.messages){\n                if ((message.function_call === void 0 || typeof message.function_call === \"string\") && (message.tool_calls === void 0 || typeof message.tool_calls === \"string\")) {\n                    continue;\n                }\n                hasFollowingResponse = true;\n                if (experimental_onFunctionCall) {\n                    const functionCall = message.function_call;\n                    if (typeof functionCall !== \"object\") {\n                        console.warn(\"experimental_onFunctionCall should not be defined when using tools\");\n                        continue;\n                    }\n                    const functionCallResponse = await experimental_onFunctionCall(getCurrentMessages(), functionCall);\n                    if (functionCallResponse === void 0) {\n                        hasFollowingResponse = false;\n                        break;\n                    }\n                    updateChatRequest(functionCallResponse);\n                }\n                if (experimental_onToolCall) {\n                    const toolCalls = message.tool_calls;\n                    if (!Array.isArray(toolCalls) || toolCalls.some((toolCall)=>typeof toolCall !== \"object\")) {\n                        console.warn(\"experimental_onToolCall should not be defined when using tools\");\n                        continue;\n                    }\n                    const toolCallResponse = await experimental_onToolCall(getCurrentMessages(), toolCalls);\n                    if (toolCallResponse === void 0) {\n                        hasFollowingResponse = false;\n                        break;\n                    }\n                    updateChatRequest(toolCallResponse);\n                }\n            }\n            if (!hasFollowingResponse) {\n                break;\n            }\n        } else {\n            let fixFunctionCallArguments2 = function(response) {\n                for (const message of response.messages){\n                    if (message.tool_calls !== void 0) {\n                        for (const toolCall of message.tool_calls){\n                            if (typeof toolCall === \"object\") {\n                                if (toolCall.function.arguments && typeof toolCall.function.arguments !== \"string\") {\n                                    toolCall.function.arguments = JSON.stringify(toolCall.function.arguments);\n                                }\n                            }\n                        }\n                    }\n                    if (message.function_call !== void 0) {\n                        if (typeof message.function_call === \"object\") {\n                            if (message.function_call.arguments && typeof message.function_call.arguments !== \"string\") {\n                                message.function_call.arguments = JSON.stringify(message.function_call.arguments);\n                            }\n                        }\n                    }\n                }\n            };\n            var fixFunctionCallArguments = fixFunctionCallArguments2;\n            const streamedResponseMessage = messagesAndDataOrJustMessage;\n            if ((streamedResponseMessage.function_call === void 0 || typeof streamedResponseMessage.function_call === \"string\") && (streamedResponseMessage.tool_calls === void 0 || typeof streamedResponseMessage.tool_calls === \"string\")) {\n                break;\n            }\n            if (experimental_onFunctionCall) {\n                const functionCall = streamedResponseMessage.function_call;\n                if (!(typeof functionCall === \"object\")) {\n                    console.warn(\"experimental_onFunctionCall should not be defined when using tools\");\n                    continue;\n                }\n                const functionCallResponse = await experimental_onFunctionCall(getCurrentMessages(), functionCall);\n                if (functionCallResponse === void 0) break;\n                fixFunctionCallArguments2(functionCallResponse);\n                updateChatRequest(functionCallResponse);\n            }\n            if (experimental_onToolCall) {\n                const toolCalls = streamedResponseMessage.tool_calls;\n                if (!(typeof toolCalls === \"object\")) {\n                    console.warn(\"experimental_onToolCall should not be defined when using functions\");\n                    continue;\n                }\n                const toolCallResponse = await experimental_onToolCall(getCurrentMessages(), toolCalls);\n                if (toolCallResponse === void 0) break;\n                fixFunctionCallArguments2(toolCallResponse);\n                updateChatRequest(toolCallResponse);\n            }\n        }\n    }\n}\n// react/use-chat.ts\nvar getStreamedResponse = async (api, chatRequest, mutate, mutateStreamData, existingData, extraMetadataRef, messagesRef, abortControllerRef, generateId2, streamMode, onFinish, onResponse, sendExtraMessageFields)=>{\n    var _a, _b;\n    const previousMessages = messagesRef.current;\n    mutate(chatRequest.messages, false);\n    const constructedMessagesPayload = sendExtraMessageFields ? chatRequest.messages : chatRequest.messages.map(({ role, content, name, function_call, tool_calls, tool_call_id })=>({\n            role,\n            content,\n            tool_call_id,\n            ...name !== void 0 && {\n                name\n            },\n            ...function_call !== void 0 && {\n                function_call\n            },\n            ...tool_calls !== void 0 && {\n                tool_calls\n            }\n        }));\n    if (typeof api !== \"string\") {\n        const replyId = generateId2();\n        const createdAt = /* @__PURE__ */ new Date();\n        let responseMessage = {\n            id: replyId,\n            createdAt,\n            content: \"\",\n            role: \"assistant\"\n        };\n        async function readRow(promise) {\n            const { content, ui, next } = await promise;\n            responseMessage[\"content\"] = content;\n            responseMessage[\"ui\"] = await ui;\n            mutate([\n                ...chatRequest.messages,\n                {\n                    ...responseMessage\n                }\n            ], false);\n            if (next) {\n                await readRow(next);\n            }\n        }\n        try {\n            const promise = api({\n                messages: constructedMessagesPayload,\n                data: chatRequest.data\n            });\n            await readRow(promise);\n        } catch (e) {\n            mutate(previousMessages, false);\n            throw e;\n        }\n        if (onFinish) {\n            onFinish(responseMessage);\n        }\n        return responseMessage;\n    }\n    return await callChatApi({\n        api,\n        messages: constructedMessagesPayload,\n        body: {\n            data: chatRequest.data,\n            ...extraMetadataRef.current.body,\n            ...(_a = chatRequest.options) == null ? void 0 : _a.body,\n            ...chatRequest.functions !== void 0 && {\n                functions: chatRequest.functions\n            },\n            ...chatRequest.function_call !== void 0 && {\n                function_call: chatRequest.function_call\n            },\n            ...chatRequest.tools !== void 0 && {\n                tools: chatRequest.tools\n            },\n            ...chatRequest.tool_choice !== void 0 && {\n                tool_choice: chatRequest.tool_choice\n            }\n        },\n        streamMode,\n        credentials: extraMetadataRef.current.credentials,\n        headers: {\n            ...extraMetadataRef.current.headers,\n            ...(_b = chatRequest.options) == null ? void 0 : _b.headers\n        },\n        abortController: ()=>abortControllerRef.current,\n        restoreMessagesOnFailure () {\n            mutate(previousMessages, false);\n        },\n        onResponse,\n        onUpdate (merged, data) {\n            mutate([\n                ...chatRequest.messages,\n                ...merged\n            ], false);\n            mutateStreamData([\n                ...existingData || [],\n                ...data || []\n            ], false);\n        },\n        onFinish,\n        generateId: generateId2\n    });\n};\nfunction useChat({ api = \"/api/chat\", id, initialMessages, initialInput = \"\", sendExtraMessageFields, experimental_onFunctionCall, experimental_onToolCall, streamMode, onResponse, onFinish, onError, credentials, headers, body, generateId: generateId2 = generateId } = {}) {\n    const hookId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n    const idKey = id != null ? id : hookId;\n    const chatKey = typeof api === \"string\" ? [\n        api,\n        idKey\n    ] : idKey;\n    const [initialMessagesFallback] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const { data: messages, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"messages\"\n    ], null, {\n        fallbackData: initialMessages != null ? initialMessages : initialMessagesFallback\n    });\n    const { data: isLoading = false, mutate: mutateLoading } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"loading\"\n    ], null);\n    const { data: streamData, mutate: mutateStreamData } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"streamData\"\n    ], null);\n    const { data: error = void 0, mutate: setError } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"error\"\n    ], null);\n    const messagesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(messages || []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        messagesRef.current = messages || [];\n    }, [\n        messages\n    ]);\n    const abortControllerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const extraMetadataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        credentials,\n        headers,\n        body\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        extraMetadataRef.current = {\n            credentials,\n            headers,\n            body\n        };\n    }, [\n        credentials,\n        headers,\n        body\n    ]);\n    const triggerRequest = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (chatRequest)=>{\n        try {\n            mutateLoading(true);\n            setError(void 0);\n            const abortController = new AbortController();\n            abortControllerRef.current = abortController;\n            await processChatStream({\n                getStreamedResponse: ()=>getStreamedResponse(api, chatRequest, mutate, mutateStreamData, streamData, extraMetadataRef, messagesRef, abortControllerRef, generateId2, streamMode, onFinish, onResponse, sendExtraMessageFields),\n                experimental_onFunctionCall,\n                experimental_onToolCall,\n                updateChatRequest: (chatRequestParam)=>{\n                    chatRequest = chatRequestParam;\n                },\n                getCurrentMessages: ()=>messagesRef.current\n            });\n            abortControllerRef.current = null;\n        } catch (err) {\n            if (err.name === \"AbortError\") {\n                abortControllerRef.current = null;\n                return null;\n            }\n            if (onError && err instanceof Error) {\n                onError(err);\n            }\n            setError(err);\n        } finally{\n            mutateLoading(false);\n        }\n    }, [\n        mutate,\n        mutateLoading,\n        api,\n        extraMetadataRef,\n        onResponse,\n        onFinish,\n        onError,\n        setError,\n        mutateStreamData,\n        streamData,\n        sendExtraMessageFields,\n        experimental_onFunctionCall,\n        experimental_onToolCall,\n        messagesRef,\n        abortControllerRef,\n        generateId2\n    ]);\n    const append = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (message, { options, functions, function_call, tools, tool_choice, data } = {})=>{\n        if (!message.id) {\n            message.id = generateId2();\n        }\n        const chatRequest = {\n            messages: messagesRef.current.concat(message),\n            options,\n            data,\n            ...functions !== void 0 && {\n                functions\n            },\n            ...function_call !== void 0 && {\n                function_call\n            },\n            ...tools !== void 0 && {\n                tools\n            },\n            ...tool_choice !== void 0 && {\n                tool_choice\n            }\n        };\n        return triggerRequest(chatRequest);\n    }, [\n        triggerRequest,\n        generateId2\n    ]);\n    const reload = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ({ options, functions, function_call, tools, tool_choice } = {})=>{\n        if (messagesRef.current.length === 0) return null;\n        const lastMessage = messagesRef.current[messagesRef.current.length - 1];\n        if (lastMessage.role === \"assistant\") {\n            const chatRequest2 = {\n                messages: messagesRef.current.slice(0, -1),\n                options,\n                ...functions !== void 0 && {\n                    functions\n                },\n                ...function_call !== void 0 && {\n                    function_call\n                },\n                ...tools !== void 0 && {\n                    tools\n                },\n                ...tool_choice !== void 0 && {\n                    tool_choice\n                }\n            };\n            return triggerRequest(chatRequest2);\n        }\n        const chatRequest = {\n            messages: messagesRef.current,\n            options,\n            ...functions !== void 0 && {\n                functions\n            },\n            ...function_call !== void 0 && {\n                function_call\n            },\n            ...tools !== void 0 && {\n                tools\n            },\n            ...tool_choice !== void 0 && {\n                tool_choice\n            }\n        };\n        return triggerRequest(chatRequest);\n    }, [\n        triggerRequest\n    ]);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (abortControllerRef.current) {\n            abortControllerRef.current.abort();\n            abortControllerRef.current = null;\n        }\n    }, []);\n    const setMessages = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((messages2)=>{\n        mutate(messages2, false);\n        messagesRef.current = messages2;\n    }, [\n        mutate\n    ]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialInput);\n    const handleSubmit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e, options = {}, metadata)=>{\n        if (metadata) {\n            extraMetadataRef.current = {\n                ...extraMetadataRef.current,\n                ...metadata\n            };\n        }\n        e.preventDefault();\n        if (!input) return;\n        append({\n            content: input,\n            role: \"user\",\n            createdAt: /* @__PURE__ */ new Date()\n        }, options);\n        setInput(\"\");\n    }, [\n        input,\n        append\n    ]);\n    const handleInputChange = (e)=>{\n        setInput(e.target.value);\n    };\n    return {\n        messages: messages || [],\n        error,\n        append,\n        reload,\n        stop,\n        setMessages,\n        input,\n        setInput,\n        handleInputChange,\n        handleSubmit,\n        isLoading,\n        data: streamData\n    };\n}\n// react/use-completion.ts\n\n\n// shared/call-completion-api.ts\nasync function callCompletionApi({ api, prompt, credentials, headers, body, streamMode = \"stream-data\", setCompletion, setLoading, setError, setAbortController, onResponse, onFinish, onError, onData }) {\n    try {\n        setLoading(true);\n        setError(void 0);\n        const abortController = new AbortController();\n        setAbortController(abortController);\n        setCompletion(\"\");\n        const res = await fetch(api, {\n            method: \"POST\",\n            body: JSON.stringify({\n                prompt,\n                ...body\n            }),\n            credentials,\n            headers: {\n                \"Content-Type\": \"application/json\",\n                ...headers\n            },\n            signal: abortController.signal\n        }).catch((err)=>{\n            throw err;\n        });\n        if (onResponse) {\n            try {\n                await onResponse(res);\n            } catch (err) {\n                throw err;\n            }\n        }\n        if (!res.ok) {\n            throw new Error(await res.text() || \"Failed to fetch the chat response.\");\n        }\n        if (!res.body) {\n            throw new Error(\"The response body is empty.\");\n        }\n        let result = \"\";\n        const reader = res.body.getReader();\n        switch(streamMode){\n            case \"text\":\n                {\n                    const decoder = createChunkDecoder();\n                    while(true){\n                        const { done, value } = await reader.read();\n                        if (done) {\n                            break;\n                        }\n                        result += decoder(value);\n                        setCompletion(result);\n                        if (abortController === null) {\n                            reader.cancel();\n                            break;\n                        }\n                    }\n                    break;\n                }\n            case \"stream-data\":\n                {\n                    for await (const { type, value } of readDataStream(reader, {\n                        isAborted: ()=>abortController === null\n                    })){\n                        switch(type){\n                            case \"text\":\n                                {\n                                    result += value;\n                                    setCompletion(result);\n                                    break;\n                                }\n                            case \"data\":\n                                {\n                                    onData == null ? void 0 : onData(value);\n                                    break;\n                                }\n                        }\n                    }\n                    break;\n                }\n            default:\n                {\n                    const exhaustiveCheck = streamMode;\n                    throw new Error(`Unknown stream mode: ${exhaustiveCheck}`);\n                }\n        }\n        if (onFinish) {\n            onFinish(prompt, result);\n        }\n        setAbortController(null);\n        return result;\n    } catch (err) {\n        if (err.name === \"AbortError\") {\n            setAbortController(null);\n            return null;\n        }\n        if (err instanceof Error) {\n            if (onError) {\n                onError(err);\n            }\n        }\n        setError(err);\n    } finally{\n        setLoading(false);\n    }\n}\n// react/use-completion.ts\nfunction useCompletion({ api = \"/api/completion\", id, initialCompletion = \"\", initialInput = \"\", credentials, headers, body, streamMode, onResponse, onFinish, onError } = {}) {\n    const hookId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n    const completionId = id || hookId;\n    const { data, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        api,\n        completionId\n    ], null, {\n        fallbackData: initialCompletion\n    });\n    const { data: isLoading = false, mutate: mutateLoading } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        completionId,\n        \"loading\"\n    ], null);\n    const { data: streamData, mutate: mutateStreamData } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        completionId,\n        \"streamData\"\n    ], null);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const completion = data;\n    const [abortController, setAbortController] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const extraMetadataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        credentials,\n        headers,\n        body\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        extraMetadataRef.current = {\n            credentials,\n            headers,\n            body\n        };\n    }, [\n        credentials,\n        headers,\n        body\n    ]);\n    const triggerRequest = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (prompt, options)=>callCompletionApi({\n            api,\n            prompt,\n            credentials: extraMetadataRef.current.credentials,\n            headers: {\n                ...extraMetadataRef.current.headers,\n                ...options == null ? void 0 : options.headers\n            },\n            body: {\n                ...extraMetadataRef.current.body,\n                ...options == null ? void 0 : options.body\n            },\n            streamMode,\n            setCompletion: (completion2)=>mutate(completion2, false),\n            setLoading: mutateLoading,\n            setError,\n            setAbortController,\n            onResponse,\n            onFinish,\n            onError,\n            onData: (data2)=>{\n                mutateStreamData([\n                    ...streamData || [],\n                    ...data2 || []\n                ], false);\n            }\n        }), [\n        mutate,\n        mutateLoading,\n        api,\n        extraMetadataRef,\n        setAbortController,\n        onResponse,\n        onFinish,\n        onError,\n        setError,\n        streamData,\n        mutateStreamData\n    ]);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (abortController) {\n            abortController.abort();\n            setAbortController(null);\n        }\n    }, [\n        abortController\n    ]);\n    const setCompletion = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((completion2)=>{\n        mutate(completion2, false);\n    }, [\n        mutate\n    ]);\n    const complete = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (prompt, options)=>{\n        return triggerRequest(prompt, options);\n    }, [\n        triggerRequest\n    ]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialInput);\n    const handleSubmit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        e.preventDefault();\n        if (!input) return;\n        return complete(input);\n    }, [\n        input,\n        complete\n    ]);\n    const handleInputChange = (e)=>{\n        setInput(e.target.value);\n    };\n    return {\n        completion,\n        complete,\n        error,\n        setCompletion,\n        stop,\n        input,\n        setInput,\n        handleInputChange,\n        handleSubmit,\n        isLoading,\n        data: streamData\n    };\n}\n// react/use-assistant.ts\n\nfunction useAssistant({ api, threadId: threadIdParam, credentials, headers, body, onError }) {\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const [threadId, setThreadId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"awaiting_message\");\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const handleInputChange = (event)=>{\n        setInput(event.target.value);\n    };\n    const append = async (message, requestOptions)=>{\n        var _a;\n        setStatus(\"in_progress\");\n        setMessages((messages2)=>{\n            var _a2;\n            return [\n                ...messages2,\n                {\n                    ...message,\n                    id: (_a2 = message.id) != null ? _a2 : generateId()\n                }\n            ];\n        });\n        setInput(\"\");\n        try {\n            const result = await fetch(api, {\n                method: \"POST\",\n                credentials,\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...headers\n                },\n                body: JSON.stringify({\n                    ...body,\n                    // always use user-provided threadId when available:\n                    threadId: (_a = threadIdParam != null ? threadIdParam : threadId) != null ? _a : null,\n                    message: message.content,\n                    // optional request data:\n                    data: requestOptions == null ? void 0 : requestOptions.data\n                })\n            });\n            if (result.body == null) {\n                throw new Error(\"The response body is empty.\");\n            }\n            for await (const { type, value } of readDataStream(result.body.getReader())){\n                switch(type){\n                    case \"assistant_message\":\n                        {\n                            setMessages((messages2)=>[\n                                    ...messages2,\n                                    {\n                                        id: value.id,\n                                        role: value.role,\n                                        content: value.content[0].text.value\n                                    }\n                                ]);\n                            break;\n                        }\n                    case \"text\":\n                        {\n                            setMessages((messages2)=>{\n                                const lastMessage = messages2[messages2.length - 1];\n                                return [\n                                    ...messages2.slice(0, messages2.length - 1),\n                                    {\n                                        id: lastMessage.id,\n                                        role: lastMessage.role,\n                                        content: lastMessage.content + value\n                                    }\n                                ];\n                            });\n                            break;\n                        }\n                    case \"data_message\":\n                        {\n                            setMessages((messages2)=>{\n                                var _a2;\n                                return [\n                                    ...messages2,\n                                    {\n                                        id: (_a2 = value.id) != null ? _a2 : generateId(),\n                                        role: \"data\",\n                                        content: \"\",\n                                        data: value.data\n                                    }\n                                ];\n                            });\n                            break;\n                        }\n                    case \"assistant_control_data\":\n                        {\n                            setThreadId(value.threadId);\n                            setMessages((messages2)=>{\n                                const lastMessage = messages2[messages2.length - 1];\n                                lastMessage.id = value.messageId;\n                                return [\n                                    ...messages2.slice(0, messages2.length - 1),\n                                    lastMessage\n                                ];\n                            });\n                            break;\n                        }\n                    case \"error\":\n                        {\n                            const errorObj = new Error(value);\n                            setError(errorObj);\n                            break;\n                        }\n                }\n            }\n        } catch (error2) {\n            if (onError && error2 instanceof Error) {\n                onError(error2);\n            }\n            setError(error2);\n        }\n        setStatus(\"awaiting_message\");\n    };\n    const submitMessage = async (event, requestOptions)=>{\n        var _a;\n        (_a = event == null ? void 0 : event.preventDefault) == null ? void 0 : _a.call(event);\n        if (input === \"\") {\n            return;\n        }\n        append({\n            role: \"user\",\n            content: input\n        }, requestOptions);\n    };\n    return {\n        append,\n        messages,\n        setMessages,\n        threadId,\n        input,\n        setInput,\n        handleInputChange,\n        submitMessage,\n        status,\n        error\n    };\n}\nvar experimental_useAssistant = useAssistant;\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWkvcmVhY3QvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBZ0U7QUFDM0I7O0FDY3JDLElBQU1NLGlCQUFrRDtJQUN0REMsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE9BQU8sQ0FBQ0M7UUFDTixJQUFJLE9BQU9BLFVBQVUsVUFBVTtZQUM3QixNQUFNLElBQUlDLE1BQU07UUFDbEI7UUFDQSxPQUFPO1lBQUVDLE1BQU07WUFBUUY7UUFBTTtJQUMvQjtBQUNGO0FBRUEsSUFBTUcseUJBSUY7SUFDRk4sTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE9BQU8sQ0FBQ0M7UUFDTixJQUNFQSxTQUFTLFFBQ1QsT0FBT0EsVUFBVSxZQUNqQixDQUFFLG9CQUFtQkEsS0FBQSxLQUNyQixPQUFPQSxNQUFNSSxhQUFBLEtBQWtCLFlBQy9CSixNQUFNSSxhQUFBLElBQWlCLFFBQ3ZCLENBQUUsV0FBVUosTUFBTUksYUFBQSxLQUNsQixDQUFFLGdCQUFlSixNQUFNSSxhQUFBLEtBQ3ZCLE9BQU9KLE1BQU1JLGFBQUEsQ0FBY04sSUFBQSxLQUFTLFlBQ3BDLE9BQU9FLE1BQU1JLGFBQUEsQ0FBY0MsU0FBQSxLQUFjLFVBQ3pDO1lBQ0EsTUFBTSxJQUFJSixNQUNSO1FBRUo7UUFFQSxPQUFPO1lBQ0xDLE1BQU07WUFDTkY7UUFDRjtJQUNGO0FBQ0Y7QUFFQSxJQUFNTSxpQkFBNEQ7SUFDaEVULE1BQU07SUFDTkMsTUFBTTtJQUNOQyxPQUFPLENBQUNDO1FBQ04sSUFBSSxDQUFDTyxNQUFNQyxPQUFBLENBQVFSLFFBQVE7WUFDekIsTUFBTSxJQUFJQyxNQUFNO1FBQ2xCO1FBRUEsT0FBTztZQUFFQyxNQUFNO1lBQVFGO1FBQU07SUFDL0I7QUFDRjtBQUVBLElBQU1TLGtCQUFvRDtJQUN4RFosTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE9BQU8sQ0FBQ0M7UUFDTixJQUFJLE9BQU9BLFVBQVUsVUFBVTtZQUM3QixNQUFNLElBQUlD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LE1BQU07WUFBUUMsU0FBU3VLO1FBQU0sR0FBRzBCO0lBQzNDO0lBRUEsT0FBTztRQUNMakM7UUFDQWxGO1FBQ0F3RjtRQUNBaks7UUFDQWtLO1FBQ0FDO1FBQ0FJO1FBQ0F1QjtRQUNBTDtRQUNBbkM7SUFDRjtBQUNGO0FBS08sSUFBTTBDLDRCQUE0QlYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1haS1ib3QvLi4vdXNlLWNoYXQudHM/ODgyOCIsIndlYnBhY2s6Ly9teS1haS1ib3QvLi4vLi4vc2hhcmVkL3N0cmVhbS1wYXJ0cy50cz9jNGE4Iiwid2VicGFjazovL215LWFpLWJvdC8uLi8uLi9zaGFyZWQvcmVhZC1kYXRhLXN0cmVhbS50cz8xOGYxIiwid2VicGFjazovL215LWFpLWJvdC8uLi8uLi9zaGFyZWQvZ2VuZXJhdGUtaWQudHM/MGQ1ZiIsIndlYnBhY2s6Ly9teS1haS1ib3QvLi4vLi4vc2hhcmVkL3BhcnNlLWNvbXBsZXgtcmVzcG9uc2UudHM/NjVlMCIsIndlYnBhY2s6Ly9teS1haS1ib3QvLi4vLi4vc2hhcmVkL3V0aWxzLnRzP2Y4Y2YiLCJ3ZWJwYWNrOi8vbXktYWktYm90Ly4uLy4uL3NoYXJlZC9jYWxsLWNoYXQtYXBpLnRzP2I1NWIiLCJ3ZWJwYWNrOi8vbXktYWktYm90Ly4uLy4uL3NoYXJlZC9wcm9jZXNzLWNoYXQtc3RyZWFtLnRzPzhkN2YiLCJ3ZWJwYWNrOi8vbXktYWktYm90Ly4uL3VzZS1jb21wbGV0aW9uLnRzP2FlN2YiLCJ3ZWJwYWNrOi8vbXktYWktYm90Ly4uLy4uL3NoYXJlZC9jYWxsLWNvbXBsZXRpb24tYXBpLnRzPzg1MjUiLCJ3ZWJwYWNrOi8vbXktYWktYm90Ly4uL3VzZS1hc3Npc3RhbnQudHM/MjgxMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VJZCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB1c2VTV1IsIHsgS2V5ZWRNdXRhdG9yIH0gZnJvbSAnc3dyJztcbmltcG9ydCB7IGNhbGxDaGF0QXBpIH0gZnJvbSAnLi4vc2hhcmVkL2NhbGwtY2hhdC1hcGknO1xuaW1wb3J0IHsgZ2VuZXJhdGVJZCBhcyBnZW5lcmF0ZUlkRnVuYyB9IGZyb20gJy4uL3NoYXJlZC9nZW5lcmF0ZS1pZCc7XG5pbXBvcnQgeyBwcm9jZXNzQ2hhdFN0cmVhbSB9IGZyb20gJy4uL3NoYXJlZC9wcm9jZXNzLWNoYXQtc3RyZWFtJztcbmltcG9ydCB0eXBlIHtcbiAgQ2hhdFJlcXVlc3QsXG4gIENoYXRSZXF1ZXN0T3B0aW9ucyxcbiAgQ3JlYXRlTWVzc2FnZSxcbiAgSWRHZW5lcmF0b3IsXG4gIEpTT05WYWx1ZSxcbiAgTWVzc2FnZSxcbiAgVXNlQ2hhdE9wdGlvbnMsXG59IGZyb20gJy4uL3NoYXJlZC90eXBlcyc7XG5pbXBvcnQgdHlwZSB7XG4gIFJlYWN0UmVzcG9uc2VSb3csXG4gIGV4cGVyaW1lbnRhbF9TdHJlYW1pbmdSZWFjdFJlc3BvbnNlLFxufSBmcm9tICcuLi9zdHJlYW1zL3N0cmVhbWluZy1yZWFjdC1yZXNwb25zZSc7XG5leHBvcnQgdHlwZSB7IENyZWF0ZU1lc3NhZ2UsIE1lc3NhZ2UsIFVzZUNoYXRPcHRpb25zIH07XG5cbmV4cG9ydCB0eXBlIFVzZUNoYXRIZWxwZXJzID0ge1xuICAvKiogQ3VycmVudCBtZXNzYWdlcyBpbiB0aGUgY2hhdCAqL1xuICBtZXNzYWdlczogTWVzc2FnZVtdO1xuICAvKiogVGhlIGVycm9yIG9iamVjdCBvZiB0aGUgQVBJIHJlcXVlc3QgKi9cbiAgZXJyb3I6IHVuZGVmaW5lZCB8IEVycm9yO1xuICAvKipcbiAgICogQXBwZW5kIGEgdXNlciBtZXNzYWdlIHRvIHRoZSBjaGF0IGxpc3QuIFRoaXMgdHJpZ2dlcnMgdGhlIEFQSSBjYWxsIHRvIGZldGNoXG4gICAqIHRoZSBhc3Npc3RhbnQncyByZXNwb25zZS5cbiAgICogQHBhcmFtIG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gYXBwZW5kXG4gICAqIEBwYXJhbSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBBUEkgY2FsbFxuICAgKi9cbiAgYXBwZW5kOiAoXG4gICAgbWVzc2FnZTogTWVzc2FnZSB8IENyZWF0ZU1lc3NhZ2UsXG4gICAgY2hhdFJlcXVlc3RPcHRpb25zPzogQ2hhdFJlcXVlc3RPcHRpb25zLFxuICApID0+IFByb21pc2U8c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZD47XG4gIC8qKlxuICAgKiBSZWxvYWQgdGhlIGxhc3QgQUkgY2hhdCByZXNwb25zZSBmb3IgdGhlIGdpdmVuIGNoYXQgaGlzdG9yeS4gSWYgdGhlIGxhc3RcbiAgICogbWVzc2FnZSBpc24ndCBmcm9tIHRoZSBhc3Npc3RhbnQsIGl0IHdpbGwgcmVxdWVzdCB0aGUgQVBJIHRvIGdlbmVyYXRlIGFcbiAgICogbmV3IHJlc3BvbnNlLlxuICAgKi9cbiAgcmVsb2FkOiAoXG4gICAgY2hhdFJlcXVlc3RPcHRpb25zPzogQ2hhdFJlcXVlc3RPcHRpb25zLFxuICApID0+IFByb21pc2U8c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZD47XG4gIC8qKlxuICAgKiBBYm9ydCB0aGUgY3VycmVudCByZXF1ZXN0IGltbWVkaWF0ZWx5LCBrZWVwIHRoZSBnZW5lcmF0ZWQgdG9rZW5zIGlmIGFueS5cbiAgICovXG4gIHN0b3A6ICgpID0+IHZvaWQ7XG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGBtZXNzYWdlc2Agc3RhdGUgbG9jYWxseS4gVGhpcyBpcyB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0b1xuICAgKiBlZGl0IHRoZSBtZXNzYWdlcyBvbiB0aGUgY2xpZW50LCBhbmQgdGhlbiB0cmlnZ2VyIHRoZSBgcmVsb2FkYCBtZXRob2RcbiAgICogbWFudWFsbHkgdG8gcmVnZW5lcmF0ZSB0aGUgQUkgcmVzcG9uc2UuXG4gICAqL1xuICBzZXRNZXNzYWdlczogKG1lc3NhZ2VzOiBNZXNzYWdlW10pID0+IHZvaWQ7XG4gIC8qKiBUaGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgaW5wdXQgKi9cbiAgaW5wdXQ6IHN0cmluZztcbiAgLyoqIHNldFN0YXRlLXBvd2VyZWQgbWV0aG9kIHRvIHVwZGF0ZSB0aGUgaW5wdXQgdmFsdWUgKi9cbiAgc2V0SW5wdXQ6IFJlYWN0LkRpc3BhdGNoPFJlYWN0LlNldFN0YXRlQWN0aW9uPHN0cmluZz4+O1xuICAvKiogQW4gaW5wdXQvdGV4dGFyZWEtcmVhZHkgb25DaGFuZ2UgaGFuZGxlciB0byBjb250cm9sIHRoZSB2YWx1ZSBvZiB0aGUgaW5wdXQgKi9cbiAgaGFuZGxlSW5wdXRDaGFuZ2U6IChcbiAgICBlOlxuICAgICAgfCBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PlxuICAgICAgfCBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MVGV4dEFyZWFFbGVtZW50PixcbiAgKSA9PiB2b2lkO1xuICAvKiogRm9ybSBzdWJtaXNzaW9uIGhhbmRsZXIgdG8gYXV0b21hdGljYWxseSByZXNldCBpbnB1dCBhbmQgYXBwZW5kIGEgdXNlciBtZXNzYWdlICovXG4gIGhhbmRsZVN1Ym1pdDogKFxuICAgIGU6IFJlYWN0LkZvcm1FdmVudDxIVE1MRm9ybUVsZW1lbnQ+LFxuICAgIGNoYXRSZXF1ZXN0T3B0aW9ucz86IENoYXRSZXF1ZXN0T3B0aW9ucyxcbiAgKSA9PiB2b2lkO1xuICBtZXRhZGF0YT86IE9iamVjdDtcbiAgLyoqIFdoZXRoZXIgdGhlIEFQSSByZXF1ZXN0IGlzIGluIHByb2dyZXNzICovXG4gIGlzTG9hZGluZzogYm9vbGVhbjtcbiAgLyoqIEFkZGl0aW9uYWwgZGF0YSBhZGRlZCBvbiB0aGUgc2VydmVyIHZpYSBTdHJlYW1EYXRhICovXG4gIGRhdGE/OiBKU09OVmFsdWVbXTtcbn07XG5cbnR5cGUgU3RyZWFtaW5nUmVhY3RSZXNwb25zZUFjdGlvbiA9IChwYXlsb2FkOiB7XG4gIG1lc3NhZ2VzOiBNZXNzYWdlW107XG4gIGRhdGE/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xufSkgPT4gUHJvbWlzZTxleHBlcmltZW50YWxfU3RyZWFtaW5nUmVhY3RSZXNwb25zZT47XG5cbmNvbnN0IGdldFN0cmVhbWVkUmVzcG9uc2UgPSBhc3luYyAoXG4gIGFwaTogc3RyaW5nIHwgU3RyZWFtaW5nUmVhY3RSZXNwb25zZUFjdGlvbixcbiAgY2hhdFJlcXVlc3Q6IENoYXRSZXF1ZXN0LFxuICBtdXRhdGU6IEtleWVkTXV0YXRvcjxNZXNzYWdlW10+LFxuICBtdXRhdGVTdHJlYW1EYXRhOiBLZXllZE11dGF0b3I8SlNPTlZhbHVlW10gfCB1bmRlZmluZWQ+LFxuICBleGlzdGluZ0RhdGE6IEpTT05WYWx1ZVtdIHwgdW5kZWZpbmVkLFxuICBleHRyYU1ldGFkYXRhUmVmOiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PGFueT4sXG4gIG1lc3NhZ2VzUmVmOiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PE1lc3NhZ2VbXT4sXG4gIGFib3J0Q29udHJvbGxlclJlZjogUmVhY3QuTXV0YWJsZVJlZk9iamVjdDxBYm9ydENvbnRyb2xsZXIgfCBudWxsPixcbiAgZ2VuZXJhdGVJZDogSWRHZW5lcmF0b3IsXG4gIHN0cmVhbU1vZGU/OiAnc3RyZWFtLWRhdGEnIHwgJ3RleHQnLFxuICBvbkZpbmlzaD86IChtZXNzYWdlOiBNZXNzYWdlKSA9PiB2b2lkLFxuICBvblJlc3BvbnNlPzogKHJlc3BvbnNlOiBSZXNwb25zZSkgPT4gdm9pZCB8IFByb21pc2U8dm9pZD4sXG4gIHNlbmRFeHRyYU1lc3NhZ2VGaWVsZHM/OiBib29sZWFuLFxuKSA9PiB7XG4gIC8vIERvIGFuIG9wdGltaXN0aWMgdXBkYXRlIHRvIHRoZSBjaGF0IHN0YXRlIHRvIHNob3cgdGhlIHVwZGF0ZWQgbWVzc2FnZXNcbiAgLy8gaW1tZWRpYXRlbHkuXG4gIGNvbnN0IHByZXZpb3VzTWVzc2FnZXMgPSBtZXNzYWdlc1JlZi5jdXJyZW50O1xuICBtdXRhdGUoY2hhdFJlcXVlc3QubWVzc2FnZXMsIGZhbHNlKTtcblxuICBjb25zdCBjb25zdHJ1Y3RlZE1lc3NhZ2VzUGF5bG9hZCA9IHNlbmRFeHRyYU1lc3NhZ2VGaWVsZHNcbiAgICA/IGNoYXRSZXF1ZXN0Lm1lc3NhZ2VzXG4gICAgOiBjaGF0UmVxdWVzdC5tZXNzYWdlcy5tYXAoXG4gICAgICAgICh7IHJvbGUsIGNvbnRlbnQsIG5hbWUsIGZ1bmN0aW9uX2NhbGwsIHRvb2xfY2FsbHMsIHRvb2xfY2FsbF9pZCB9KSA9PiAoe1xuICAgICAgICAgIHJvbGUsXG4gICAgICAgICAgY29udGVudCxcbiAgICAgICAgICB0b29sX2NhbGxfaWQsXG4gICAgICAgICAgLi4uKG5hbWUgIT09IHVuZGVmaW5lZCAmJiB7IG5hbWUgfSksXG4gICAgICAgICAgLi4uKGZ1bmN0aW9uX2NhbGwgIT09IHVuZGVmaW5lZCAmJiB7XG4gICAgICAgICAgICBmdW5jdGlvbl9jYWxsOiBmdW5jdGlvbl9jYWxsLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIC4uLih0b29sX2NhbGxzICE9PSB1bmRlZmluZWQgJiYge1xuICAgICAgICAgICAgdG9vbF9jYWxsczogdG9vbF9jYWxscyxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSksXG4gICAgICApO1xuXG4gIGlmICh0eXBlb2YgYXBpICE9PSAnc3RyaW5nJykge1xuICAgIC8vIEluIHRoaXMgY2FzZSwgd2UgYXJlIGhhbmRsaW5nIGEgU2VydmVyIEFjdGlvbi4gTm8gY29tcGxleCBtb2RlIGhhbmRsaW5nIG5lZWRlZC5cblxuICAgIGNvbnN0IHJlcGx5SWQgPSBnZW5lcmF0ZUlkKCk7XG4gICAgY29uc3QgY3JlYXRlZEF0ID0gbmV3IERhdGUoKTtcbiAgICBsZXQgcmVzcG9uc2VNZXNzYWdlOiBNZXNzYWdlID0ge1xuICAgICAgaWQ6IHJlcGx5SWQsXG4gICAgICBjcmVhdGVkQXQsXG4gICAgICBjb250ZW50OiAnJyxcbiAgICAgIHJvbGU6ICdhc3Npc3RhbnQnLFxuICAgIH07XG5cbiAgICBhc3luYyBmdW5jdGlvbiByZWFkUm93KHByb21pc2U6IFByb21pc2U8UmVhY3RSZXNwb25zZVJvdz4pIHtcbiAgICAgIGNvbnN0IHsgY29udGVudCwgdWksIG5leHQgfSA9IGF3YWl0IHByb21pc2U7XG5cbiAgICAgIC8vIFRPRE86IEhhbmRsZSBmdW5jdGlvbiBjYWxscy5cbiAgICAgIHJlc3BvbnNlTWVzc2FnZVsnY29udGVudCddID0gY29udGVudDtcbiAgICAgIHJlc3BvbnNlTWVzc2FnZVsndWknXSA9IGF3YWl0IHVpO1xuXG4gICAgICBtdXRhdGUoWy4uLmNoYXRSZXF1ZXN0Lm1lc3NhZ2VzLCB7IC4uLnJlc3BvbnNlTWVzc2FnZSB9XSwgZmFsc2UpO1xuXG4gICAgICBpZiAobmV4dCkge1xuICAgICAgICBhd2FpdCByZWFkUm93KG5leHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBwcm9taXNlID0gYXBpKHtcbiAgICAgICAgbWVzc2FnZXM6IGNvbnN0cnVjdGVkTWVzc2FnZXNQYXlsb2FkIGFzIE1lc3NhZ2VbXSxcbiAgICAgICAgZGF0YTogY2hhdFJlcXVlc3QuZGF0YSxcbiAgICAgIH0pIGFzIFByb21pc2U8UmVhY3RSZXNwb25zZVJvdz47XG4gICAgICBhd2FpdCByZWFkUm93KHByb21pc2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIFJlc3RvcmUgdGhlIHByZXZpb3VzIG1lc3NhZ2VzIGlmIHRoZSByZXF1ZXN0IGZhaWxzLlxuICAgICAgbXV0YXRlKHByZXZpb3VzTWVzc2FnZXMsIGZhbHNlKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuXG4gICAgaWYgKG9uRmluaXNoKSB7XG4gICAgICBvbkZpbmlzaChyZXNwb25zZU1lc3NhZ2UpO1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZU1lc3NhZ2U7XG4gIH1cblxuICByZXR1cm4gYXdhaXQgY2FsbENoYXRBcGkoe1xuICAgIGFwaSxcbiAgICBtZXNzYWdlczogY29uc3RydWN0ZWRNZXNzYWdlc1BheWxvYWQsXG4gICAgYm9keToge1xuICAgICAgZGF0YTogY2hhdFJlcXVlc3QuZGF0YSxcbiAgICAgIC4uLmV4dHJhTWV0YWRhdGFSZWYuY3VycmVudC5ib2R5LFxuICAgICAgLi4uY2hhdFJlcXVlc3Qub3B0aW9ucz8uYm9keSxcbiAgICAgIC4uLihjaGF0UmVxdWVzdC5mdW5jdGlvbnMgIT09IHVuZGVmaW5lZCAmJiB7XG4gICAgICAgIGZ1bmN0aW9uczogY2hhdFJlcXVlc3QuZnVuY3Rpb25zLFxuICAgICAgfSksXG4gICAgICAuLi4oY2hhdFJlcXVlc3QuZnVuY3Rpb25fY2FsbCAhPT0gdW5kZWZpbmVkICYmIHtcbiAgICAgICAgZnVuY3Rpb25fY2FsbDogY2hhdFJlcXVlc3QuZnVuY3Rpb25fY2FsbCxcbiAgICAgIH0pLFxuICAgICAgLi4uKGNoYXRSZXF1ZXN0LnRvb2xzICE9PSB1bmRlZmluZWQgJiYge1xuICAgICAgICB0b29sczogY2hhdFJlcXVlc3QudG9vbHMsXG4gICAgICB9KSxcbiAgICAgIC4uLihjaGF0UmVxdWVzdC50b29sX2Nob2ljZSAhPT0gdW5kZWZpbmVkICYmIHtcbiAgICAgICAgdG9vbF9jaG9pY2U6IGNoYXRSZXF1ZXN0LnRvb2xfY2hvaWNlLFxuICAgICAgfSksXG4gICAgfSxcbiAgICBzdHJlYW1Nb2RlLFxuICAgIGNyZWRlbnRpYWxzOiBleHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQuY3JlZGVudGlhbHMsXG4gICAgaGVhZGVyczoge1xuICAgICAgLi4uZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LmhlYWRlcnMsXG4gICAgICAuLi5jaGF0UmVxdWVzdC5vcHRpb25zPy5oZWFkZXJzLFxuICAgIH0sXG4gICAgYWJvcnRDb250cm9sbGVyOiAoKSA9PiBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCxcbiAgICByZXN0b3JlTWVzc2FnZXNPbkZhaWx1cmUoKSB7XG4gICAgICBtdXRhdGUocHJldmlvdXNNZXNzYWdlcywgZmFsc2UpO1xuICAgIH0sXG4gICAgb25SZXNwb25zZSxcbiAgICBvblVwZGF0ZShtZXJnZWQsIGRhdGEpIHtcbiAgICAgIG11dGF0ZShbLi4uY2hhdFJlcXVlc3QubWVzc2FnZXMsIC4uLm1lcmdlZF0sIGZhbHNlKTtcbiAgICAgIG11dGF0ZVN0cmVhbURhdGEoWy4uLihleGlzdGluZ0RhdGEgfHwgW10pLCAuLi4oZGF0YSB8fCBbXSldLCBmYWxzZSk7XG4gICAgfSxcbiAgICBvbkZpbmlzaCxcbiAgICBnZW5lcmF0ZUlkLFxuICB9KTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VDaGF0KHtcbiAgYXBpID0gJy9hcGkvY2hhdCcsXG4gIGlkLFxuICBpbml0aWFsTWVzc2FnZXMsXG4gIGluaXRpYWxJbnB1dCA9ICcnLFxuICBzZW5kRXh0cmFNZXNzYWdlRmllbGRzLFxuICBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwsXG4gIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsLFxuICBzdHJlYW1Nb2RlLFxuICBvblJlc3BvbnNlLFxuICBvbkZpbmlzaCxcbiAgb25FcnJvcixcbiAgY3JlZGVudGlhbHMsXG4gIGhlYWRlcnMsXG4gIGJvZHksXG4gIGdlbmVyYXRlSWQgPSBnZW5lcmF0ZUlkRnVuYyxcbn06IE9taXQ8VXNlQ2hhdE9wdGlvbnMsICdhcGknPiAmIHtcbiAgYXBpPzogc3RyaW5nIHwgU3RyZWFtaW5nUmVhY3RSZXNwb25zZUFjdGlvbjtcbiAga2V5Pzogc3RyaW5nO1xufSA9IHt9KTogVXNlQ2hhdEhlbHBlcnMge1xuICAvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBpZCBmb3IgdGhlIGNoYXQgaWYgbm90IHByb3ZpZGVkLlxuICBjb25zdCBob29rSWQgPSB1c2VJZCgpO1xuICBjb25zdCBpZEtleSA9IGlkID8/IGhvb2tJZDtcbiAgY29uc3QgY2hhdEtleSA9IHR5cGVvZiBhcGkgPT09ICdzdHJpbmcnID8gW2FwaSwgaWRLZXldIDogaWRLZXk7XG5cbiAgLy8gU3RvcmUgYSBlbXB0eSBhcnJheSBhcyB0aGUgaW5pdGlhbCBtZXNzYWdlc1xuICAvLyAoaW5zdGVhZCBvZiB1c2luZyBhIGRlZmF1bHQgcGFyYW1ldGVyIHZhbHVlIHRoYXQgZ2V0cyByZS1jcmVhdGVkIGVhY2ggdGltZSlcbiAgLy8gdG8gYXZvaWQgcmUtcmVuZGVyczpcbiAgY29uc3QgW2luaXRpYWxNZXNzYWdlc0ZhbGxiYWNrXSA9IHVzZVN0YXRlKFtdKTtcblxuICAvLyBTdG9yZSB0aGUgY2hhdCBzdGF0ZSBpbiBTV1IsIHVzaW5nIHRoZSBjaGF0SWQgYXMgdGhlIGtleSB0byBzaGFyZSBzdGF0ZXMuXG4gIGNvbnN0IHsgZGF0YTogbWVzc2FnZXMsIG11dGF0ZSB9ID0gdXNlU1dSPE1lc3NhZ2VbXT4oXG4gICAgW2NoYXRLZXksICdtZXNzYWdlcyddLFxuICAgIG51bGwsXG4gICAgeyBmYWxsYmFja0RhdGE6IGluaXRpYWxNZXNzYWdlcyA/PyBpbml0aWFsTWVzc2FnZXNGYWxsYmFjayB9LFxuICApO1xuXG4gIC8vIFdlIHN0b3JlIGxvYWRpbmcgc3RhdGUgaW4gYW5vdGhlciBob29rIHRvIHN5bmMgbG9hZGluZyBzdGF0ZXMgYWNyb3NzIGhvb2sgaW52b2NhdGlvbnNcbiAgY29uc3QgeyBkYXRhOiBpc0xvYWRpbmcgPSBmYWxzZSwgbXV0YXRlOiBtdXRhdGVMb2FkaW5nIH0gPSB1c2VTV1I8Ym9vbGVhbj4oXG4gICAgW2NoYXRLZXksICdsb2FkaW5nJ10sXG4gICAgbnVsbCxcbiAgKTtcblxuICBjb25zdCB7IGRhdGE6IHN0cmVhbURhdGEsIG11dGF0ZTogbXV0YXRlU3RyZWFtRGF0YSB9ID0gdXNlU1dSPFxuICAgIEpTT05WYWx1ZVtdIHwgdW5kZWZpbmVkXG4gID4oW2NoYXRLZXksICdzdHJlYW1EYXRhJ10sIG51bGwpO1xuXG4gIGNvbnN0IHsgZGF0YTogZXJyb3IgPSB1bmRlZmluZWQsIG11dGF0ZTogc2V0RXJyb3IgfSA9IHVzZVNXUjxcbiAgICB1bmRlZmluZWQgfCBFcnJvclxuICA+KFtjaGF0S2V5LCAnZXJyb3InXSwgbnVsbCk7XG5cbiAgLy8gS2VlcCB0aGUgbGF0ZXN0IG1lc3NhZ2VzIGluIGEgcmVmLlxuICBjb25zdCBtZXNzYWdlc1JlZiA9IHVzZVJlZjxNZXNzYWdlW10+KG1lc3NhZ2VzIHx8IFtdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBtZXNzYWdlc1JlZi5jdXJyZW50ID0gbWVzc2FnZXMgfHwgW107XG4gIH0sIFttZXNzYWdlc10pO1xuXG4gIC8vIEFib3J0IGNvbnRyb2xsZXIgdG8gY2FuY2VsIHRoZSBjdXJyZW50IEFQSSBjYWxsLlxuICBjb25zdCBhYm9ydENvbnRyb2xsZXJSZWYgPSB1c2VSZWY8QWJvcnRDb250cm9sbGVyIHwgbnVsbD4obnVsbCk7XG5cbiAgY29uc3QgZXh0cmFNZXRhZGF0YVJlZiA9IHVzZVJlZih7XG4gICAgY3JlZGVudGlhbHMsXG4gICAgaGVhZGVycyxcbiAgICBib2R5LFxuICB9KTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGV4dHJhTWV0YWRhdGFSZWYuY3VycmVudCA9IHtcbiAgICAgIGNyZWRlbnRpYWxzLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGJvZHksXG4gICAgfTtcbiAgfSwgW2NyZWRlbnRpYWxzLCBoZWFkZXJzLCBib2R5XSk7XG5cbiAgY29uc3QgdHJpZ2dlclJlcXVlc3QgPSB1c2VDYWxsYmFjayhcbiAgICBhc3luYyAoY2hhdFJlcXVlc3Q6IENoYXRSZXF1ZXN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBtdXRhdGVMb2FkaW5nKHRydWUpO1xuICAgICAgICBzZXRFcnJvcih1bmRlZmluZWQpO1xuXG4gICAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQgPSBhYm9ydENvbnRyb2xsZXI7XG5cbiAgICAgICAgYXdhaXQgcHJvY2Vzc0NoYXRTdHJlYW0oe1xuICAgICAgICAgIGdldFN0cmVhbWVkUmVzcG9uc2U6ICgpID0+XG4gICAgICAgICAgICBnZXRTdHJlYW1lZFJlc3BvbnNlKFxuICAgICAgICAgICAgICBhcGksXG4gICAgICAgICAgICAgIGNoYXRSZXF1ZXN0LFxuICAgICAgICAgICAgICBtdXRhdGUsXG4gICAgICAgICAgICAgIG11dGF0ZVN0cmVhbURhdGEsXG4gICAgICAgICAgICAgIHN0cmVhbURhdGEhLFxuICAgICAgICAgICAgICBleHRyYU1ldGFkYXRhUmVmLFxuICAgICAgICAgICAgICBtZXNzYWdlc1JlZixcbiAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyUmVmLFxuICAgICAgICAgICAgICBnZW5lcmF0ZUlkLFxuICAgICAgICAgICAgICBzdHJlYW1Nb2RlLFxuICAgICAgICAgICAgICBvbkZpbmlzaCxcbiAgICAgICAgICAgICAgb25SZXNwb25zZSxcbiAgICAgICAgICAgICAgc2VuZEV4dHJhTWVzc2FnZUZpZWxkcyxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsLFxuICAgICAgICAgIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsLFxuICAgICAgICAgIHVwZGF0ZUNoYXRSZXF1ZXN0OiBjaGF0UmVxdWVzdFBhcmFtID0+IHtcbiAgICAgICAgICAgIGNoYXRSZXF1ZXN0ID0gY2hhdFJlcXVlc3RQYXJhbTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldEN1cnJlbnRNZXNzYWdlczogKCkgPT4gbWVzc2FnZXNSZWYuY3VycmVudCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIElnbm9yZSBhYm9ydCBlcnJvcnMgYXMgdGhleSBhcmUgZXhwZWN0ZWQuXG4gICAgICAgIGlmICgoZXJyIGFzIGFueSkubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9uRXJyb3IgJiYgZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICBzZXRFcnJvcihlcnIgYXMgRXJyb3IpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgbXV0YXRlTG9hZGluZyhmYWxzZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbXG4gICAgICBtdXRhdGUsXG4gICAgICBtdXRhdGVMb2FkaW5nLFxuICAgICAgYXBpLFxuICAgICAgZXh0cmFNZXRhZGF0YVJlZixcbiAgICAgIG9uUmVzcG9uc2UsXG4gICAgICBvbkZpbmlzaCxcbiAgICAgIG9uRXJyb3IsXG4gICAgICBzZXRFcnJvcixcbiAgICAgIG11dGF0ZVN0cmVhbURhdGEsXG4gICAgICBzdHJlYW1EYXRhLFxuICAgICAgc2VuZEV4dHJhTWVzc2FnZUZpZWxkcyxcbiAgICAgIGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCxcbiAgICAgIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsLFxuICAgICAgbWVzc2FnZXNSZWYsXG4gICAgICBhYm9ydENvbnRyb2xsZXJSZWYsXG4gICAgICBnZW5lcmF0ZUlkLFxuICAgIF0sXG4gICk7XG5cbiAgY29uc3QgYXBwZW5kID0gdXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKFxuICAgICAgbWVzc2FnZTogTWVzc2FnZSB8IENyZWF0ZU1lc3NhZ2UsXG4gICAgICB7XG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGZ1bmN0aW9ucyxcbiAgICAgICAgZnVuY3Rpb25fY2FsbCxcbiAgICAgICAgdG9vbHMsXG4gICAgICAgIHRvb2xfY2hvaWNlLFxuICAgICAgICBkYXRhLFxuICAgICAgfTogQ2hhdFJlcXVlc3RPcHRpb25zID0ge30sXG4gICAgKSA9PiB7XG4gICAgICBpZiAoIW1lc3NhZ2UuaWQpIHtcbiAgICAgICAgbWVzc2FnZS5pZCA9IGdlbmVyYXRlSWQoKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2hhdFJlcXVlc3Q6IENoYXRSZXF1ZXN0ID0ge1xuICAgICAgICBtZXNzYWdlczogbWVzc2FnZXNSZWYuY3VycmVudC5jb25jYXQobWVzc2FnZSBhcyBNZXNzYWdlKSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgLi4uKGZ1bmN0aW9ucyAhPT0gdW5kZWZpbmVkICYmIHsgZnVuY3Rpb25zIH0pLFxuICAgICAgICAuLi4oZnVuY3Rpb25fY2FsbCAhPT0gdW5kZWZpbmVkICYmIHsgZnVuY3Rpb25fY2FsbCB9KSxcbiAgICAgICAgLi4uKHRvb2xzICE9PSB1bmRlZmluZWQgJiYgeyB0b29scyB9KSxcbiAgICAgICAgLi4uKHRvb2xfY2hvaWNlICE9PSB1bmRlZmluZWQgJiYgeyB0b29sX2Nob2ljZSB9KSxcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB0cmlnZ2VyUmVxdWVzdChjaGF0UmVxdWVzdCk7XG4gICAgfSxcbiAgICBbdHJpZ2dlclJlcXVlc3QsIGdlbmVyYXRlSWRdLFxuICApO1xuXG4gIGNvbnN0IHJlbG9hZCA9IHVzZUNhbGxiYWNrKFxuICAgIGFzeW5jICh7XG4gICAgICBvcHRpb25zLFxuICAgICAgZnVuY3Rpb25zLFxuICAgICAgZnVuY3Rpb25fY2FsbCxcbiAgICAgIHRvb2xzLFxuICAgICAgdG9vbF9jaG9pY2UsXG4gICAgfTogQ2hhdFJlcXVlc3RPcHRpb25zID0ge30pID0+IHtcbiAgICAgIGlmIChtZXNzYWdlc1JlZi5jdXJyZW50Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgICAgIC8vIFJlbW92ZSBsYXN0IGFzc2lzdGFudCBtZXNzYWdlIGFuZCByZXRyeSBsYXN0IHVzZXIgbWVzc2FnZS5cbiAgICAgIGNvbnN0IGxhc3RNZXNzYWdlID0gbWVzc2FnZXNSZWYuY3VycmVudFttZXNzYWdlc1JlZi5jdXJyZW50Lmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGxhc3RNZXNzYWdlLnJvbGUgPT09ICdhc3Npc3RhbnQnKSB7XG4gICAgICAgIGNvbnN0IGNoYXRSZXF1ZXN0OiBDaGF0UmVxdWVzdCA9IHtcbiAgICAgICAgICBtZXNzYWdlczogbWVzc2FnZXNSZWYuY3VycmVudC5zbGljZSgwLCAtMSksXG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAuLi4oZnVuY3Rpb25zICE9PSB1bmRlZmluZWQgJiYgeyBmdW5jdGlvbnMgfSksXG4gICAgICAgICAgLi4uKGZ1bmN0aW9uX2NhbGwgIT09IHVuZGVmaW5lZCAmJiB7IGZ1bmN0aW9uX2NhbGwgfSksXG4gICAgICAgICAgLi4uKHRvb2xzICE9PSB1bmRlZmluZWQgJiYgeyB0b29scyB9KSxcbiAgICAgICAgICAuLi4odG9vbF9jaG9pY2UgIT09IHVuZGVmaW5lZCAmJiB7IHRvb2xfY2hvaWNlIH0pLFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0cmlnZ2VyUmVxdWVzdChjaGF0UmVxdWVzdCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNoYXRSZXF1ZXN0OiBDaGF0UmVxdWVzdCA9IHtcbiAgICAgICAgbWVzc2FnZXM6IG1lc3NhZ2VzUmVmLmN1cnJlbnQsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIC4uLihmdW5jdGlvbnMgIT09IHVuZGVmaW5lZCAmJiB7IGZ1bmN0aW9ucyB9KSxcbiAgICAgICAgLi4uKGZ1bmN0aW9uX2NhbGwgIT09IHVuZGVmaW5lZCAmJiB7IGZ1bmN0aW9uX2NhbGwgfSksXG4gICAgICAgIC4uLih0b29scyAhPT0gdW5kZWZpbmVkICYmIHsgdG9vbHMgfSksXG4gICAgICAgIC4uLih0b29sX2Nob2ljZSAhPT0gdW5kZWZpbmVkICYmIHsgdG9vbF9jaG9pY2UgfSksXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gdHJpZ2dlclJlcXVlc3QoY2hhdFJlcXVlc3QpO1xuICAgIH0sXG4gICAgW3RyaWdnZXJSZXF1ZXN0XSxcbiAgKTtcblxuICBjb25zdCBzdG9wID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCkge1xuICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQuYWJvcnQoKTtcbiAgICAgIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH0sIFtdKTtcblxuICBjb25zdCBzZXRNZXNzYWdlcyA9IHVzZUNhbGxiYWNrKFxuICAgIChtZXNzYWdlczogTWVzc2FnZVtdKSA9PiB7XG4gICAgICBtdXRhdGUobWVzc2FnZXMsIGZhbHNlKTtcbiAgICAgIG1lc3NhZ2VzUmVmLmN1cnJlbnQgPSBtZXNzYWdlcztcbiAgICB9LFxuICAgIFttdXRhdGVdLFxuICApO1xuXG4gIC8vIElucHV0IHN0YXRlIGFuZCBoYW5kbGVycy5cbiAgY29uc3QgW2lucHV0LCBzZXRJbnB1dF0gPSB1c2VTdGF0ZShpbml0aWFsSW5wdXQpO1xuXG4gIGNvbnN0IGhhbmRsZVN1Ym1pdCA9IHVzZUNhbGxiYWNrKFxuICAgIChcbiAgICAgIGU6IFJlYWN0LkZvcm1FdmVudDxIVE1MRm9ybUVsZW1lbnQ+LFxuICAgICAgb3B0aW9uczogQ2hhdFJlcXVlc3RPcHRpb25zID0ge30sXG4gICAgICBtZXRhZGF0YT86IE9iamVjdCxcbiAgICApID0+IHtcbiAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICBleHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQgPSB7XG4gICAgICAgICAgLi4uZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LFxuICAgICAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAoIWlucHV0KSByZXR1cm47XG5cbiAgICAgIGFwcGVuZChcbiAgICAgICAge1xuICAgICAgICAgIGNvbnRlbnQ6IGlucHV0LFxuICAgICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApO1xuICAgICAgc2V0SW5wdXQoJycpO1xuICAgIH0sXG4gICAgW2lucHV0LCBhcHBlbmRdLFxuICApO1xuXG4gIGNvbnN0IGhhbmRsZUlucHV0Q2hhbmdlID0gKGU6IGFueSkgPT4ge1xuICAgIHNldElucHV0KGUudGFyZ2V0LnZhbHVlKTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG1lc3NhZ2VzOiBtZXNzYWdlcyB8fCBbXSxcbiAgICBlcnJvcixcbiAgICBhcHBlbmQsXG4gICAgcmVsb2FkLFxuICAgIHN0b3AsXG4gICAgc2V0TWVzc2FnZXMsXG4gICAgaW5wdXQsXG4gICAgc2V0SW5wdXQsXG4gICAgaGFuZGxlSW5wdXRDaGFuZ2UsXG4gICAgaGFuZGxlU3VibWl0LFxuICAgIGlzTG9hZGluZyxcbiAgICBkYXRhOiBzdHJlYW1EYXRhLFxuICB9O1xufVxuIiwiaW1wb3J0IHtcbiAgQXNzaXN0YW50TWVzc2FnZSxcbiAgRGF0YU1lc3NhZ2UsXG4gIEZ1bmN0aW9uQ2FsbCxcbiAgSlNPTlZhbHVlLFxuICBUb29sQ2FsbCxcbn0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBTdHJlYW1TdHJpbmcgfSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGludGVyZmFjZSBTdHJlYW1QYXJ0PENPREUgZXh0ZW5kcyBzdHJpbmcsIE5BTUUgZXh0ZW5kcyBzdHJpbmcsIFRZUEU+IHtcbiAgY29kZTogQ09ERTtcbiAgbmFtZTogTkFNRTtcbiAgcGFyc2U6ICh2YWx1ZTogSlNPTlZhbHVlKSA9PiB7IHR5cGU6IE5BTUU7IHZhbHVlOiBUWVBFIH07XG59XG5cbmNvbnN0IHRleHRTdHJlYW1QYXJ0OiBTdHJlYW1QYXJ0PCcwJywgJ3RleHQnLCBzdHJpbmc+ID0ge1xuICBjb2RlOiAnMCcsXG4gIG5hbWU6ICd0ZXh0JyxcbiAgcGFyc2U6ICh2YWx1ZTogSlNPTlZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJ0ZXh0XCIgcGFydHMgZXhwZWN0IGEgc3RyaW5nIHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiAndGV4dCcsIHZhbHVlIH07XG4gIH0sXG59O1xuXG5jb25zdCBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0OiBTdHJlYW1QYXJ0PFxuICAnMScsXG4gICdmdW5jdGlvbl9jYWxsJyxcbiAgeyBmdW5jdGlvbl9jYWxsOiBGdW5jdGlvbkNhbGwgfVxuPiA9IHtcbiAgY29kZTogJzEnLFxuICBuYW1lOiAnZnVuY3Rpb25fY2FsbCcsXG4gIHBhcnNlOiAodmFsdWU6IEpTT05WYWx1ZSkgPT4ge1xuICAgIGlmIChcbiAgICAgIHZhbHVlID09IG51bGwgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICEoJ2Z1bmN0aW9uX2NhbGwnIGluIHZhbHVlKSB8fFxuICAgICAgdHlwZW9mIHZhbHVlLmZ1bmN0aW9uX2NhbGwgIT09ICdvYmplY3QnIHx8XG4gICAgICB2YWx1ZS5mdW5jdGlvbl9jYWxsID09IG51bGwgfHxcbiAgICAgICEoJ25hbWUnIGluIHZhbHVlLmZ1bmN0aW9uX2NhbGwpIHx8XG4gICAgICAhKCdhcmd1bWVudHMnIGluIHZhbHVlLmZ1bmN0aW9uX2NhbGwpIHx8XG4gICAgICB0eXBlb2YgdmFsdWUuZnVuY3Rpb25fY2FsbC5uYW1lICE9PSAnc3RyaW5nJyB8fFxuICAgICAgdHlwZW9mIHZhbHVlLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzICE9PSAnc3RyaW5nJ1xuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJmdW5jdGlvbl9jYWxsXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJmdW5jdGlvbl9jYWxsXCIgcHJvcGVydHkuJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdmdW5jdGlvbl9jYWxsJyxcbiAgICAgIHZhbHVlOiB2YWx1ZSBhcyB1bmtub3duIGFzIHsgZnVuY3Rpb25fY2FsbDogRnVuY3Rpb25DYWxsIH0sXG4gICAgfTtcbiAgfSxcbn07XG5cbmNvbnN0IGRhdGFTdHJlYW1QYXJ0OiBTdHJlYW1QYXJ0PCcyJywgJ2RhdGEnLCBBcnJheTxKU09OVmFsdWU+PiA9IHtcbiAgY29kZTogJzInLFxuICBuYW1lOiAnZGF0YScsXG4gIHBhcnNlOiAodmFsdWU6IEpTT05WYWx1ZSkgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJkYXRhXCIgcGFydHMgZXhwZWN0IGFuIGFycmF5IHZhbHVlLicpO1xuICAgIH1cblxuICAgIHJldHVybiB7IHR5cGU6ICdkYXRhJywgdmFsdWUgfTtcbiAgfSxcbn07XG5cbmNvbnN0IGVycm9yU3RyZWFtUGFydDogU3RyZWFtUGFydDwnMycsICdlcnJvcicsIHN0cmluZz4gPSB7XG4gIGNvZGU6ICczJyxcbiAgbmFtZTogJ2Vycm9yJyxcbiAgcGFyc2U6ICh2YWx1ZTogSlNPTlZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJlcnJvclwiIHBhcnRzIGV4cGVjdCBhIHN0cmluZyB2YWx1ZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogJ2Vycm9yJywgdmFsdWUgfTtcbiAgfSxcbn07XG5cbmNvbnN0IGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0OiBTdHJlYW1QYXJ0PFxuICAnNCcsXG4gICdhc3Npc3RhbnRfbWVzc2FnZScsXG4gIEFzc2lzdGFudE1lc3NhZ2Vcbj4gPSB7XG4gIGNvZGU6ICc0JyxcbiAgbmFtZTogJ2Fzc2lzdGFudF9tZXNzYWdlJyxcbiAgcGFyc2U6ICh2YWx1ZTogSlNPTlZhbHVlKSA9PiB7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fFxuICAgICAgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fFxuICAgICAgISgnaWQnIGluIHZhbHVlKSB8fFxuICAgICAgISgncm9sZScgaW4gdmFsdWUpIHx8XG4gICAgICAhKCdjb250ZW50JyBpbiB2YWx1ZSkgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZS5pZCAhPT0gJ3N0cmluZycgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZS5yb2xlICE9PSAnc3RyaW5nJyB8fFxuICAgICAgdmFsdWUucm9sZSAhPT0gJ2Fzc2lzdGFudCcgfHxcbiAgICAgICFBcnJheS5pc0FycmF5KHZhbHVlLmNvbnRlbnQpIHx8XG4gICAgICAhdmFsdWUuY29udGVudC5ldmVyeShcbiAgICAgICAgaXRlbSA9PlxuICAgICAgICAgIGl0ZW0gIT0gbnVsbCAmJlxuICAgICAgICAgIHR5cGVvZiBpdGVtID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICd0eXBlJyBpbiBpdGVtICYmXG4gICAgICAgICAgaXRlbS50eXBlID09PSAndGV4dCcgJiZcbiAgICAgICAgICAndGV4dCcgaW4gaXRlbSAmJlxuICAgICAgICAgIGl0ZW0udGV4dCAhPSBudWxsICYmXG4gICAgICAgICAgdHlwZW9mIGl0ZW0udGV4dCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAndmFsdWUnIGluIGl0ZW0udGV4dCAmJlxuICAgICAgICAgIHR5cGVvZiBpdGVtLnRleHQudmFsdWUgPT09ICdzdHJpbmcnLFxuICAgICAgKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJhc3Npc3RhbnRfbWVzc2FnZVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhbiBcImlkXCIsIFwicm9sZVwiLCBhbmQgXCJjb250ZW50XCIgcHJvcGVydHkuJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdhc3Npc3RhbnRfbWVzc2FnZScsXG4gICAgICB2YWx1ZTogdmFsdWUgYXMgQXNzaXN0YW50TWVzc2FnZSxcbiAgICB9O1xuICB9LFxufTtcblxuY29uc3QgYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0OiBTdHJlYW1QYXJ0PFxuICAnNScsXG4gICdhc3Npc3RhbnRfY29udHJvbF9kYXRhJyxcbiAge1xuICAgIHRocmVhZElkOiBzdHJpbmc7XG4gICAgbWVzc2FnZUlkOiBzdHJpbmc7XG4gIH1cbj4gPSB7XG4gIGNvZGU6ICc1JyxcbiAgbmFtZTogJ2Fzc2lzdGFudF9jb250cm9sX2RhdGEnLFxuICBwYXJzZTogKHZhbHVlOiBKU09OVmFsdWUpID0+IHtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSA9PSBudWxsIHx8XG4gICAgICB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8XG4gICAgICAhKCd0aHJlYWRJZCcgaW4gdmFsdWUpIHx8XG4gICAgICAhKCdtZXNzYWdlSWQnIGluIHZhbHVlKSB8fFxuICAgICAgdHlwZW9mIHZhbHVlLnRocmVhZElkICE9PSAnc3RyaW5nJyB8fFxuICAgICAgdHlwZW9mIHZhbHVlLm1lc3NhZ2VJZCAhPT0gJ3N0cmluZydcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiYXNzaXN0YW50X2NvbnRyb2xfZGF0YVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwidGhyZWFkSWRcIiBhbmQgXCJtZXNzYWdlSWRcIiBwcm9wZXJ0eS4nLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2Fzc2lzdGFudF9jb250cm9sX2RhdGEnLFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgdGhyZWFkSWQ6IHZhbHVlLnRocmVhZElkLFxuICAgICAgICBtZXNzYWdlSWQ6IHZhbHVlLm1lc3NhZ2VJZCxcbiAgICAgIH0sXG4gICAgfTtcbiAgfSxcbn07XG5cbmNvbnN0IGRhdGFNZXNzYWdlU3RyZWFtUGFydDogU3RyZWFtUGFydDwnNicsICdkYXRhX21lc3NhZ2UnLCBEYXRhTWVzc2FnZT4gPSB7XG4gIGNvZGU6ICc2JyxcbiAgbmFtZTogJ2RhdGFfbWVzc2FnZScsXG4gIHBhcnNlOiAodmFsdWU6IEpTT05WYWx1ZSkgPT4ge1xuICAgIGlmIChcbiAgICAgIHZhbHVlID09IG51bGwgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICEoJ3JvbGUnIGluIHZhbHVlKSB8fFxuICAgICAgISgnZGF0YScgaW4gdmFsdWUpIHx8XG4gICAgICB0eXBlb2YgdmFsdWUucm9sZSAhPT0gJ3N0cmluZycgfHxcbiAgICAgIHZhbHVlLnJvbGUgIT09ICdkYXRhJ1xuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJkYXRhX21lc3NhZ2VcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcInJvbGVcIiBhbmQgXCJkYXRhXCIgcHJvcGVydHkuJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdkYXRhX21lc3NhZ2UnLFxuICAgICAgdmFsdWU6IHZhbHVlIGFzIERhdGFNZXNzYWdlLFxuICAgIH07XG4gIH0sXG59O1xuXG5jb25zdCB0b29sQ2FsbFN0cmVhbVBhcnQ6IFN0cmVhbVBhcnQ8XG4gICc3JyxcbiAgJ3Rvb2xfY2FsbHMnLFxuICB7IHRvb2xfY2FsbHM6IFRvb2xDYWxsW10gfVxuPiA9IHtcbiAgY29kZTogJzcnLFxuICBuYW1lOiAndG9vbF9jYWxscycsXG4gIHBhcnNlOiAodmFsdWU6IEpTT05WYWx1ZSkgPT4ge1xuICAgIGlmIChcbiAgICAgIHZhbHVlID09IG51bGwgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICEoJ3Rvb2xfY2FsbHMnIGluIHZhbHVlKSB8fFxuICAgICAgdHlwZW9mIHZhbHVlLnRvb2xfY2FsbHMgIT09ICdvYmplY3QnIHx8XG4gICAgICB2YWx1ZS50b29sX2NhbGxzID09IG51bGwgfHxcbiAgICAgICFBcnJheS5pc0FycmF5KHZhbHVlLnRvb2xfY2FsbHMpIHx8XG4gICAgICB2YWx1ZS50b29sX2NhbGxzLnNvbWUoXG4gICAgICAgIHRjID0+XG4gICAgICAgICAgdGMgPT0gbnVsbCB8fFxuICAgICAgICAgIHR5cGVvZiB0YyAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAhKCdpZCcgaW4gdGMpIHx8XG4gICAgICAgICAgdHlwZW9mIHRjLmlkICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICEoJ3R5cGUnIGluIHRjKSB8fFxuICAgICAgICAgIHR5cGVvZiB0Yy50eXBlICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICEoJ2Z1bmN0aW9uJyBpbiB0YykgfHxcbiAgICAgICAgICB0Yy5mdW5jdGlvbiA9PSBudWxsIHx8XG4gICAgICAgICAgdHlwZW9mIHRjLmZ1bmN0aW9uICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICEoJ2FyZ3VtZW50cycgaW4gdGMuZnVuY3Rpb24pIHx8XG4gICAgICAgICAgdHlwZW9mIHRjLmZ1bmN0aW9uLm5hbWUgIT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgdHlwZW9mIHRjLmZ1bmN0aW9uLmFyZ3VtZW50cyAhPT0gJ3N0cmluZycsXG4gICAgICApXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcInRvb2xfY2FsbHNcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBUb29sQ2FsbFBheWxvYWQuJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICd0b29sX2NhbGxzJyxcbiAgICAgIHZhbHVlOiB2YWx1ZSBhcyB1bmtub3duIGFzIHsgdG9vbF9jYWxsczogVG9vbENhbGxbXSB9LFxuICAgIH07XG4gIH0sXG59O1xuXG5jb25zdCBtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0OiBTdHJlYW1QYXJ0PFxuICAnOCcsXG4gICdtZXNzYWdlX2Fubm90YXRpb25zJyxcbiAgQXJyYXk8SlNPTlZhbHVlPlxuPiA9IHtcbiAgY29kZTogJzgnLFxuICBuYW1lOiAnbWVzc2FnZV9hbm5vdGF0aW9ucycsXG4gIHBhcnNlOiAodmFsdWU6IEpTT05WYWx1ZSkgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJtZXNzYWdlX2Fubm90YXRpb25zXCIgcGFydHMgZXhwZWN0IGFuIGFycmF5IHZhbHVlLicpO1xuICAgIH1cblxuICAgIHJldHVybiB7IHR5cGU6ICdtZXNzYWdlX2Fubm90YXRpb25zJywgdmFsdWUgfTtcbiAgfSxcbn07XG5cbmNvbnN0IHN0cmVhbVBhcnRzID0gW1xuICB0ZXh0U3RyZWFtUGFydCxcbiAgZnVuY3Rpb25DYWxsU3RyZWFtUGFydCxcbiAgZGF0YVN0cmVhbVBhcnQsXG4gIGVycm9yU3RyZWFtUGFydCxcbiAgYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQsXG4gIGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydCxcbiAgZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0LFxuICB0b29sQ2FsbFN0cmVhbVBhcnQsXG4gIG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQsXG5dIGFzIGNvbnN0O1xuXG4vLyB1bmlvbiB0eXBlIG9mIGFsbCBzdHJlYW0gcGFydHNcbnR5cGUgU3RyZWFtUGFydHMgPVxuICB8IHR5cGVvZiB0ZXh0U3RyZWFtUGFydFxuICB8IHR5cGVvZiBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0XG4gIHwgdHlwZW9mIGRhdGFTdHJlYW1QYXJ0XG4gIHwgdHlwZW9mIGVycm9yU3RyZWFtUGFydFxuICB8IHR5cGVvZiBhc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydFxuICB8IHR5cGVvZiBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnRcbiAgfCB0eXBlb2YgZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0XG4gIHwgdHlwZW9mIHRvb2xDYWxsU3RyZWFtUGFydFxuICB8IHR5cGVvZiBtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0O1xuLyoqXG4gKiBNYXBzIHRoZSB0eXBlIG9mIGEgc3RyZWFtIHBhcnQgdG8gaXRzIHZhbHVlIHR5cGUuXG4gKi9cbnR5cGUgU3RyZWFtUGFydFZhbHVlVHlwZSA9IHtcbiAgW1AgaW4gU3RyZWFtUGFydHMgYXMgUFsnbmFtZSddXTogUmV0dXJuVHlwZTxQWydwYXJzZSddPlsndmFsdWUnXTtcbn07XG5cbmV4cG9ydCB0eXBlIFN0cmVhbVBhcnRUeXBlID1cbiAgfCBSZXR1cm5UeXBlPHR5cGVvZiB0ZXh0U3RyZWFtUGFydC5wYXJzZT5cbiAgfCBSZXR1cm5UeXBlPHR5cGVvZiBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0LnBhcnNlPlxuICB8IFJldHVyblR5cGU8dHlwZW9mIGRhdGFTdHJlYW1QYXJ0LnBhcnNlPlxuICB8IFJldHVyblR5cGU8dHlwZW9mIGVycm9yU3RyZWFtUGFydC5wYXJzZT5cbiAgfCBSZXR1cm5UeXBlPHR5cGVvZiBhc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydC5wYXJzZT5cbiAgfCBSZXR1cm5UeXBlPHR5cGVvZiBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQucGFyc2U+XG4gIHwgUmV0dXJuVHlwZTx0eXBlb2YgZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0LnBhcnNlPlxuICB8IFJldHVyblR5cGU8dHlwZW9mIHRvb2xDYWxsU3RyZWFtUGFydC5wYXJzZT5cbiAgfCBSZXR1cm5UeXBlPHR5cGVvZiBtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0LnBhcnNlPjtcblxuZXhwb3J0IGNvbnN0IHN0cmVhbVBhcnRzQnlDb2RlID0ge1xuICBbdGV4dFN0cmVhbVBhcnQuY29kZV06IHRleHRTdHJlYW1QYXJ0LFxuICBbZnVuY3Rpb25DYWxsU3RyZWFtUGFydC5jb2RlXTogZnVuY3Rpb25DYWxsU3RyZWFtUGFydCxcbiAgW2RhdGFTdHJlYW1QYXJ0LmNvZGVdOiBkYXRhU3RyZWFtUGFydCxcbiAgW2Vycm9yU3RyZWFtUGFydC5jb2RlXTogZXJyb3JTdHJlYW1QYXJ0LFxuICBbYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQuY29kZV06IGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0LFxuICBbYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0LmNvZGVdOiBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQsXG4gIFtkYXRhTWVzc2FnZVN0cmVhbVBhcnQuY29kZV06IGRhdGFNZXNzYWdlU3RyZWFtUGFydCxcbiAgW3Rvb2xDYWxsU3RyZWFtUGFydC5jb2RlXTogdG9vbENhbGxTdHJlYW1QYXJ0LFxuICBbbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydC5jb2RlXTogbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydCxcbn0gYXMgY29uc3Q7XG5cbi8qKlxuICogVGhlIG1hcCBvZiBwcmVmaXhlcyBmb3IgZGF0YSBpbiB0aGUgc3RyZWFtXG4gKlxuICogLSAwOiBUZXh0IGZyb20gdGhlIExMTSByZXNwb25zZVxuICogLSAxOiAoT3BlbkFJKSBmdW5jdGlvbl9jYWxsIHJlc3BvbnNlc1xuICogLSAyOiBjdXN0b20gSlNPTiBhZGRlZCBieSB0aGUgdXNlciB1c2luZyBgRGF0YWBcbiAqIC0gNjogKE9wZW5BSSkgdG9vbF9jYWxsIHJlc3BvbnNlc1xuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGBcbiAqIDA6VmVyY2VsXG4gKiAwOidzXG4gKiAwOiBBSVxuICogMDogQUlcbiAqIDA6IFNES1xuICogMDogaXMgZ3JlYXRcbiAqIDA6IVxuICogMjogeyBcInNvbWVKc29uXCI6IFwidmFsdWVcIiB9XG4gKiAxOiB7XCJmdW5jdGlvbl9jYWxsXCI6IHtcIm5hbWVcIjogXCJnZXRfY3VycmVudF93ZWF0aGVyXCIsIFwiYXJndW1lbnRzXCI6IFwie1xcXFxuXFxcXFwibG9jYXRpb25cXFxcXCI6IFxcXFxcIkNoYXJsb3R0ZXN2aWxsZSwgVmlyZ2luaWFcXFxcXCIsXFxcXG5cXFxcXCJmb3JtYXRcXFxcXCI6IFxcXFxcImNlbHNpdXNcXFxcXCJcXFxcbn1cIn19XG4gKiA2OiB7XCJ0b29sX2NhbGxcIjoge1wiaWRcIjogXCJ0b29sXzBcIiwgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIiwgXCJmdW5jdGlvblwiOiB7XCJuYW1lXCI6IFwiZ2V0X2N1cnJlbnRfd2VhdGhlclwiLCBcImFyZ3VtZW50c1wiOiBcIntcXFxcblxcXFxcImxvY2F0aW9uXFxcXFwiOiBcXFxcXCJDaGFybG90dGVzdmlsbGUsIFZpcmdpbmlhXFxcXFwiLFxcXFxuXFxcXFwiZm9ybWF0XFxcXFwiOiBcXFxcXCJjZWxzaXVzXFxcXFwiXFxcXG59XCJ9fX1cbiAqYGBgXG4gKi9cbmV4cG9ydCBjb25zdCBTdHJlYW1TdHJpbmdQcmVmaXhlcyA9IHtcbiAgW3RleHRTdHJlYW1QYXJ0Lm5hbWVdOiB0ZXh0U3RyZWFtUGFydC5jb2RlLFxuICBbZnVuY3Rpb25DYWxsU3RyZWFtUGFydC5uYW1lXTogZnVuY3Rpb25DYWxsU3RyZWFtUGFydC5jb2RlLFxuICBbZGF0YVN0cmVhbVBhcnQubmFtZV06IGRhdGFTdHJlYW1QYXJ0LmNvZGUsXG4gIFtlcnJvclN0cmVhbVBhcnQubmFtZV06IGVycm9yU3RyZWFtUGFydC5jb2RlLFxuICBbYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQubmFtZV06IGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0LmNvZGUsXG4gIFthc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQubmFtZV06IGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydC5jb2RlLFxuICBbZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0Lm5hbWVdOiBkYXRhTWVzc2FnZVN0cmVhbVBhcnQuY29kZSxcbiAgW3Rvb2xDYWxsU3RyZWFtUGFydC5uYW1lXTogdG9vbENhbGxTdHJlYW1QYXJ0LmNvZGUsXG4gIFttZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0Lm5hbWVdOiBtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0LmNvZGUsXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgY29uc3QgdmFsaWRDb2RlcyA9IHN0cmVhbVBhcnRzLm1hcChwYXJ0ID0+IHBhcnQuY29kZSk7XG5cbi8qKlxuUGFyc2VzIGEgc3RyZWFtIHBhcnQgZnJvbSBhIHN0cmluZy5cblxuQHBhcmFtIGxpbmUgVGhlIHN0cmluZyB0byBwYXJzZS5cbkByZXR1cm5zIFRoZSBwYXJzZWQgc3RyZWFtIHBhcnQuXG5AdGhyb3dzIEFuIGVycm9yIGlmIHRoZSBzdHJpbmcgY2Fubm90IGJlIHBhcnNlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHBhcnNlU3RyZWFtUGFydCA9IChsaW5lOiBzdHJpbmcpOiBTdHJlYW1QYXJ0VHlwZSA9PiB7XG4gIGNvbnN0IGZpcnN0U2VwYXJhdG9ySW5kZXggPSBsaW5lLmluZGV4T2YoJzonKTtcblxuICBpZiAoZmlyc3RTZXBhcmF0b3JJbmRleCA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBzdHJlYW0gc3RyaW5nLiBObyBzZXBhcmF0b3IgZm91bmQuJyk7XG4gIH1cblxuICBjb25zdCBwcmVmaXggPSBsaW5lLnNsaWNlKDAsIGZpcnN0U2VwYXJhdG9ySW5kZXgpO1xuXG4gIGlmICghdmFsaWRDb2Rlcy5pbmNsdWRlcyhwcmVmaXggYXMga2V5b2YgdHlwZW9mIHN0cmVhbVBhcnRzQnlDb2RlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIHN0cmVhbSBzdHJpbmcuIEludmFsaWQgY29kZSAke3ByZWZpeH0uYCk7XG4gIH1cblxuICBjb25zdCBjb2RlID0gcHJlZml4IGFzIGtleW9mIHR5cGVvZiBzdHJlYW1QYXJ0c0J5Q29kZTtcblxuICBjb25zdCB0ZXh0VmFsdWUgPSBsaW5lLnNsaWNlKGZpcnN0U2VwYXJhdG9ySW5kZXggKyAxKTtcbiAgY29uc3QganNvblZhbHVlOiBKU09OVmFsdWUgPSBKU09OLnBhcnNlKHRleHRWYWx1ZSk7XG5cbiAgcmV0dXJuIHN0cmVhbVBhcnRzQnlDb2RlW2NvZGVdLnBhcnNlKGpzb25WYWx1ZSk7XG59O1xuXG4vKipcblByZXBlbmRzIGEgc3RyaW5nIHdpdGggYSBwcmVmaXggZnJvbSB0aGUgYFN0cmVhbUNodW5rUHJlZml4ZXNgLCBKU09OLWlmaWVzIGl0LFxuYW5kIGFwcGVuZHMgYSBuZXcgbGluZS5cblxuSXQgZW5zdXJlcyB0eXBlLXNhZmV0eSBmb3IgdGhlIHBhcnQgdHlwZSBhbmQgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRTdHJlYW1QYXJ0PFQgZXh0ZW5kcyBrZXlvZiBTdHJlYW1QYXJ0VmFsdWVUeXBlPihcbiAgdHlwZTogVCxcbiAgdmFsdWU6IFN0cmVhbVBhcnRWYWx1ZVR5cGVbVF0sXG4pOiBTdHJlYW1TdHJpbmcge1xuICBjb25zdCBzdHJlYW1QYXJ0ID0gc3RyZWFtUGFydHMuZmluZChwYXJ0ID0+IHBhcnQubmFtZSA9PT0gdHlwZSk7XG5cbiAgaWYgKCFzdHJlYW1QYXJ0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHN0cmVhbSBwYXJ0IHR5cGU6ICR7dHlwZX1gKTtcbiAgfVxuXG4gIHJldHVybiBgJHtzdHJlYW1QYXJ0LmNvZGV9OiR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfVxcbmA7XG59XG4iLCJpbXBvcnQgeyBTdHJlYW1QYXJ0VHlwZSwgcGFyc2VTdHJlYW1QYXJ0IH0gZnJvbSAnLi9zdHJlYW0tcGFydHMnO1xuXG5jb25zdCBORVdMSU5FID0gJ1xcbicuY2hhckNvZGVBdCgwKTtcblxuLy8gY29uY2F0ZW5hdGVzIGFsbCB0aGUgY2h1bmtzIGludG8gYSBzaW5nbGUgVWludDhBcnJheVxuZnVuY3Rpb24gY29uY2F0Q2h1bmtzKGNodW5rczogVWludDhBcnJheVtdLCB0b3RhbExlbmd0aDogbnVtYmVyKSB7XG4gIGNvbnN0IGNvbmNhdGVuYXRlZENodW5rcyA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcblxuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZm9yIChjb25zdCBjaHVuayBvZiBjaHVua3MpIHtcbiAgICBjb25jYXRlbmF0ZWRDaHVua3Muc2V0KGNodW5rLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBjaHVuay5sZW5ndGg7XG4gIH1cbiAgY2h1bmtzLmxlbmd0aCA9IDA7XG5cbiAgcmV0dXJuIGNvbmNhdGVuYXRlZENodW5rcztcbn1cblxuLyoqXG5Db252ZXJ0cyBhIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlciBpbnRvIGFuIGFzeW5jIGdlbmVyYXRvciB0aGF0IHlpZWxkc1xuU3RyZWFtUGFydCBvYmplY3RzLlxuXG5AcGFyYW0gcmVhZGVyIFxuICAgICAgIFJlYWRlciBmb3IgdGhlIHN0cmVhbSB0byByZWFkIGZyb20uXG5AcGFyYW0gaXNBYm9ydGVkXG4gICAgICAgT3B0aW9uYWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgaWYgdGhlIHJlcXVlc3QgaGFzIGJlZW4gYWJvcnRlZC5cbiAgICAgICBJZiB0aGUgZnVuY3Rpb24gcmV0dXJucyB0cnVlLCB0aGUgZ2VuZXJhdG9yIHdpbGwgc3RvcCByZWFkaW5nIHRoZSBzdHJlYW0uXG4gICAgICAgSWYgdGhlIGZ1bmN0aW9uIGlzIG5vdCBwcm92aWRlZCwgdGhlIGdlbmVyYXRvciB3aWxsIG5vdCBzdG9wIHJlYWRpbmcgdGhlIHN0cmVhbS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uKiByZWFkRGF0YVN0cmVhbShcbiAgcmVhZGVyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8VWludDhBcnJheT4sXG4gIHtcbiAgICBpc0Fib3J0ZWQsXG4gIH06IHtcbiAgICBpc0Fib3J0ZWQ/OiAoKSA9PiBib29sZWFuO1xuICB9ID0ge30sXG4pOiBBc3luY0dlbmVyYXRvcjxTdHJlYW1QYXJ0VHlwZT4ge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBub3RlOiB0aGlzIHNsaWdodGx5IG1vcmUgY29tcGxleCBhbGdvcml0aG0gaXMgcmVxdWlyZWRcbiAgLy8gdG8gcGFzcyB0aGUgdGVzdHMgaW4gdGhlIGVkZ2UgZW52aXJvbm1lbnQuXG5cbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICBjb25zdCBjaHVua3M6IFVpbnQ4QXJyYXlbXSA9IFtdO1xuICBsZXQgdG90YWxMZW5ndGggPSAwO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcblxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgY2h1bmtzLnB1c2godmFsdWUpO1xuICAgICAgdG90YWxMZW5ndGggKz0gdmFsdWUubGVuZ3RoO1xuICAgICAgaWYgKHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdICE9PSBORVdMSU5FKSB7XG4gICAgICAgIC8vIGlmIHRoZSBsYXN0IGNoYXJhY3RlciBpcyBub3QgYSBuZXdsaW5lLCB3ZSBoYXZlIG5vdCByZWFkIHRoZSB3aG9sZSBKU09OIHZhbHVlXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgICBicmVhazsgLy8gd2UgaGF2ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIHN0cmVhbVxuICAgIH1cblxuICAgIGNvbnN0IGNvbmNhdGVuYXRlZENodW5rcyA9IGNvbmNhdENodW5rcyhjaHVua3MsIHRvdGFsTGVuZ3RoKTtcbiAgICB0b3RhbExlbmd0aCA9IDA7XG5cbiAgICBjb25zdCBzdHJlYW1QYXJ0cyA9IGRlY29kZXJcbiAgICAgIC5kZWNvZGUoY29uY2F0ZW5hdGVkQ2h1bmtzLCB7IHN0cmVhbTogdHJ1ZSB9KVxuICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgLmZpbHRlcihsaW5lID0+IGxpbmUgIT09ICcnKSAvLyBzcGxpdHRpbmcgbGVhdmVzIGFuIGVtcHR5IHN0cmluZyBhdCB0aGUgZW5kXG4gICAgICAubWFwKHBhcnNlU3RyZWFtUGFydCk7XG5cbiAgICBmb3IgKGNvbnN0IHN0cmVhbVBhcnQgb2Ygc3RyZWFtUGFydHMpIHtcbiAgICAgIHlpZWxkIHN0cmVhbVBhcnQ7XG4gICAgfVxuXG4gICAgLy8gVGhlIHJlcXVlc3QgaGFzIGJlZW4gYWJvcnRlZCwgc3RvcCByZWFkaW5nIHRoZSBzdHJlYW0uXG4gICAgaWYgKGlzQWJvcnRlZD8uKCkpIHtcbiAgICAgIHJlYWRlci5jYW5jZWwoKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgY3VzdG9tQWxwaGFiZXQgfSBmcm9tICduYW5vaWQvbm9uLXNlY3VyZSc7XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgNy1jaGFyYWN0ZXIgcmFuZG9tIHN0cmluZyB0byB1c2UgZm9yIElEcy4gTm90IHNlY3VyZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGdlbmVyYXRlSWQgPSBjdXN0b21BbHBoYWJldChcbiAgJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6JyxcbiAgNyxcbik7XG4iLCJpbXBvcnQgeyByZWFkRGF0YVN0cmVhbSB9IGZyb20gJy4vcmVhZC1kYXRhLXN0cmVhbSc7XG5pbXBvcnQgdHlwZSB7IEZ1bmN0aW9uQ2FsbCwgSlNPTlZhbHVlLCBNZXNzYWdlLCBUb29sQ2FsbCB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVJZCBhcyBnZW5lcmF0ZUlkRnVuY3Rpb24gfSBmcm9tICcuL2dlbmVyYXRlLWlkJztcblxudHlwZSBQcmVmaXhNYXAgPSB7XG4gIHRleHQ/OiBNZXNzYWdlO1xuICBmdW5jdGlvbl9jYWxsPzogTWVzc2FnZSAmIHtcbiAgICByb2xlOiAnYXNzaXN0YW50JztcbiAgICBmdW5jdGlvbl9jYWxsOiBGdW5jdGlvbkNhbGw7XG4gIH07XG4gIHRvb2xfY2FsbHM/OiBNZXNzYWdlICYge1xuICAgIHJvbGU6ICdhc3Npc3RhbnQnO1xuICAgIHRvb2xfY2FsbHM6IFRvb2xDYWxsW107XG4gIH07XG4gIGRhdGE6IEpTT05WYWx1ZVtdO1xufTtcblxuZnVuY3Rpb24gYXNzaWduQW5ub3RhdGlvbnNUb01lc3NhZ2U8VCBleHRlbmRzIE1lc3NhZ2UgfCBudWxsIHwgdW5kZWZpbmVkPihcbiAgbWVzc2FnZTogVCxcbiAgYW5ub3RhdGlvbnM6IEpTT05WYWx1ZVtdIHwgdW5kZWZpbmVkLFxuKTogVCB7XG4gIGlmICghbWVzc2FnZSB8fCAhYW5ub3RhdGlvbnMgfHwgIWFubm90YXRpb25zLmxlbmd0aCkgcmV0dXJuIG1lc3NhZ2U7XG4gIHJldHVybiB7IC4uLm1lc3NhZ2UsIGFubm90YXRpb25zOiBbLi4uYW5ub3RhdGlvbnNdIH0gYXMgVDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBhcnNlQ29tcGxleFJlc3BvbnNlKHtcbiAgcmVhZGVyLFxuICBhYm9ydENvbnRyb2xsZXJSZWYsXG4gIHVwZGF0ZSxcbiAgb25GaW5pc2gsXG4gIGdlbmVyYXRlSWQgPSBnZW5lcmF0ZUlkRnVuY3Rpb24sXG4gIGdldEN1cnJlbnREYXRlID0gKCkgPT4gbmV3IERhdGUoKSxcbn06IHtcbiAgcmVhZGVyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8VWludDhBcnJheT47XG4gIGFib3J0Q29udHJvbGxlclJlZj86IHtcbiAgICBjdXJyZW50OiBBYm9ydENvbnRyb2xsZXIgfCBudWxsO1xuICB9O1xuICB1cGRhdGU6IChtZXJnZWQ6IE1lc3NhZ2VbXSwgZGF0YTogSlNPTlZhbHVlW10gfCB1bmRlZmluZWQpID0+IHZvaWQ7XG4gIG9uRmluaXNoPzogKHByZWZpeE1hcDogUHJlZml4TWFwKSA9PiB2b2lkO1xuICBnZW5lcmF0ZUlkPzogKCkgPT4gc3RyaW5nO1xuICBnZXRDdXJyZW50RGF0ZT86ICgpID0+IERhdGU7XG59KSB7XG4gIGNvbnN0IGNyZWF0ZWRBdCA9IGdldEN1cnJlbnREYXRlKCk7XG4gIGNvbnN0IHByZWZpeE1hcDogUHJlZml4TWFwID0ge1xuICAgIGRhdGE6IFtdLFxuICB9O1xuXG4gIC8vIGtlZXAgbGlzdCBvZiBjdXJyZW50IG1lc3NhZ2UgYW5ub3RhdGlvbnMgZm9yIG1lc3NhZ2VcbiAgbGV0IG1lc3NhZ2VfYW5ub3RhdGlvbnM6IEpTT05WYWx1ZVtdIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuXG4gIC8vIHdlIGNyZWF0ZSBhIG1hcCBvZiBlYWNoIHByZWZpeCwgYW5kIGZvciBlYWNoIHByZWZpeGVkIG1lc3NhZ2Ugd2UgcHVzaCB0byB0aGUgbWFwXG4gIGZvciBhd2FpdCAoY29uc3QgeyB0eXBlLCB2YWx1ZSB9IG9mIHJlYWREYXRhU3RyZWFtKHJlYWRlciwge1xuICAgIGlzQWJvcnRlZDogKCkgPT4gYWJvcnRDb250cm9sbGVyUmVmPy5jdXJyZW50ID09PSBudWxsLFxuICB9KSkge1xuICAgIGlmICh0eXBlID09PSAndGV4dCcpIHtcbiAgICAgIGlmIChwcmVmaXhNYXBbJ3RleHQnXSkge1xuICAgICAgICBwcmVmaXhNYXBbJ3RleHQnXSA9IHtcbiAgICAgICAgICAuLi5wcmVmaXhNYXBbJ3RleHQnXSxcbiAgICAgICAgICBjb250ZW50OiAocHJlZml4TWFwWyd0ZXh0J10uY29udGVudCB8fCAnJykgKyB2YWx1ZSxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZWZpeE1hcFsndGV4dCddID0ge1xuICAgICAgICAgIGlkOiBnZW5lcmF0ZUlkKCksXG4gICAgICAgICAgcm9sZTogJ2Fzc2lzdGFudCcsXG4gICAgICAgICAgY29udGVudDogdmFsdWUsXG4gICAgICAgICAgY3JlYXRlZEF0LFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBmdW5jdGlvbkNhbGxNZXNzYWdlOiBNZXNzYWdlIHwgbnVsbCB8IHVuZGVmaW5lZCA9IG51bGw7XG5cbiAgICBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uX2NhbGwnKSB7XG4gICAgICBwcmVmaXhNYXBbJ2Z1bmN0aW9uX2NhbGwnXSA9IHtcbiAgICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgcm9sZTogJ2Fzc2lzdGFudCcsXG4gICAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgICBmdW5jdGlvbl9jYWxsOiB2YWx1ZS5mdW5jdGlvbl9jYWxsLFxuICAgICAgICBuYW1lOiB2YWx1ZS5mdW5jdGlvbl9jYWxsLm5hbWUsXG4gICAgICAgIGNyZWF0ZWRBdCxcbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uQ2FsbE1lc3NhZ2UgPSBwcmVmaXhNYXBbJ2Z1bmN0aW9uX2NhbGwnXTtcbiAgICB9XG5cbiAgICBsZXQgdG9vbENhbGxNZXNzYWdlOiBNZXNzYWdlIHwgbnVsbCB8IHVuZGVmaW5lZCA9IG51bGw7XG5cbiAgICBpZiAodHlwZSA9PT0gJ3Rvb2xfY2FsbHMnKSB7XG4gICAgICBwcmVmaXhNYXBbJ3Rvb2xfY2FsbHMnXSA9IHtcbiAgICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgcm9sZTogJ2Fzc2lzdGFudCcsXG4gICAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgICB0b29sX2NhbGxzOiB2YWx1ZS50b29sX2NhbGxzLFxuICAgICAgICBjcmVhdGVkQXQsXG4gICAgICB9O1xuXG4gICAgICB0b29sQ2FsbE1lc3NhZ2UgPSBwcmVmaXhNYXBbJ3Rvb2xfY2FsbHMnXTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ2RhdGEnKSB7XG4gICAgICBwcmVmaXhNYXBbJ2RhdGEnXS5wdXNoKC4uLnZhbHVlKTtcbiAgICB9XG5cbiAgICBsZXQgcmVzcG9uc2VNZXNzYWdlID0gcHJlZml4TWFwWyd0ZXh0J107XG5cbiAgICBpZiAodHlwZSA9PT0gJ21lc3NhZ2VfYW5ub3RhdGlvbnMnKSB7XG4gICAgICBpZiAoIW1lc3NhZ2VfYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgbWVzc2FnZV9hbm5vdGF0aW9ucyA9IFsuLi52YWx1ZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXNzYWdlX2Fubm90YXRpb25zLnB1c2goLi4udmFsdWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgYW55IGV4aXN0aW5nIG1lc3NhZ2Ugd2l0aCB0aGUgbGF0ZXN0IGFubm90YXRpb25zXG4gICAgICBmdW5jdGlvbkNhbGxNZXNzYWdlID0gYXNzaWduQW5ub3RhdGlvbnNUb01lc3NhZ2UoXG4gICAgICAgIHByZWZpeE1hcFsnZnVuY3Rpb25fY2FsbCddLFxuICAgICAgICBtZXNzYWdlX2Fubm90YXRpb25zLFxuICAgICAgKTtcbiAgICAgIHRvb2xDYWxsTWVzc2FnZSA9IGFzc2lnbkFubm90YXRpb25zVG9NZXNzYWdlKFxuICAgICAgICBwcmVmaXhNYXBbJ3Rvb2xfY2FsbHMnXSxcbiAgICAgICAgbWVzc2FnZV9hbm5vdGF0aW9ucyxcbiAgICAgICk7XG4gICAgICByZXNwb25zZU1lc3NhZ2UgPSBhc3NpZ25Bbm5vdGF0aW9uc1RvTWVzc2FnZShcbiAgICAgICAgcHJlZml4TWFwWyd0ZXh0J10sXG4gICAgICAgIG1lc3NhZ2VfYW5ub3RhdGlvbnMsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGtlZXBzIHRoZSBwcmVmaXhNYXAgdXAgdG8gZGF0ZSB3aXRoIHRoZSBsYXRlc3QgYW5ub3RhdGlvbnMsIGV2ZW4gaWYgYW5ub3RhdGlvbnMgcHJlY2VkZWQgdGhlIG1lc3NhZ2VcbiAgICBpZiAobWVzc2FnZV9hbm5vdGF0aW9ucz8ubGVuZ3RoKSB7XG4gICAgICBjb25zdCBtZXNzYWdlUHJlZml4S2V5czogKGtleW9mIFByZWZpeE1hcClbXSA9IFtcbiAgICAgICAgJ3RleHQnLFxuICAgICAgICAnZnVuY3Rpb25fY2FsbCcsXG4gICAgICAgICd0b29sX2NhbGxzJyxcbiAgICAgIF07XG4gICAgICBtZXNzYWdlUHJlZml4S2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGlmIChwcmVmaXhNYXBba2V5XSkge1xuICAgICAgICAgIChwcmVmaXhNYXBba2V5XSBhcyBNZXNzYWdlKS5hbm5vdGF0aW9ucyA9IFsuLi5tZXNzYWdlX2Fubm90YXRpb25zIV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFdlIGFkZCBmdW5jdGlvbiAmIHRvb2wgY2FsbHMgYW5kIHJlc3BvbnNlIG1lc3NhZ2VzIHRvIHRoZSBtZXNzYWdlc1tdLCBidXQgZGF0YSBpcyBpdHMgb3duIHRoaW5nXG4gICAgY29uc3QgbWVyZ2VkID0gW2Z1bmN0aW9uQ2FsbE1lc3NhZ2UsIHRvb2xDYWxsTWVzc2FnZSwgcmVzcG9uc2VNZXNzYWdlXVxuICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICAgLm1hcChtZXNzYWdlID0+ICh7XG4gICAgICAgIC4uLmFzc2lnbkFubm90YXRpb25zVG9NZXNzYWdlKG1lc3NhZ2UsIG1lc3NhZ2VfYW5ub3RhdGlvbnMpLFxuICAgICAgfSkpIGFzIE1lc3NhZ2VbXTtcblxuICAgIHVwZGF0ZShtZXJnZWQsIFsuLi5wcmVmaXhNYXBbJ2RhdGEnXV0pOyAvLyBtYWtlIGEgY29weSBvZiB0aGUgZGF0YSBhcnJheVxuICB9XG5cbiAgb25GaW5pc2g/LihwcmVmaXhNYXApO1xuXG4gIHJldHVybiB7XG4gICAgbWVzc2FnZXM6IFtcbiAgICAgIHByZWZpeE1hcC50ZXh0LFxuICAgICAgcHJlZml4TWFwLmZ1bmN0aW9uX2NhbGwsXG4gICAgICBwcmVmaXhNYXAudG9vbF9jYWxscyxcbiAgICBdLmZpbHRlcihCb29sZWFuKSBhcyBNZXNzYWdlW10sXG4gICAgZGF0YTogcHJlZml4TWFwLmRhdGEsXG4gIH07XG59XG4iLCJpbXBvcnQge1xuICBTdHJlYW1QYXJ0VHlwZSxcbiAgU3RyZWFtU3RyaW5nUHJlZml4ZXMsXG4gIHBhcnNlU3RyZWFtUGFydCxcbn0gZnJvbSAnLi9zdHJlYW0tcGFydHMnO1xuXG5leHBvcnQgKiBmcm9tICcuL2dlbmVyYXRlLWlkJztcblxuLy8gVE9ETyByZW1vdmUgKGJyZWFraW5nIGNoYW5nZSlcbmV4cG9ydCB7IGdlbmVyYXRlSWQgYXMgbmFub2lkIH0gZnJvbSAnLi9nZW5lcmF0ZS1pZCc7XG5cbi8vIEV4cG9ydCBzdHJlYW0gZGF0YSB1dGlsaXRpZXMgZm9yIGN1c3RvbSBzdHJlYW0gaW1wbGVtZW50YXRpb25zLFxuLy8gYm90aCBvbiB0aGUgY2xpZW50IGFuZCBzZXJ2ZXIgc2lkZS5cbmV4cG9ydCB0eXBlIHsgU3RyZWFtUGFydCB9IGZyb20gJy4vc3RyZWFtLXBhcnRzJztcbmV4cG9ydCB7IGZvcm1hdFN0cmVhbVBhcnQsIHBhcnNlU3RyZWFtUGFydCB9IGZyb20gJy4vc3RyZWFtLXBhcnRzJztcbmV4cG9ydCB7IHJlYWREYXRhU3RyZWFtIH0gZnJvbSAnLi9yZWFkLWRhdGEtc3RyZWFtJztcblxuLy8gc2ltcGxlIGRlY29kZXIgc2lnbmF0dXJlczpcbmZ1bmN0aW9uIGNyZWF0ZUNodW5rRGVjb2RlcigpOiAoY2h1bms6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQpID0+IHN0cmluZztcbmZ1bmN0aW9uIGNyZWF0ZUNodW5rRGVjb2RlcihcbiAgY29tcGxleDogZmFsc2UsXG4pOiAoY2h1bms6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQpID0+IHN0cmluZztcbi8vIGNvbXBsZXggZGVjb2RlciBzaWduYXR1cmU6XG5mdW5jdGlvbiBjcmVhdGVDaHVua0RlY29kZXIoXG4gIGNvbXBsZXg6IHRydWUsXG4pOiAoY2h1bms6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQpID0+IFN0cmVhbVBhcnRUeXBlW107XG4vLyBjb21iaW5lZCBzaWduYXR1cmUgZm9yIHdoZW4gdGhlIGNsaWVudCBjYWxscyB0aGlzIGZ1bmN0aW9uIHdpdGggYSBib29sZWFuOlxuZnVuY3Rpb24gY3JlYXRlQ2h1bmtEZWNvZGVyKFxuICBjb21wbGV4PzogYm9vbGVhbixcbik6IChjaHVuazogVWludDhBcnJheSB8IHVuZGVmaW5lZCkgPT4gU3RyZWFtUGFydFR5cGVbXSB8IHN0cmluZztcbmZ1bmN0aW9uIGNyZWF0ZUNodW5rRGVjb2Rlcihjb21wbGV4PzogYm9vbGVhbikge1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG5cbiAgaWYgKCFjb21wbGV4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjaHVuazogVWludDhBcnJheSB8IHVuZGVmaW5lZCk6IHN0cmluZyB7XG4gICAgICBpZiAoIWNodW5rKSByZXR1cm4gJyc7XG4gICAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGUoY2h1bmssIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGNodW5rOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgZGVjb2RlZCA9IGRlY29kZXJcbiAgICAgIC5kZWNvZGUoY2h1bmssIHsgc3RyZWFtOiB0cnVlIH0pXG4gICAgICAuc3BsaXQoJ1xcbicpXG4gICAgICAuZmlsdGVyKGxpbmUgPT4gbGluZSAhPT0gJycpOyAvLyBzcGxpdHRpbmcgbGVhdmVzIGFuIGVtcHR5IHN0cmluZyBhdCB0aGUgZW5kXG5cbiAgICByZXR1cm4gZGVjb2RlZC5tYXAocGFyc2VTdHJlYW1QYXJ0KS5maWx0ZXIoQm9vbGVhbik7XG4gIH07XG59XG5cbmV4cG9ydCB7IGNyZWF0ZUNodW5rRGVjb2RlciB9O1xuXG5leHBvcnQgY29uc3QgaXNTdHJlYW1TdHJpbmdFcXVhbFRvVHlwZSA9IChcbiAgdHlwZToga2V5b2YgdHlwZW9mIFN0cmVhbVN0cmluZ1ByZWZpeGVzLFxuICB2YWx1ZTogc3RyaW5nLFxuKTogdmFsdWUgaXMgU3RyZWFtU3RyaW5nID0+XG4gIHZhbHVlLnN0YXJ0c1dpdGgoYCR7U3RyZWFtU3RyaW5nUHJlZml4ZXNbdHlwZV19OmApICYmIHZhbHVlLmVuZHNXaXRoKCdcXG4nKTtcblxuZXhwb3J0IHR5cGUgU3RyZWFtU3RyaW5nID1cbiAgYCR7KHR5cGVvZiBTdHJlYW1TdHJpbmdQcmVmaXhlcylba2V5b2YgdHlwZW9mIFN0cmVhbVN0cmluZ1ByZWZpeGVzXX06JHtzdHJpbmd9XFxuYDtcbiIsImltcG9ydCB7IHBhcnNlQ29tcGxleFJlc3BvbnNlIH0gZnJvbSAnLi9wYXJzZS1jb21wbGV4LXJlc3BvbnNlJztcbmltcG9ydCB7IElkR2VuZXJhdG9yLCBKU09OVmFsdWUsIE1lc3NhZ2UgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IGNyZWF0ZUNodW5rRGVjb2RlciB9IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2FsbENoYXRBcGkoe1xuICBhcGksXG4gIG1lc3NhZ2VzLFxuICBib2R5LFxuICBzdHJlYW1Nb2RlID0gJ3N0cmVhbS1kYXRhJyxcbiAgY3JlZGVudGlhbHMsXG4gIGhlYWRlcnMsXG4gIGFib3J0Q29udHJvbGxlcixcbiAgcmVzdG9yZU1lc3NhZ2VzT25GYWlsdXJlLFxuICBvblJlc3BvbnNlLFxuICBvblVwZGF0ZSxcbiAgb25GaW5pc2gsXG4gIGdlbmVyYXRlSWQsXG59OiB7XG4gIGFwaTogc3RyaW5nO1xuICBtZXNzYWdlczogT21pdDxNZXNzYWdlLCAnaWQnPltdO1xuICBib2R5OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICBzdHJlYW1Nb2RlPzogJ3N0cmVhbS1kYXRhJyB8ICd0ZXh0JztcbiAgY3JlZGVudGlhbHM/OiBSZXF1ZXN0Q3JlZGVudGlhbHM7XG4gIGhlYWRlcnM/OiBIZWFkZXJzSW5pdDtcbiAgYWJvcnRDb250cm9sbGVyPzogKCkgPT4gQWJvcnRDb250cm9sbGVyIHwgbnVsbDtcbiAgcmVzdG9yZU1lc3NhZ2VzT25GYWlsdXJlOiAoKSA9PiB2b2lkO1xuICBvblJlc3BvbnNlPzogKHJlc3BvbnNlOiBSZXNwb25zZSkgPT4gdm9pZCB8IFByb21pc2U8dm9pZD47XG4gIG9uVXBkYXRlOiAobWVyZ2VkOiBNZXNzYWdlW10sIGRhdGE6IEpTT05WYWx1ZVtdIHwgdW5kZWZpbmVkKSA9PiB2b2lkO1xuICBvbkZpbmlzaD86IChtZXNzYWdlOiBNZXNzYWdlKSA9PiB2b2lkO1xuICBnZW5lcmF0ZUlkOiBJZEdlbmVyYXRvcjtcbn0pIHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChhcGksIHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBtZXNzYWdlcyxcbiAgICAgIC4uLmJvZHksXG4gICAgfSksXG4gICAgaGVhZGVyczoge1xuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIC4uLmhlYWRlcnMsXG4gICAgfSxcbiAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlcj8uKCk/LnNpZ25hbCxcbiAgICBjcmVkZW50aWFscyxcbiAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICByZXN0b3JlTWVzc2FnZXNPbkZhaWx1cmUoKTtcbiAgICB0aHJvdyBlcnI7XG4gIH0pO1xuXG4gIGlmIChvblJlc3BvbnNlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IG9uUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuXG4gIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICByZXN0b3JlTWVzc2FnZXNPbkZhaWx1cmUoKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAoYXdhaXQgcmVzcG9uc2UudGV4dCgpKSB8fCAnRmFpbGVkIHRvIGZldGNoIHRoZSBjaGF0IHJlc3BvbnNlLicsXG4gICAgKTtcbiAgfVxuXG4gIGlmICghcmVzcG9uc2UuYm9keSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIHJlc3BvbnNlIGJvZHkgaXMgZW1wdHkuJyk7XG4gIH1cblxuICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuXG4gIHN3aXRjaCAoc3RyZWFtTW9kZSkge1xuICAgIGNhc2UgJ3RleHQnOiB7XG4gICAgICBjb25zdCBkZWNvZGVyID0gY3JlYXRlQ2h1bmtEZWNvZGVyKCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdE1lc3NhZ2UgPSB7XG4gICAgICAgIGlkOiBnZW5lcmF0ZUlkKCksXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgcm9sZTogJ2Fzc2lzdGFudCcgYXMgY29uc3QsXG4gICAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgfTtcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdE1lc3NhZ2UuY29udGVudCArPSBkZWNvZGVyKHZhbHVlKTtcbiAgICAgICAgcmVzdWx0TWVzc2FnZS5pZCA9IGdlbmVyYXRlSWQoKTtcblxuICAgICAgICAvLyBub3RlOiBjcmVhdGluZyBhIG5ldyBtZXNzYWdlIG9iamVjdCBpcyByZXF1aXJlZCBmb3IgU29saWQuanMgc3RyZWFtaW5nXG4gICAgICAgIG9uVXBkYXRlKFt7IC4uLnJlc3VsdE1lc3NhZ2UgfV0sIFtdKTtcblxuICAgICAgICAvLyBUaGUgcmVxdWVzdCBoYXMgYmVlbiBhYm9ydGVkLCBzdG9wIHJlYWRpbmcgdGhlIHN0cmVhbS5cbiAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlcj8uKCkgPT09IG51bGwpIHtcbiAgICAgICAgICByZWFkZXIuY2FuY2VsKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb25GaW5pc2g/LihyZXN1bHRNZXNzYWdlKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWVzc2FnZXM6IFtyZXN1bHRNZXNzYWdlXSxcbiAgICAgICAgZGF0YTogW10sXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNhc2UgJ3N0cmVhbS1kYXRhJzoge1xuICAgICAgcmV0dXJuIGF3YWl0IHBhcnNlQ29tcGxleFJlc3BvbnNlKHtcbiAgICAgICAgcmVhZGVyLFxuICAgICAgICBhYm9ydENvbnRyb2xsZXJSZWY6XG4gICAgICAgICAgYWJvcnRDb250cm9sbGVyICE9IG51bGwgPyB7IGN1cnJlbnQ6IGFib3J0Q29udHJvbGxlcigpIH0gOiB1bmRlZmluZWQsXG4gICAgICAgIHVwZGF0ZTogb25VcGRhdGUsXG4gICAgICAgIG9uRmluaXNoKHByZWZpeE1hcCkge1xuICAgICAgICAgIGlmIChvbkZpbmlzaCAmJiBwcmVmaXhNYXAudGV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBvbkZpbmlzaChwcmVmaXhNYXAudGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZW5lcmF0ZUlkLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZGVmYXVsdDoge1xuICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrOiBuZXZlciA9IHN0cmVhbU1vZGU7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gc3RyZWFtIG1vZGU6ICR7ZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHtcbiAgQ2hhdFJlcXVlc3QsXG4gIEZ1bmN0aW9uQ2FsbCxcbiAgSlNPTlZhbHVlLFxuICBNZXNzYWdlLFxuICBUb29sQ2FsbCxcbn0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzQ2hhdFN0cmVhbSh7XG4gIGdldFN0cmVhbWVkUmVzcG9uc2UsXG4gIGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCxcbiAgZXhwZXJpbWVudGFsX29uVG9vbENhbGwsXG4gIHVwZGF0ZUNoYXRSZXF1ZXN0LFxuICBnZXRDdXJyZW50TWVzc2FnZXMsXG59OiB7XG4gIGdldFN0cmVhbWVkUmVzcG9uc2U6ICgpID0+IFByb21pc2U8XG4gICAgTWVzc2FnZSB8IHsgbWVzc2FnZXM6IE1lc3NhZ2VbXTsgZGF0YTogSlNPTlZhbHVlW10gfVxuICA+O1xuICBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGw/OiAoXG4gICAgY2hhdE1lc3NhZ2VzOiBNZXNzYWdlW10sXG4gICAgZnVuY3Rpb25DYWxsOiBGdW5jdGlvbkNhbGwsXG4gICkgPT4gUHJvbWlzZTx2b2lkIHwgQ2hhdFJlcXVlc3Q+O1xuICBleHBlcmltZW50YWxfb25Ub29sQ2FsbD86IChcbiAgICBjaGF0TWVzc2FnZXM6IE1lc3NhZ2VbXSxcbiAgICB0b29sQ2FsbHM6IFRvb2xDYWxsW10sXG4gICkgPT4gUHJvbWlzZTx2b2lkIHwgQ2hhdFJlcXVlc3Q+O1xuICB1cGRhdGVDaGF0UmVxdWVzdDogKGNoYXRSZXF1ZXN0OiBDaGF0UmVxdWVzdCkgPT4gdm9pZDtcbiAgZ2V0Q3VycmVudE1lc3NhZ2VzOiAoKSA9PiBNZXNzYWdlW107XG59KSB7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgLy8gVE9ETy1TVFJFQU1EQVRBOiBUaGlzIHNob3VsZCBiZSB7ICBjb25zdCB7IG1lc3NhZ2VzOiBzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZXMsIGRhdGEgfSA9XG4gICAgLy8gYXdhaXQgZ2V0U3RyZWFtZWRSZXNwb25zZSh9IG9uY2UgU3RyZWFtIERhdGEgaXMgbm90IGV4cGVyaW1lbnRhbFxuICAgIGNvbnN0IG1lc3NhZ2VzQW5kRGF0YU9ySnVzdE1lc3NhZ2UgPSBhd2FpdCBnZXRTdHJlYW1lZFJlc3BvbnNlKCk7XG5cbiAgICAvLyBVc2luZyBleHBlcmltZW50YWwgc3RyZWFtIGRhdGFcbiAgICBpZiAoJ21lc3NhZ2VzJyBpbiBtZXNzYWdlc0FuZERhdGFPckp1c3RNZXNzYWdlKSB7XG4gICAgICBsZXQgaGFzRm9sbG93aW5nUmVzcG9uc2UgPSBmYWxzZTtcblxuICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIG1lc3NhZ2VzQW5kRGF0YU9ySnVzdE1lc3NhZ2UubWVzc2FnZXMpIHtcbiAgICAgICAgLy8gU2VlIGlmIHRoZSBtZXNzYWdlIGhhcyBhIGNvbXBsZXRlIGZ1bmN0aW9uIGNhbGwgb3IgdG9vbCBjYWxsXG4gICAgICAgIGlmIChcbiAgICAgICAgICAobWVzc2FnZS5mdW5jdGlvbl9jYWxsID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIHR5cGVvZiBtZXNzYWdlLmZ1bmN0aW9uX2NhbGwgPT09ICdzdHJpbmcnKSAmJlxuICAgICAgICAgIChtZXNzYWdlLnRvb2xfY2FsbHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgdHlwZW9mIG1lc3NhZ2UudG9vbF9jYWxscyA9PT0gJ3N0cmluZycpXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaGFzRm9sbG93aW5nUmVzcG9uc2UgPSB0cnVlO1xuICAgICAgICAvLyBUcnkgdG8gaGFuZGxlIGZ1bmN0aW9uIGNhbGxcbiAgICAgICAgaWYgKGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCkge1xuICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbCA9IG1lc3NhZ2UuZnVuY3Rpb25fY2FsbDtcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgZnVuY3Rpb25DYWxsIGlzIGFuIG9iamVjdFxuICAgICAgICAgIC8vIElmIG5vdCwgd2UgZ290IHRvb2wgY2FsbHMgaW5zdGVhZCBvZiBmdW5jdGlvbiBjYWxsc1xuICAgICAgICAgIGlmICh0eXBlb2YgZnVuY3Rpb25DYWxsICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAnZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHNob3VsZCBub3QgYmUgZGVmaW5lZCB3aGVuIHVzaW5nIHRvb2xzJyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBVc2VyIGhhbmRsZXMgdGhlIGZ1bmN0aW9uIGNhbGwgaW4gdGhlaXIgb3duIGZ1bmN0aW9uQ2FsbEhhbmRsZXIuXG4gICAgICAgICAgLy8gVGhlIFwiYXJndW1lbnRzXCIga2V5IG9mIHRoZSBmdW5jdGlvbiBjYWxsIG9iamVjdCB3aWxsIHN0aWxsIGJlIGEgc3RyaW5nIHdoaWNoIHdpbGwgaGF2ZSB0byBiZSBwYXJzZWQgaW4gdGhlIGZ1bmN0aW9uIGhhbmRsZXIuXG4gICAgICAgICAgLy8gSWYgdGhlIFwiYXJndW1lbnRzXCIgSlNPTiBpcyBtYWxmb3JtZWQgZHVlIHRvIG1vZGVsIGVycm9yIHRoZSB1c2VyIHdpbGwgaGF2ZSB0byBoYW5kbGUgdGhhdCB0aGVtc2VsdmVzLlxuXG4gICAgICAgICAgY29uc3QgZnVuY3Rpb25DYWxsUmVzcG9uc2U6IENoYXRSZXF1ZXN0IHwgdm9pZCA9XG4gICAgICAgICAgICBhd2FpdCBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwoXG4gICAgICAgICAgICAgIGdldEN1cnJlbnRNZXNzYWdlcygpLFxuICAgICAgICAgICAgICBmdW5jdGlvbkNhbGwsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gSWYgdGhlIHVzZXIgZG9lcyBub3QgcmV0dXJuIGFueXRoaW5nIGFzIGEgcmVzdWx0IG9mIHRoZSBmdW5jdGlvbiBjYWxsLCB0aGUgbG9vcCB3aWxsIGJyZWFrLlxuICAgICAgICAgIGlmIChmdW5jdGlvbkNhbGxSZXNwb25zZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBoYXNGb2xsb3dpbmdSZXNwb25zZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQSBmdW5jdGlvbiBjYWxsIHJlc3BvbnNlIHdhcyByZXR1cm5lZC5cbiAgICAgICAgICAvLyBUaGUgdXBkYXRlZCBjaGF0IHdpdGggZnVuY3Rpb24gY2FsbCByZXNwb25zZSB3aWxsIGJlIHNlbnQgdG8gdGhlIEFQSSBpbiB0aGUgbmV4dCBpdGVyYXRpb24gb2YgdGhlIGxvb3AuXG4gICAgICAgICAgdXBkYXRlQ2hhdFJlcXVlc3QoZnVuY3Rpb25DYWxsUmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRyeSB0byBoYW5kbGUgdG9vbCBjYWxsXG4gICAgICAgIGlmIChleHBlcmltZW50YWxfb25Ub29sQ2FsbCkge1xuICAgICAgICAgIGNvbnN0IHRvb2xDYWxscyA9IG1lc3NhZ2UudG9vbF9jYWxscztcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgdG9vbENhbGxzIGlzIGFuIGFycmF5IG9mIG9iamVjdHNcbiAgICAgICAgICAvLyBJZiBub3QsIHdlIGdvdCBmdW5jdGlvbiBjYWxscyBpbnN0ZWFkIG9mIHRvb2wgY2FsbHNcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhQXJyYXkuaXNBcnJheSh0b29sQ2FsbHMpIHx8XG4gICAgICAgICAgICB0b29sQ2FsbHMuc29tZSh0b29sQ2FsbCA9PiB0eXBlb2YgdG9vbENhbGwgIT09ICdvYmplY3QnKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAnZXhwZXJpbWVudGFsX29uVG9vbENhbGwgc2hvdWxkIG5vdCBiZSBkZWZpbmVkIHdoZW4gdXNpbmcgdG9vbHMnLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFVzZXIgaGFuZGxlcyB0aGUgZnVuY3Rpb24gY2FsbCBpbiB0aGVpciBvd24gZnVuY3Rpb25DYWxsSGFuZGxlci5cbiAgICAgICAgICAvLyBUaGUgXCJhcmd1bWVudHNcIiBrZXkgb2YgdGhlIGZ1bmN0aW9uIGNhbGwgb2JqZWN0IHdpbGwgc3RpbGwgYmUgYSBzdHJpbmcgd2hpY2ggd2lsbCBoYXZlIHRvIGJlIHBhcnNlZCBpbiB0aGUgZnVuY3Rpb24gaGFuZGxlci5cbiAgICAgICAgICAvLyBJZiB0aGUgXCJhcmd1bWVudHNcIiBKU09OIGlzIG1hbGZvcm1lZCBkdWUgdG8gbW9kZWwgZXJyb3IgdGhlIHVzZXIgd2lsbCBoYXZlIHRvIGhhbmRsZSB0aGF0IHRoZW1zZWx2ZXMuXG4gICAgICAgICAgY29uc3QgdG9vbENhbGxSZXNwb25zZTogQ2hhdFJlcXVlc3QgfCB2b2lkID1cbiAgICAgICAgICAgIGF3YWl0IGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKGdldEN1cnJlbnRNZXNzYWdlcygpLCB0b29sQ2FsbHMpO1xuXG4gICAgICAgICAgLy8gSWYgdGhlIHVzZXIgZG9lcyBub3QgcmV0dXJuIGFueXRoaW5nIGFzIGEgcmVzdWx0IG9mIHRoZSBmdW5jdGlvbiBjYWxsLCB0aGUgbG9vcCB3aWxsIGJyZWFrLlxuICAgICAgICAgIGlmICh0b29sQ2FsbFJlc3BvbnNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGhhc0ZvbGxvd2luZ1Jlc3BvbnNlID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBBIGZ1bmN0aW9uIGNhbGwgcmVzcG9uc2Ugd2FzIHJldHVybmVkLlxuICAgICAgICAgIC8vIFRoZSB1cGRhdGVkIGNoYXQgd2l0aCBmdW5jdGlvbiBjYWxsIHJlc3BvbnNlIHdpbGwgYmUgc2VudCB0byB0aGUgQVBJIGluIHRoZSBuZXh0IGl0ZXJhdGlvbiBvZiB0aGUgbG9vcC5cbiAgICAgICAgICB1cGRhdGVDaGF0UmVxdWVzdCh0b29sQ2FsbFJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFoYXNGb2xsb3dpbmdSZXNwb25zZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3RyZWFtZWRSZXNwb25zZU1lc3NhZ2UgPSBtZXNzYWdlc0FuZERhdGFPckp1c3RNZXNzYWdlO1xuXG4gICAgICAvLyBUT0RPLVNUUkVBTURBVEE6IFJlbW92ZSB0aGlzIG9uY2UgU3RyZWFtIERhdGEgaXMgbm90IGV4cGVyaW1lbnRhbFxuICAgICAgaWYgKFxuICAgICAgICAoc3RyZWFtZWRSZXNwb25zZU1lc3NhZ2UuZnVuY3Rpb25fY2FsbCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgdHlwZW9mIHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlLmZ1bmN0aW9uX2NhbGwgPT09ICdzdHJpbmcnKSAmJlxuICAgICAgICAoc3RyZWFtZWRSZXNwb25zZU1lc3NhZ2UudG9vbF9jYWxscyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgdHlwZW9mIHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlLnRvb2xfY2FsbHMgPT09ICdzdHJpbmcnKVxuICAgICAgKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB3ZSBnZXQgaGVyZSBhbmQgYXJlIGV4cGVjdGluZyBhIGZ1bmN0aW9uIGNhbGwsIHRoZSBtZXNzYWdlIHNob3VsZCBoYXZlIG9uZSwgaWYgbm90IHdhcm4gYW5kIGNvbnRpbnVlXG4gICAgICBpZiAoZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKSB7XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbCA9IHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlLmZ1bmN0aW9uX2NhbGw7XG4gICAgICAgIGlmICghKHR5cGVvZiBmdW5jdGlvbkNhbGwgPT09ICdvYmplY3QnKSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICdleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgc2hvdWxkIG5vdCBiZSBkZWZpbmVkIHdoZW4gdXNpbmcgdG9vbHMnLFxuICAgICAgICAgICk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnVuY3Rpb25DYWxsUmVzcG9uc2U6IENoYXRSZXF1ZXN0IHwgdm9pZCA9XG4gICAgICAgICAgYXdhaXQgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKGdldEN1cnJlbnRNZXNzYWdlcygpLCBmdW5jdGlvbkNhbGwpO1xuXG4gICAgICAgIC8vIElmIHRoZSB1c2VyIGRvZXMgbm90IHJldHVybiBhbnl0aGluZyBhcyBhIHJlc3VsdCBvZiB0aGUgZnVuY3Rpb24gY2FsbCwgdGhlIGxvb3Agd2lsbCBicmVhay5cbiAgICAgICAgaWYgKGZ1bmN0aW9uQ2FsbFJlc3BvbnNlID09PSB1bmRlZmluZWQpIGJyZWFrO1xuICAgICAgICAvLyBBIGZ1bmN0aW9uIGNhbGwgcmVzcG9uc2Ugd2FzIHJldHVybmVkLlxuICAgICAgICAvLyBUaGUgdXBkYXRlZCBjaGF0IHdpdGggZnVuY3Rpb24gY2FsbCByZXNwb25zZSB3aWxsIGJlIHNlbnQgdG8gdGhlIEFQSSBpbiB0aGUgbmV4dCBpdGVyYXRpb24gb2YgdGhlIGxvb3AuXG4gICAgICAgIGZpeEZ1bmN0aW9uQ2FsbEFyZ3VtZW50cyhmdW5jdGlvbkNhbGxSZXNwb25zZSk7XG4gICAgICAgIHVwZGF0ZUNoYXRSZXF1ZXN0KGZ1bmN0aW9uQ2FsbFJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHdlIGdldCBoZXJlIGFuZCBhcmUgZXhwZWN0aW5nIGEgdG9vbCBjYWxsLCB0aGUgbWVzc2FnZSBzaG91bGQgaGF2ZSBvbmUsIGlmIG5vdCB3YXJuIGFuZCBjb250aW51ZVxuICAgICAgaWYgKGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKSB7XG4gICAgICAgIGNvbnN0IHRvb2xDYWxscyA9IHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlLnRvb2xfY2FsbHM7XG4gICAgICAgIGlmICghKHR5cGVvZiB0b29sQ2FsbHMgPT09ICdvYmplY3QnKSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICdleHBlcmltZW50YWxfb25Ub29sQ2FsbCBzaG91bGQgbm90IGJlIGRlZmluZWQgd2hlbiB1c2luZyBmdW5jdGlvbnMnLFxuICAgICAgICAgICk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9vbENhbGxSZXNwb25zZTogQ2hhdFJlcXVlc3QgfCB2b2lkID1cbiAgICAgICAgICBhd2FpdCBleHBlcmltZW50YWxfb25Ub29sQ2FsbChnZXRDdXJyZW50TWVzc2FnZXMoKSwgdG9vbENhbGxzKTtcblxuICAgICAgICAvLyBJZiB0aGUgdXNlciBkb2VzIG5vdCByZXR1cm4gYW55dGhpbmcgYXMgYSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uIGNhbGwsIHRoZSBsb29wIHdpbGwgYnJlYWsuXG4gICAgICAgIGlmICh0b29sQ2FsbFJlc3BvbnNlID09PSB1bmRlZmluZWQpIGJyZWFrO1xuICAgICAgICAvLyBBIGZ1bmN0aW9uIGNhbGwgcmVzcG9uc2Ugd2FzIHJldHVybmVkLlxuICAgICAgICAvLyBUaGUgdXBkYXRlZCBjaGF0IHdpdGggZnVuY3Rpb24gY2FsbCByZXNwb25zZSB3aWxsIGJlIHNlbnQgdG8gdGhlIEFQSSBpbiB0aGUgbmV4dCBpdGVyYXRpb24gb2YgdGhlIGxvb3AuXG4gICAgICAgIGZpeEZ1bmN0aW9uQ2FsbEFyZ3VtZW50cyh0b29sQ2FsbFJlc3BvbnNlKTtcbiAgICAgICAgdXBkYXRlQ2hhdFJlcXVlc3QodG9vbENhbGxSZXNwb25zZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIE1ha2Ugc3VyZSBmdW5jdGlvbiBjYWxsIGFyZ3VtZW50cyBhcmUgc2VudCBiYWNrIHRvIHRoZSBBUEkgYXMgYSBzdHJpbmdcbiAgICAgIGZ1bmN0aW9uIGZpeEZ1bmN0aW9uQ2FsbEFyZ3VtZW50cyhyZXNwb25zZTogQ2hhdFJlcXVlc3QpIHtcbiAgICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIHJlc3BvbnNlLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudG9vbF9jYWxscyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2xDYWxsIG9mIG1lc3NhZ2UudG9vbF9jYWxscykge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIHRvb2xDYWxsID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cyAmJlxuICAgICAgICAgICAgICAgICAgdHlwZW9mIHRvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cyAhPT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cyA9IEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgICAgICB0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5mdW5jdGlvbl9jYWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5mdW5jdGlvbl9jYWxsID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50cyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBtZXNzYWdlLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzICE9PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzID0gSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZUlkLCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZVNXUiBmcm9tICdzd3InO1xuaW1wb3J0IHsgY2FsbENvbXBsZXRpb25BcGkgfSBmcm9tICcuLi9zaGFyZWQvY2FsbC1jb21wbGV0aW9uLWFwaSc7XG5pbXBvcnQge1xuICBKU09OVmFsdWUsXG4gIFJlcXVlc3RPcHRpb25zLFxuICBVc2VDb21wbGV0aW9uT3B0aW9ucyxcbn0gZnJvbSAnLi4vc2hhcmVkL3R5cGVzJztcblxuZXhwb3J0IHR5cGUgeyBVc2VDb21wbGV0aW9uT3B0aW9ucyB9O1xuXG5leHBvcnQgdHlwZSBVc2VDb21wbGV0aW9uSGVscGVycyA9IHtcbiAgLyoqIFRoZSBjdXJyZW50IGNvbXBsZXRpb24gcmVzdWx0ICovXG4gIGNvbXBsZXRpb246IHN0cmluZztcbiAgLyoqXG4gICAqIFNlbmQgYSBuZXcgcHJvbXB0IHRvIHRoZSBBUEkgZW5kcG9pbnQgYW5kIHVwZGF0ZSB0aGUgY29tcGxldGlvbiBzdGF0ZS5cbiAgICovXG4gIGNvbXBsZXRlOiAoXG4gICAgcHJvbXB0OiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IFJlcXVlc3RPcHRpb25zLFxuICApID0+IFByb21pc2U8c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZD47XG4gIC8qKiBUaGUgZXJyb3Igb2JqZWN0IG9mIHRoZSBBUEkgcmVxdWVzdCAqL1xuICBlcnJvcjogdW5kZWZpbmVkIHwgRXJyb3I7XG4gIC8qKlxuICAgKiBBYm9ydCB0aGUgY3VycmVudCBBUEkgcmVxdWVzdCBidXQga2VlcCB0aGUgZ2VuZXJhdGVkIHRva2Vucy5cbiAgICovXG4gIHN0b3A6ICgpID0+IHZvaWQ7XG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGBjb21wbGV0aW9uYCBzdGF0ZSBsb2NhbGx5LlxuICAgKi9cbiAgc2V0Q29tcGxldGlvbjogKGNvbXBsZXRpb246IHN0cmluZykgPT4gdm9pZDtcbiAgLyoqIFRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBpbnB1dCAqL1xuICBpbnB1dDogc3RyaW5nO1xuICAvKiogc2V0U3RhdGUtcG93ZXJlZCBtZXRob2QgdG8gdXBkYXRlIHRoZSBpbnB1dCB2YWx1ZSAqL1xuICBzZXRJbnB1dDogUmVhY3QuRGlzcGF0Y2g8UmVhY3QuU2V0U3RhdGVBY3Rpb248c3RyaW5nPj47XG4gIC8qKlxuICAgKiBBbiBpbnB1dC90ZXh0YXJlYS1yZWFkeSBvbkNoYW5nZSBoYW5kbGVyIHRvIGNvbnRyb2wgdGhlIHZhbHVlIG9mIHRoZSBpbnB1dFxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc3hcbiAgICogPGlucHV0IG9uQ2hhbmdlPXtoYW5kbGVJbnB1dENoYW5nZX0gdmFsdWU9e2lucHV0fSAvPlxuICAgKiBgYGBcbiAgICovXG4gIGhhbmRsZUlucHV0Q2hhbmdlOiAoXG4gICAgZTpcbiAgICAgIHwgUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD5cbiAgICAgIHwgUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTFRleHRBcmVhRWxlbWVudD4sXG4gICkgPT4gdm9pZDtcbiAgLyoqXG4gICAqIEZvcm0gc3VibWlzc2lvbiBoYW5kbGVyIHRvIGF1dG9tYXRpY2FsbHkgcmVzZXQgaW5wdXQgYW5kIGFwcGVuZCBhIHVzZXIgbWVzc2FnZVxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc3hcbiAgICogPGZvcm0gb25TdWJtaXQ9e2hhbmRsZVN1Ym1pdH0+XG4gICAqICA8aW5wdXQgb25DaGFuZ2U9e2hhbmRsZUlucHV0Q2hhbmdlfSB2YWx1ZT17aW5wdXR9IC8+XG4gICAqIDwvZm9ybT5cbiAgICogYGBgXG4gICAqL1xuICBoYW5kbGVTdWJtaXQ6IChlOiBSZWFjdC5Gb3JtRXZlbnQ8SFRNTEZvcm1FbGVtZW50PikgPT4gdm9pZDtcbiAgLyoqIFdoZXRoZXIgdGhlIEFQSSByZXF1ZXN0IGlzIGluIHByb2dyZXNzICovXG4gIGlzTG9hZGluZzogYm9vbGVhbjtcbiAgLyoqIEFkZGl0aW9uYWwgZGF0YSBhZGRlZCBvbiB0aGUgc2VydmVyIHZpYSBTdHJlYW1EYXRhICovXG4gIGRhdGE/OiBKU09OVmFsdWVbXTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VDb21wbGV0aW9uKHtcbiAgYXBpID0gJy9hcGkvY29tcGxldGlvbicsXG4gIGlkLFxuICBpbml0aWFsQ29tcGxldGlvbiA9ICcnLFxuICBpbml0aWFsSW5wdXQgPSAnJyxcbiAgY3JlZGVudGlhbHMsXG4gIGhlYWRlcnMsXG4gIGJvZHksXG4gIHN0cmVhbU1vZGUsXG4gIG9uUmVzcG9uc2UsXG4gIG9uRmluaXNoLFxuICBvbkVycm9yLFxufTogVXNlQ29tcGxldGlvbk9wdGlvbnMgPSB7fSk6IFVzZUNvbXBsZXRpb25IZWxwZXJzIHtcbiAgLy8gR2VuZXJhdGUgYW4gdW5pcXVlIGlkIGZvciB0aGUgY29tcGxldGlvbiBpZiBub3QgcHJvdmlkZWQuXG4gIGNvbnN0IGhvb2tJZCA9IHVzZUlkKCk7XG4gIGNvbnN0IGNvbXBsZXRpb25JZCA9IGlkIHx8IGhvb2tJZDtcblxuICAvLyBTdG9yZSB0aGUgY29tcGxldGlvbiBzdGF0ZSBpbiBTV1IsIHVzaW5nIHRoZSBjb21wbGV0aW9uSWQgYXMgdGhlIGtleSB0byBzaGFyZSBzdGF0ZXMuXG4gIGNvbnN0IHsgZGF0YSwgbXV0YXRlIH0gPSB1c2VTV1I8c3RyaW5nPihbYXBpLCBjb21wbGV0aW9uSWRdLCBudWxsLCB7XG4gICAgZmFsbGJhY2tEYXRhOiBpbml0aWFsQ29tcGxldGlvbixcbiAgfSk7XG5cbiAgY29uc3QgeyBkYXRhOiBpc0xvYWRpbmcgPSBmYWxzZSwgbXV0YXRlOiBtdXRhdGVMb2FkaW5nIH0gPSB1c2VTV1I8Ym9vbGVhbj4oXG4gICAgW2NvbXBsZXRpb25JZCwgJ2xvYWRpbmcnXSxcbiAgICBudWxsLFxuICApO1xuXG4gIGNvbnN0IHsgZGF0YTogc3RyZWFtRGF0YSwgbXV0YXRlOiBtdXRhdGVTdHJlYW1EYXRhIH0gPSB1c2VTV1I8XG4gICAgSlNPTlZhbHVlW10gfCB1bmRlZmluZWRcbiAgPihbY29tcGxldGlvbklkLCAnc3RyZWFtRGF0YSddLCBudWxsKTtcblxuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHVuZGVmaW5lZCB8IEVycm9yPih1bmRlZmluZWQpO1xuICBjb25zdCBjb21wbGV0aW9uID0gZGF0YSE7XG5cbiAgLy8gQWJvcnQgY29udHJvbGxlciB0byBjYW5jZWwgdGhlIGN1cnJlbnQgQVBJIGNhbGwuXG4gIGNvbnN0IFthYm9ydENvbnRyb2xsZXIsIHNldEFib3J0Q29udHJvbGxlcl0gPVxuICAgIHVzZVN0YXRlPEFib3J0Q29udHJvbGxlciB8IG51bGw+KG51bGwpO1xuXG4gIGNvbnN0IGV4dHJhTWV0YWRhdGFSZWYgPSB1c2VSZWYoe1xuICAgIGNyZWRlbnRpYWxzLFxuICAgIGhlYWRlcnMsXG4gICAgYm9keSxcbiAgfSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50ID0ge1xuICAgICAgY3JlZGVudGlhbHMsXG4gICAgICBoZWFkZXJzLFxuICAgICAgYm9keSxcbiAgICB9O1xuICB9LCBbY3JlZGVudGlhbHMsIGhlYWRlcnMsIGJvZHldKTtcblxuICBjb25zdCB0cmlnZ2VyUmVxdWVzdCA9IHVzZUNhbGxiYWNrKFxuICAgIGFzeW5jIChwcm9tcHQ6IHN0cmluZywgb3B0aW9ucz86IFJlcXVlc3RPcHRpb25zKSA9PlxuICAgICAgY2FsbENvbXBsZXRpb25BcGkoe1xuICAgICAgICBhcGksXG4gICAgICAgIHByb21wdCxcbiAgICAgICAgY3JlZGVudGlhbHM6IGV4dHJhTWV0YWRhdGFSZWYuY3VycmVudC5jcmVkZW50aWFscyxcbiAgICAgICAgaGVhZGVyczogeyAuLi5leHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQuaGVhZGVycywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgLi4uZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LmJvZHksXG4gICAgICAgICAgLi4ub3B0aW9ucz8uYm9keSxcbiAgICAgICAgfSxcbiAgICAgICAgc3RyZWFtTW9kZSxcbiAgICAgICAgc2V0Q29tcGxldGlvbjogY29tcGxldGlvbiA9PiBtdXRhdGUoY29tcGxldGlvbiwgZmFsc2UpLFxuICAgICAgICBzZXRMb2FkaW5nOiBtdXRhdGVMb2FkaW5nLFxuICAgICAgICBzZXRFcnJvcixcbiAgICAgICAgc2V0QWJvcnRDb250cm9sbGVyLFxuICAgICAgICBvblJlc3BvbnNlLFxuICAgICAgICBvbkZpbmlzaCxcbiAgICAgICAgb25FcnJvcixcbiAgICAgICAgb25EYXRhOiBkYXRhID0+IHtcbiAgICAgICAgICBtdXRhdGVTdHJlYW1EYXRhKFsuLi4oc3RyZWFtRGF0YSB8fCBbXSksIC4uLihkYXRhIHx8IFtdKV0sIGZhbHNlKTtcbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgIFtcbiAgICAgIG11dGF0ZSxcbiAgICAgIG11dGF0ZUxvYWRpbmcsXG4gICAgICBhcGksXG4gICAgICBleHRyYU1ldGFkYXRhUmVmLFxuICAgICAgc2V0QWJvcnRDb250cm9sbGVyLFxuICAgICAgb25SZXNwb25zZSxcbiAgICAgIG9uRmluaXNoLFxuICAgICAgb25FcnJvcixcbiAgICAgIHNldEVycm9yLFxuICAgICAgc3RyZWFtRGF0YSxcbiAgICAgIG11dGF0ZVN0cmVhbURhdGEsXG4gICAgXSxcbiAgKTtcblxuICBjb25zdCBzdG9wID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChhYm9ydENvbnRyb2xsZXIpIHtcbiAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgc2V0QWJvcnRDb250cm9sbGVyKG51bGwpO1xuICAgIH1cbiAgfSwgW2Fib3J0Q29udHJvbGxlcl0pO1xuXG4gIGNvbnN0IHNldENvbXBsZXRpb24gPSB1c2VDYWxsYmFjayhcbiAgICAoY29tcGxldGlvbjogc3RyaW5nKSA9PiB7XG4gICAgICBtdXRhdGUoY29tcGxldGlvbiwgZmFsc2UpO1xuICAgIH0sXG4gICAgW211dGF0ZV0sXG4gICk7XG5cbiAgY29uc3QgY29tcGxldGUgPSB1c2VDYWxsYmFjazxVc2VDb21wbGV0aW9uSGVscGVyc1snY29tcGxldGUnXT4oXG4gICAgYXN5bmMgKHByb21wdCwgb3B0aW9ucykgPT4ge1xuICAgICAgcmV0dXJuIHRyaWdnZXJSZXF1ZXN0KHByb21wdCwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBbdHJpZ2dlclJlcXVlc3RdLFxuICApO1xuXG4gIGNvbnN0IFtpbnB1dCwgc2V0SW5wdXRdID0gdXNlU3RhdGUoaW5pdGlhbElucHV0KTtcblxuICBjb25zdCBoYW5kbGVTdWJtaXQgPSB1c2VDYWxsYmFjayhcbiAgICAoZTogUmVhY3QuRm9ybUV2ZW50PEhUTUxGb3JtRWxlbWVudD4pID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGlmICghaW5wdXQpIHJldHVybjtcbiAgICAgIHJldHVybiBjb21wbGV0ZShpbnB1dCk7XG4gICAgfSxcbiAgICBbaW5wdXQsIGNvbXBsZXRlXSxcbiAgKTtcblxuICBjb25zdCBoYW5kbGVJbnB1dENoYW5nZSA9IChlOiBhbnkpID0+IHtcbiAgICBzZXRJbnB1dChlLnRhcmdldC52YWx1ZSk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBjb21wbGV0aW9uLFxuICAgIGNvbXBsZXRlLFxuICAgIGVycm9yLFxuICAgIHNldENvbXBsZXRpb24sXG4gICAgc3RvcCxcbiAgICBpbnB1dCxcbiAgICBzZXRJbnB1dCxcbiAgICBoYW5kbGVJbnB1dENoYW5nZSxcbiAgICBoYW5kbGVTdWJtaXQsXG4gICAgaXNMb2FkaW5nLFxuICAgIGRhdGE6IHN0cmVhbURhdGEsXG4gIH07XG59XG4iLCJpbXBvcnQgeyByZWFkRGF0YVN0cmVhbSB9IGZyb20gJy4vcmVhZC1kYXRhLXN0cmVhbSc7XG5pbXBvcnQgeyBKU09OVmFsdWUgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IGNyZWF0ZUNodW5rRGVjb2RlciB9IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2FsbENvbXBsZXRpb25BcGkoe1xuICBhcGksXG4gIHByb21wdCxcbiAgY3JlZGVudGlhbHMsXG4gIGhlYWRlcnMsXG4gIGJvZHksXG4gIHN0cmVhbU1vZGUgPSAnc3RyZWFtLWRhdGEnLFxuICBzZXRDb21wbGV0aW9uLFxuICBzZXRMb2FkaW5nLFxuICBzZXRFcnJvcixcbiAgc2V0QWJvcnRDb250cm9sbGVyLFxuICBvblJlc3BvbnNlLFxuICBvbkZpbmlzaCxcbiAgb25FcnJvcixcbiAgb25EYXRhLFxufToge1xuICBhcGk6IHN0cmluZztcbiAgcHJvbXB0OiBzdHJpbmc7XG4gIGNyZWRlbnRpYWxzPzogUmVxdWVzdENyZWRlbnRpYWxzO1xuICBoZWFkZXJzPzogSGVhZGVyc0luaXQ7XG4gIGJvZHk6IFJlY29yZDxzdHJpbmcsIGFueT47XG4gIHN0cmVhbU1vZGU/OiAnc3RyZWFtLWRhdGEnIHwgJ3RleHQnO1xuICBzZXRDb21wbGV0aW9uOiAoY29tcGxldGlvbjogc3RyaW5nKSA9PiB2b2lkO1xuICBzZXRMb2FkaW5nOiAobG9hZGluZzogYm9vbGVhbikgPT4gdm9pZDtcbiAgc2V0RXJyb3I6IChlcnJvcjogRXJyb3IgfCB1bmRlZmluZWQpID0+IHZvaWQ7XG4gIHNldEFib3J0Q29udHJvbGxlcjogKGFib3J0Q29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyIHwgbnVsbCkgPT4gdm9pZDtcbiAgb25SZXNwb25zZT86IChyZXNwb25zZTogUmVzcG9uc2UpID0+IHZvaWQgfCBQcm9taXNlPHZvaWQ+O1xuICBvbkZpbmlzaD86IChwcm9tcHQ6IHN0cmluZywgY29tcGxldGlvbjogc3RyaW5nKSA9PiB2b2lkO1xuICBvbkVycm9yPzogKGVycm9yOiBFcnJvcikgPT4gdm9pZDtcbiAgb25EYXRhPzogKGRhdGE6IEpTT05WYWx1ZVtdKSA9PiB2b2lkO1xufSkge1xuICB0cnkge1xuICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgc2V0RXJyb3IodW5kZWZpbmVkKTtcblxuICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBzZXRBYm9ydENvbnRyb2xsZXIoYWJvcnRDb250cm9sbGVyKTtcblxuICAgIC8vIEVtcHR5IHRoZSBjb21wbGV0aW9uIGltbWVkaWF0ZWx5LlxuICAgIHNldENvbXBsZXRpb24oJycpO1xuXG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYXBpLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgcHJvbXB0LFxuICAgICAgICAuLi5ib2R5LFxuICAgICAgfSksXG4gICAgICBjcmVkZW50aWFscyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgLi4uaGVhZGVycyxcbiAgICAgIH0sXG4gICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9KTtcblxuICAgIGlmIChvblJlc3BvbnNlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBvblJlc3BvbnNlKHJlcyk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIChhd2FpdCByZXMudGV4dCgpKSB8fCAnRmFpbGVkIHRvIGZldGNoIHRoZSBjaGF0IHJlc3BvbnNlLicsXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghcmVzLmJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHJlc3BvbnNlIGJvZHkgaXMgZW1wdHkuJyk7XG4gICAgfVxuXG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgIGNvbnN0IHJlYWRlciA9IHJlcy5ib2R5LmdldFJlYWRlcigpO1xuXG4gICAgc3dpdGNoIChzdHJlYW1Nb2RlKSB7XG4gICAgICBjYXNlICd0ZXh0Jzoge1xuICAgICAgICBjb25zdCBkZWNvZGVyID0gY3JlYXRlQ2h1bmtEZWNvZGVyKCk7XG5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIGNvbXBsZXRpb24gc3RhdGUgd2l0aCB0aGUgbmV3IG1lc3NhZ2UgdG9rZW5zLlxuICAgICAgICAgIHJlc3VsdCArPSBkZWNvZGVyKHZhbHVlKTtcbiAgICAgICAgICBzZXRDb21wbGV0aW9uKHJlc3VsdCk7XG5cbiAgICAgICAgICAvLyBUaGUgcmVxdWVzdCBoYXMgYmVlbiBhYm9ydGVkLCBzdG9wIHJlYWRpbmcgdGhlIHN0cmVhbS5cbiAgICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZWFkZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY2FzZSAnc3RyZWFtLWRhdGEnOiB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgeyB0eXBlLCB2YWx1ZSB9IG9mIHJlYWREYXRhU3RyZWFtKHJlYWRlciwge1xuICAgICAgICAgIGlzQWJvcnRlZDogKCkgPT4gYWJvcnRDb250cm9sbGVyID09PSBudWxsLFxuICAgICAgICB9KSkge1xuICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAndGV4dCc6IHtcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IHZhbHVlO1xuICAgICAgICAgICAgICBzZXRDb21wbGV0aW9uKHJlc3VsdCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnZGF0YSc6IHtcbiAgICAgICAgICAgICAgb25EYXRhPy4odmFsdWUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrOiBuZXZlciA9IHN0cmVhbU1vZGU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzdHJlYW0gbW9kZTogJHtleGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9uRmluaXNoKSB7XG4gICAgICBvbkZpbmlzaChwcm9tcHQsIHJlc3VsdCk7XG4gICAgfVxuXG4gICAgc2V0QWJvcnRDb250cm9sbGVyKG51bGwpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIElnbm9yZSBhYm9ydCBlcnJvcnMgYXMgdGhleSBhcmUgZXhwZWN0ZWQuXG4gICAgaWYgKChlcnIgYXMgYW55KS5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgIHNldEFib3J0Q29udHJvbGxlcihudWxsKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNldEVycm9yKGVyciBhcyBFcnJvcik7XG4gIH0gZmluYWxseSB7XG4gICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gIH1cbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzICovXG5cbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBnZW5lcmF0ZUlkIH0gZnJvbSAnLi4vc2hhcmVkL2dlbmVyYXRlLWlkJztcbmltcG9ydCB7IHJlYWREYXRhU3RyZWFtIH0gZnJvbSAnLi4vc2hhcmVkL3JlYWQtZGF0YS1zdHJlYW0nO1xuaW1wb3J0IHsgQ3JlYXRlTWVzc2FnZSwgTWVzc2FnZSB9IGZyb20gJy4uL3NoYXJlZC90eXBlcyc7XG5cbmV4cG9ydCB0eXBlIEFzc2lzdGFudFN0YXR1cyA9ICdpbl9wcm9ncmVzcycgfCAnYXdhaXRpbmdfbWVzc2FnZSc7XG5cbmV4cG9ydCB0eXBlIFVzZUFzc2lzdGFudEhlbHBlcnMgPSB7XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBhcnJheSBvZiBjaGF0IG1lc3NhZ2VzLlxuICAgKi9cbiAgbWVzc2FnZXM6IE1lc3NhZ2VbXTtcblxuICAvKipcbiAgICogc2V0U3RhdGUtcG93ZXJlZCBtZXRob2QgdG8gdXBkYXRlIHRoZSBtZXNzYWdlcyBhcnJheS5cbiAgICovXG4gIHNldE1lc3NhZ2VzOiBSZWFjdC5EaXNwYXRjaDxSZWFjdC5TZXRTdGF0ZUFjdGlvbjxNZXNzYWdlW10+PjtcblxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgdGhyZWFkIElELlxuICAgKi9cbiAgdGhyZWFkSWQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGlucHV0IGZpZWxkLlxuICAgKi9cbiAgaW5wdXQ6IHN0cmluZztcblxuICAvKipcbiAgICogQXBwZW5kIGEgdXNlciBtZXNzYWdlIHRvIHRoZSBjaGF0IGxpc3QuIFRoaXMgdHJpZ2dlcnMgdGhlIEFQSSBjYWxsIHRvIGZldGNoXG4gICAqIHRoZSBhc3Npc3RhbnQncyByZXNwb25zZS5cbiAgICogQHBhcmFtIG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gYXBwZW5kXG4gICAqIEBwYXJhbSByZXF1ZXN0T3B0aW9ucyBBZGRpdGlvbmFsIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgQVBJIGNhbGxcbiAgICovXG4gIGFwcGVuZDogKFxuICAgIG1lc3NhZ2U6IE1lc3NhZ2UgfCBDcmVhdGVNZXNzYWdlLFxuICAgIHJlcXVlc3RPcHRpb25zPzoge1xuICAgICAgZGF0YT86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gICAgfSxcbiAgKSA9PiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBzZXRTdGF0ZS1wb3dlcmVkIG1ldGhvZCB0byB1cGRhdGUgdGhlIGlucHV0IHZhbHVlLlxuICAgKi9cbiAgc2V0SW5wdXQ6IFJlYWN0LkRpc3BhdGNoPFJlYWN0LlNldFN0YXRlQWN0aW9uPHN0cmluZz4+O1xuXG4gIC8qKlxuICAgKiBIYW5kbGVyIGZvciB0aGUgYG9uQ2hhbmdlYCBldmVudCBvZiB0aGUgaW5wdXQgZmllbGQgdG8gY29udHJvbCB0aGUgaW5wdXQncyB2YWx1ZS5cbiAgICovXG4gIGhhbmRsZUlucHV0Q2hhbmdlOiAoXG4gICAgZXZlbnQ6XG4gICAgICB8IFJlYWN0LkNoYW5nZUV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+XG4gICAgICB8IFJlYWN0LkNoYW5nZUV2ZW50PEhUTUxUZXh0QXJlYUVsZW1lbnQ+LFxuICApID0+IHZvaWQ7XG5cbiAgLyoqXG4gICAqIEZvcm0gc3VibWlzc2lvbiBoYW5kbGVyIHRoYXQgYXV0b21hdGljYWxseSByZXNldHMgdGhlIGlucHV0IGZpZWxkIGFuZCBhcHBlbmRzIGEgdXNlciBtZXNzYWdlLlxuICAgKi9cbiAgc3VibWl0TWVzc2FnZTogKFxuICAgIGV2ZW50PzogUmVhY3QuRm9ybUV2ZW50PEhUTUxGb3JtRWxlbWVudD4sXG4gICAgcmVxdWVzdE9wdGlvbnM/OiB7XG4gICAgICBkYXRhPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgICB9LFxuICApID0+IFByb21pc2U8dm9pZD47XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHN0YXR1cyBvZiB0aGUgYXNzaXN0YW50LiBUaGlzIGNhbiBiZSB1c2VkIHRvIHNob3cgYSBsb2FkaW5nIGluZGljYXRvci5cbiAgICovXG4gIHN0YXR1czogQXNzaXN0YW50U3RhdHVzO1xuXG4gIC8qKlxuICAgKiBUaGUgZXJyb3IgdGhyb3duIGR1cmluZyB0aGUgYXNzaXN0YW50IG1lc3NhZ2UgcHJvY2Vzc2luZywgaWYgYW55LlxuICAgKi9cbiAgZXJyb3I6IHVuZGVmaW5lZCB8IHVua25vd247XG59O1xuXG5leHBvcnQgdHlwZSBVc2VBc3Npc3RhbnRPcHRpb25zID0ge1xuICAvKipcbiAgICogVGhlIEFQSSBlbmRwb2ludCB0aGF0IGFjY2VwdHMgYSBgeyB0aHJlYWRJZDogc3RyaW5nIHwgbnVsbDsgbWVzc2FnZTogc3RyaW5nOyB9YCBvYmplY3QgYW5kIHJldHVybnMgYW4gYEFzc2lzdGFudFJlc3BvbnNlYCBzdHJlYW0uXG4gICAqIFRoZSB0aHJlYWRJZCByZWZlcnMgdG8gYW4gZXhpc3RpbmcgdGhyZWFkIHdpdGggbWVzc2FnZXMgKG9yIGlzIGBudWxsYCB0byBjcmVhdGUgYSBuZXcgdGhyZWFkKS5cbiAgICogVGhlIG1lc3NhZ2UgaXMgdGhlIG5leHQgbWVzc2FnZSB0aGF0IHNob3VsZCBiZSBhcHBlbmRlZCB0byB0aGUgdGhyZWFkIGFuZCBzZW50IHRvIHRoZSBhc3Npc3RhbnQuXG4gICAqL1xuICBhcGk6IHN0cmluZztcblxuICAvKipcbiAgICogQW4gb3B0aW9uYWwgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyB0aGUgSUQgb2YgYW4gZXhpc3RpbmcgdGhyZWFkLlxuICAgKiBJZiBub3QgcHJvdmlkZWQsIGEgbmV3IHRocmVhZCB3aWxsIGJlIGNyZWF0ZWQuXG4gICAqL1xuICB0aHJlYWRJZD86IHN0cmluZztcblxuICAvKipcbiAgICogQW4gb3B0aW9uYWwgbGl0ZXJhbCB0aGF0IHNldHMgdGhlIG1vZGUgb2YgY3JlZGVudGlhbHMgdG8gYmUgdXNlZCBvbiB0aGUgcmVxdWVzdC5cbiAgICogRGVmYXVsdHMgdG8gXCJzYW1lLW9yaWdpblwiLlxuICAgKi9cbiAgY3JlZGVudGlhbHM/OiBSZXF1ZXN0Q3JlZGVudGlhbHM7XG5cbiAgLyoqXG4gICAqIEFuIG9wdGlvbmFsIG9iamVjdCBvZiBoZWFkZXJzIHRvIGJlIHBhc3NlZCB0byB0aGUgQVBJIGVuZHBvaW50LlxuICAgKi9cbiAgaGVhZGVycz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gfCBIZWFkZXJzO1xuXG4gIC8qKlxuICAgKiBBbiBvcHRpb25hbCwgYWRkaXRpb25hbCBib2R5IG9iamVjdCB0byBiZSBwYXNzZWQgdG8gdGhlIEFQSSBlbmRwb2ludC5cbiAgICovXG4gIGJvZHk/OiBvYmplY3Q7XG5cbiAgLyoqXG4gICAqIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgYXNzaXN0YW50IGVuY291bnRlcnMgYW4gZXJyb3IuXG4gICAqL1xuICBvbkVycm9yPzogKGVycm9yOiBFcnJvcikgPT4gdm9pZDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VBc3Npc3RhbnQoe1xuICBhcGksXG4gIHRocmVhZElkOiB0aHJlYWRJZFBhcmFtLFxuICBjcmVkZW50aWFscyxcbiAgaGVhZGVycyxcbiAgYm9keSxcbiAgb25FcnJvcixcbn06IFVzZUFzc2lzdGFudE9wdGlvbnMpOiBVc2VBc3Npc3RhbnRIZWxwZXJzIHtcbiAgY29uc3QgW21lc3NhZ2VzLCBzZXRNZXNzYWdlc10gPSB1c2VTdGF0ZTxNZXNzYWdlW10+KFtdKTtcbiAgY29uc3QgW2lucHV0LCBzZXRJbnB1dF0gPSB1c2VTdGF0ZSgnJyk7XG4gIGNvbnN0IFt0aHJlYWRJZCwgc2V0VGhyZWFkSWRdID0gdXNlU3RhdGU8c3RyaW5nIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xuICBjb25zdCBbc3RhdHVzLCBzZXRTdGF0dXNdID0gdXNlU3RhdGU8QXNzaXN0YW50U3RhdHVzPignYXdhaXRpbmdfbWVzc2FnZScpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHVuZGVmaW5lZCB8IEVycm9yPih1bmRlZmluZWQpO1xuXG4gIGNvbnN0IGhhbmRsZUlucHV0Q2hhbmdlID0gKFxuICAgIGV2ZW50OlxuICAgICAgfCBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PlxuICAgICAgfCBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MVGV4dEFyZWFFbGVtZW50PixcbiAgKSA9PiB7XG4gICAgc2V0SW5wdXQoZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgfTtcblxuICBjb25zdCBhcHBlbmQgPSBhc3luYyAoXG4gICAgbWVzc2FnZTogTWVzc2FnZSB8IENyZWF0ZU1lc3NhZ2UsXG4gICAgcmVxdWVzdE9wdGlvbnM/OiB7XG4gICAgICBkYXRhPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgICB9LFxuICApID0+IHtcbiAgICBzZXRTdGF0dXMoJ2luX3Byb2dyZXNzJyk7XG5cbiAgICBzZXRNZXNzYWdlcyhtZXNzYWdlcyA9PiBbXG4gICAgICAuLi5tZXNzYWdlcyxcbiAgICAgIHtcbiAgICAgICAgLi4ubWVzc2FnZSxcbiAgICAgICAgaWQ6IG1lc3NhZ2UuaWQgPz8gZ2VuZXJhdGVJZCgpLFxuICAgICAgfSxcbiAgICBdKTtcblxuICAgIHNldElucHV0KCcnKTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmZXRjaChhcGksIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGNyZWRlbnRpYWxzLFxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsIC4uLmhlYWRlcnMgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIC4uLmJvZHksXG4gICAgICAgICAgLy8gYWx3YXlzIHVzZSB1c2VyLXByb3ZpZGVkIHRocmVhZElkIHdoZW4gYXZhaWxhYmxlOlxuICAgICAgICAgIHRocmVhZElkOiB0aHJlYWRJZFBhcmFtID8/IHRocmVhZElkID8/IG51bGwsXG4gICAgICAgICAgbWVzc2FnZTogbWVzc2FnZS5jb250ZW50LFxuXG4gICAgICAgICAgLy8gb3B0aW9uYWwgcmVxdWVzdCBkYXRhOlxuICAgICAgICAgIGRhdGE6IHJlcXVlc3RPcHRpb25zPy5kYXRhLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocmVzdWx0LmJvZHkgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSByZXNwb25zZSBib2R5IGlzIGVtcHR5LicpO1xuICAgICAgfVxuXG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IHsgdHlwZSwgdmFsdWUgfSBvZiByZWFkRGF0YVN0cmVhbShcbiAgICAgICAgcmVzdWx0LmJvZHkuZ2V0UmVhZGVyKCksXG4gICAgICApKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2Fzc2lzdGFudF9tZXNzYWdlJzoge1xuICAgICAgICAgICAgc2V0TWVzc2FnZXMobWVzc2FnZXMgPT4gW1xuICAgICAgICAgICAgICAuLi5tZXNzYWdlcyxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlkOiB2YWx1ZS5pZCxcbiAgICAgICAgICAgICAgICByb2xlOiB2YWx1ZS5yb2xlLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHZhbHVlLmNvbnRlbnRbMF0udGV4dC52YWx1ZSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAndGV4dCc6IHtcbiAgICAgICAgICAgIC8vIHRleHQgZGVsdGEgLSBhZGQgdG8gbGFzdCBtZXNzYWdlOlxuICAgICAgICAgICAgc2V0TWVzc2FnZXMobWVzc2FnZXMgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBsYXN0TWVzc2FnZSA9IG1lc3NhZ2VzW21lc3NhZ2VzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIC4uLm1lc3NhZ2VzLnNsaWNlKDAsIG1lc3NhZ2VzLmxlbmd0aCAtIDEpLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlkOiBsYXN0TWVzc2FnZS5pZCxcbiAgICAgICAgICAgICAgICAgIHJvbGU6IGxhc3RNZXNzYWdlLnJvbGUsXG4gICAgICAgICAgICAgICAgICBjb250ZW50OiBsYXN0TWVzc2FnZS5jb250ZW50ICsgdmFsdWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdkYXRhX21lc3NhZ2UnOiB7XG4gICAgICAgICAgICBzZXRNZXNzYWdlcyhtZXNzYWdlcyA9PiBbXG4gICAgICAgICAgICAgIC4uLm1lc3NhZ2VzLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWQ6IHZhbHVlLmlkID8/IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgICAgICAgICByb2xlOiAnZGF0YScsXG4gICAgICAgICAgICAgICAgY29udGVudDogJycsXG4gICAgICAgICAgICAgICAgZGF0YTogdmFsdWUuZGF0YSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnYXNzaXN0YW50X2NvbnRyb2xfZGF0YSc6IHtcbiAgICAgICAgICAgIHNldFRocmVhZElkKHZhbHVlLnRocmVhZElkKTtcblxuICAgICAgICAgICAgLy8gc2V0IGlkIG9mIGxhc3QgbWVzc2FnZTpcbiAgICAgICAgICAgIHNldE1lc3NhZ2VzKG1lc3NhZ2VzID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgbGFzdE1lc3NhZ2UgPSBtZXNzYWdlc1ttZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgbGFzdE1lc3NhZ2UuaWQgPSB2YWx1ZS5tZXNzYWdlSWQ7XG4gICAgICAgICAgICAgIHJldHVybiBbLi4ubWVzc2FnZXMuc2xpY2UoMCwgbWVzc2FnZXMubGVuZ3RoIC0gMSksIGxhc3RNZXNzYWdlXTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdlcnJvcic6IHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yT2JqID0gbmV3IEVycm9yKHZhbHVlKTtcbiAgICAgICAgICAgIHNldEVycm9yKGVycm9yT2JqKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAob25FcnJvciAmJiBlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICBzZXRFcnJvcihlcnJvciBhcyBFcnJvcik7XG4gICAgfVxuXG4gICAgc2V0U3RhdHVzKCdhd2FpdGluZ19tZXNzYWdlJyk7XG4gIH07XG5cbiAgY29uc3Qgc3VibWl0TWVzc2FnZSA9IGFzeW5jIChcbiAgICBldmVudD86IFJlYWN0LkZvcm1FdmVudDxIVE1MRm9ybUVsZW1lbnQ+LFxuICAgIHJlcXVlc3RPcHRpb25zPzoge1xuICAgICAgZGF0YT86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gICAgfSxcbiAgKSA9PiB7XG4gICAgZXZlbnQ/LnByZXZlbnREZWZhdWx0Py4oKTtcblxuICAgIGlmIChpbnB1dCA9PT0gJycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhcHBlbmQoeyByb2xlOiAndXNlcicsIGNvbnRlbnQ6IGlucHV0IH0sIHJlcXVlc3RPcHRpb25zKTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGFwcGVuZCxcbiAgICBtZXNzYWdlcyxcbiAgICBzZXRNZXNzYWdlcyxcbiAgICB0aHJlYWRJZCxcbiAgICBpbnB1dCxcbiAgICBzZXRJbnB1dCxcbiAgICBoYW5kbGVJbnB1dENoYW5nZSxcbiAgICBzdWJtaXRNZXNzYWdlLFxuICAgIHN0YXR1cyxcbiAgICBlcnJvcixcbiAgfTtcbn1cblxuLyoqXG5AZGVwcmVjYXRlZCBVc2UgYHVzZUFzc2lzdGFudGAgaW5zdGVhZC5cbiAqL1xuZXhwb3J0IGNvbnN0IGV4cGVyaW1lbnRhbF91c2VBc3Npc3RhbnQgPSB1c2VBc3Npc3RhbnQ7XG4iXSwibmFtZXMiOlsidXNlQ2FsbGJhY2siLCJ1c2VFZmZlY3QiLCJ1c2VJZCIsInVzZVJlZiIsInVzZVN0YXRlIiwidXNlU1dSIiwidGV4dFN0cmVhbVBhcnQiLCJjb2RlIiwibmFtZSIsInBhcnNlIiwidmFsdWUiLCJFcnJvciIsInR5cGUiLCJmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0IiwiZnVuY3Rpb25fY2FsbCIsImFyZ3VtZW50cyIsImRhdGFTdHJlYW1QYXJ0IiwiQXJyYXkiLCJpc0FycmF5IiwiZXJyb3JTdHJlYW1QYXJ0IiwiYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQiLCJpZCIsInJvbGUiLCJjb250ZW50IiwiZXZlcnkiLCJpdGVtIiwidGV4dCIsImFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydCIsInRocmVhZElkIiwibWVzc2FnZUlkIiwiZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0IiwidG9vbENhbGxTdHJlYW1QYXJ0IiwidG9vbF9jYWxscyIsInNvbWUiLCJ0YyIsImZ1bmN0aW9uIiwibWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydCIsInN0cmVhbVBhcnRzIiwic3RyZWFtUGFydHNCeUNvZGUiLCJTdHJlYW1TdHJpbmdQcmVmaXhlcyIsInZhbGlkQ29kZXMiLCJtYXAiLCJwYXJ0IiwicGFyc2VTdHJlYW1QYXJ0IiwibGluZSIsImZpcnN0U2VwYXJhdG9ySW5kZXgiLCJpbmRleE9mIiwicHJlZml4Iiwic2xpY2UiLCJpbmNsdWRlcyIsInRleHRWYWx1ZSIsImpzb25WYWx1ZSIsIkpTT04iLCJORVdMSU5FIiwiY2hhckNvZGVBdCIsImNvbmNhdENodW5rcyIsImNodW5rcyIsInRvdGFsTGVuZ3RoIiwiY29uY2F0ZW5hdGVkQ2h1bmtzIiwiVWludDhBcnJheSIsIm9mZnNldCIsImNodW5rIiwic2V0IiwibGVuZ3RoIiwicmVhZERhdGFTdHJlYW0iLCJyZWFkZXIiLCJpc0Fib3J0ZWQiLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJyZWFkIiwicHVzaCIsImRlY29kZSIsInN0cmVhbSIsInNwbGl0IiwiZmlsdGVyIiwic3RyZWFtUGFydCIsImNhbmNlbCIsImN1c3RvbUFscGhhYmV0IiwiZ2VuZXJhdGVJZCIsImFzc2lnbkFubm90YXRpb25zVG9NZXNzYWdlIiwibWVzc2FnZSIsImFubm90YXRpb25zIiwicGFyc2VDb21wbGV4UmVzcG9uc2UiLCJhYm9ydENvbnRyb2xsZXJSZWYiLCJ1cGRhdGUiLCJvbkZpbmlzaCIsImdldEN1cnJlbnREYXRlIiwiRGF0ZSIsImNyZWF0ZWRBdCIsInByZWZpeE1hcCIsImRhdGEiLCJtZXNzYWdlX2Fubm90YXRpb25zIiwiY3VycmVudCIsImZ1bmN0aW9uQ2FsbE1lc3NhZ2UiLCJ0b29sQ2FsbE1lc3NhZ2UiLCJyZXNwb25zZU1lc3NhZ2UiLCJtZXNzYWdlUHJlZml4S2V5cyIsImZvckVhY2giLCJrZXkiLCJtZXJnZWQiLCJCb29sZWFuIiwibWVzc2FnZXMiLCJjcmVhdGVDaHVua0RlY29kZXIiLCJjb21wbGV4IiwiZGVjb2RlZCIsImNhbGxDaGF0QXBpIiwiYXBpIiwiYm9keSIsInN0cmVhbU1vZGUiLCJjcmVkZW50aWFscyIsImhlYWRlcnMiLCJhYm9ydENvbnRyb2xsZXIiLCJyZXN0b3JlTWVzc2FnZXNPbkZhaWx1cmUiLCJvblJlc3BvbnNlIiwib25VcGRhdGUiLCJfYSIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJzdHJpbmdpZnkiLCJzaWduYWwiLCJjYXRjaCIsImVyciIsIm9rIiwiZ2V0UmVhZGVyIiwicmVzdWx0TWVzc2FnZSIsImRvbmUiLCJleGhhdXN0aXZlQ2hlY2siLCJwcm9jZXNzQ2hhdFN0cmVhbSIsImdldFN0cmVhbWVkUmVzcG9uc2UiLCJleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwiLCJleHBlcmltZW50YWxfb25Ub29sQ2FsbCIsInVwZGF0ZUNoYXRSZXF1ZXN0IiwiZ2V0Q3VycmVudE1lc3NhZ2VzIiwibWVzc2FnZXNBbmREYXRhT3JKdXN0TWVzc2FnZSIsImhhc0ZvbGxvd2luZ1Jlc3BvbnNlIiwiZnVuY3Rpb25DYWxsIiwiY29uc29sZSIsIndhcm4iLCJmdW5jdGlvbkNhbGxSZXNwb25zZSIsInRvb2xDYWxscyIsInRvb2xDYWxsIiwidG9vbENhbGxSZXNwb25zZSIsImZpeEZ1bmN0aW9uQ2FsbEFyZ3VtZW50cyIsInN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlIiwiY2hhdFJlcXVlc3QiLCJtdXRhdGUiLCJtdXRhdGVTdHJlYW1EYXRhIiwiZXhpc3RpbmdEYXRhIiwiZXh0cmFNZXRhZGF0YVJlZiIsIm1lc3NhZ2VzUmVmIiwic2VuZEV4dHJhTWVzc2FnZUZpZWxkcyIsIl9iIiwicHJldmlvdXNNZXNzYWdlcyIsImNvbnN0cnVjdGVkTWVzc2FnZXNQYXlsb2FkIiwidG9vbF9jYWxsX2lkIiwicmVwbHlJZCIsInJlYWRSb3ciLCJwcm9taXNlIiwidWkiLCJuZXh0IiwiZSIsIm9wdGlvbnMiLCJmdW5jdGlvbnMiLCJ0b29scyIsInRvb2xfY2hvaWNlIiwidXNlQ2hhdCIsImluaXRpYWxNZXNzYWdlcyIsImluaXRpYWxJbnB1dCIsIm9uRXJyb3IiLCJob29rSWQiLCJpZEtleSIsImNoYXRLZXkiLCJpbml0aWFsTWVzc2FnZXNGYWxsYmFjayIsImZhbGxiYWNrRGF0YSIsImlzTG9hZGluZyIsIm11dGF0ZUxvYWRpbmciLCJzdHJlYW1EYXRhIiwiZXJyb3IiLCJzZXRFcnJvciIsInRyaWdnZXJSZXF1ZXN0IiwiQWJvcnRDb250cm9sbGVyIiwiY2hhdFJlcXVlc3RQYXJhbSIsImFwcGVuZCIsImNvbmNhdCIsInJlbG9hZCIsImxhc3RNZXNzYWdlIiwic3RvcCIsImFib3J0Iiwic2V0TWVzc2FnZXMiLCJpbnB1dCIsInNldElucHV0IiwiaGFuZGxlU3VibWl0IiwibWV0YWRhdGEiLCJwcmV2ZW50RGVmYXVsdCIsImhhbmRsZUlucHV0Q2hhbmdlIiwidGFyZ2V0IiwiY2FsbENvbXBsZXRpb25BcGkiLCJwcm9tcHQiLCJzZXRDb21wbGV0aW9uIiwic2V0TG9hZGluZyIsInNldEFib3J0Q29udHJvbGxlciIsIm9uRGF0YSIsInJlcyIsInJlc3VsdCIsInVzZUNvbXBsZXRpb24iLCJpbml0aWFsQ29tcGxldGlvbiIsImNvbXBsZXRpb25JZCIsImNvbXBsZXRpb24iLCJjb21wbGV0ZSIsInVzZUFzc2lzdGFudCIsInRocmVhZElkUGFyYW0iLCJzZXRUaHJlYWRJZCIsInN0YXR1cyIsInNldFN0YXR1cyIsImV2ZW50IiwicmVxdWVzdE9wdGlvbnMiLCJlcnJvck9iaiIsInN1Ym1pdE1lc3NhZ2UiLCJjYWxsIiwiZXhwZXJpbWVudGFsX3VzZUFzc2lzdGFudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ai/react/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/ai/dist/index.mjs":
/*!****************************************!*\
  !*** ./node_modules/ai/dist/index.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AIStream: () => (/* binding */ AIStream),\n/* harmony export */   APICallError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError),\n/* harmony export */   AWSBedrockAnthropicMessagesStream: () => (/* binding */ AWSBedrockAnthropicMessagesStream),\n/* harmony export */   AWSBedrockAnthropicStream: () => (/* binding */ AWSBedrockAnthropicStream),\n/* harmony export */   AWSBedrockCohereStream: () => (/* binding */ AWSBedrockCohereStream),\n/* harmony export */   AWSBedrockLlama2Stream: () => (/* binding */ AWSBedrockLlama2Stream),\n/* harmony export */   AWSBedrockStream: () => (/* binding */ AWSBedrockStream),\n/* harmony export */   AnthropicStream: () => (/* binding */ AnthropicStream),\n/* harmony export */   AssistantResponse: () => (/* binding */ AssistantResponse),\n/* harmony export */   CohereStream: () => (/* binding */ CohereStream),\n/* harmony export */   EmptyResponseBodyError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.EmptyResponseBodyError),\n/* harmony export */   GenerateObjectResult: () => (/* binding */ GenerateObjectResult),\n/* harmony export */   GenerateTextResult: () => (/* binding */ GenerateTextResult),\n/* harmony export */   GoogleGenerativeAIStream: () => (/* binding */ GoogleGenerativeAIStream),\n/* harmony export */   HuggingFaceStream: () => (/* binding */ HuggingFaceStream),\n/* harmony export */   InkeepStream: () => (/* binding */ InkeepStream),\n/* harmony export */   InvalidArgumentError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError),\n/* harmony export */   InvalidDataContentError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidDataContentError),\n/* harmony export */   InvalidPromptError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError),\n/* harmony export */   InvalidResponseDataError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidResponseDataError),\n/* harmony export */   InvalidToolArgumentsError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidToolArgumentsError),\n/* harmony export */   JSONParseError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError),\n/* harmony export */   LangChainStream: () => (/* binding */ LangChainStream),\n/* harmony export */   LoadAPIKeyError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadAPIKeyError),\n/* harmony export */   MistralStream: () => (/* binding */ MistralStream),\n/* harmony export */   NoObjectGeneratedError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoObjectGeneratedError),\n/* harmony export */   NoSuchToolError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchToolError),\n/* harmony export */   OpenAIStream: () => (/* binding */ OpenAIStream),\n/* harmony export */   ReplicateStream: () => (/* binding */ ReplicateStream),\n/* harmony export */   RetryError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.RetryError),\n/* harmony export */   StreamData: () => (/* binding */ StreamData),\n/* harmony export */   StreamObjectResult: () => (/* binding */ StreamObjectResult),\n/* harmony export */   StreamTextResult: () => (/* binding */ StreamTextResult),\n/* harmony export */   StreamingTextResponse: () => (/* binding */ StreamingTextResponse),\n/* harmony export */   ToolCallParseError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.ToolCallParseError),\n/* harmony export */   TypeValidationError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError),\n/* harmony export */   UnsupportedFunctionalityError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError),\n/* harmony export */   UnsupportedJSONSchemaError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedJSONSchemaError),\n/* harmony export */   convertDataContentToBase64String: () => (/* binding */ convertDataContentToBase64String),\n/* harmony export */   convertDataContentToUint8Array: () => (/* binding */ convertDataContentToUint8Array),\n/* harmony export */   createCallbacksTransformer: () => (/* binding */ createCallbacksTransformer),\n/* harmony export */   createChunkDecoder: () => (/* binding */ createChunkDecoder),\n/* harmony export */   createEventStreamTransformer: () => (/* binding */ createEventStreamTransformer),\n/* harmony export */   createStreamDataTransformer: () => (/* binding */ createStreamDataTransformer),\n/* harmony export */   experimental_AssistantResponse: () => (/* binding */ experimental_AssistantResponse),\n/* harmony export */   experimental_StreamData: () => (/* binding */ experimental_StreamData),\n/* harmony export */   experimental_StreamingReactResponse: () => (/* binding */ experimental_StreamingReactResponse),\n/* harmony export */   experimental_generateObject: () => (/* binding */ experimental_generateObject),\n/* harmony export */   experimental_generateText: () => (/* binding */ experimental_generateText),\n/* harmony export */   experimental_streamObject: () => (/* binding */ experimental_streamObject),\n/* harmony export */   experimental_streamText: () => (/* binding */ experimental_streamText),\n/* harmony export */   formatStreamPart: () => (/* binding */ formatStreamPart),\n/* harmony export */   generateId: () => (/* binding */ generateId),\n/* harmony export */   isStreamStringEqualToType: () => (/* binding */ isStreamStringEqualToType),\n/* harmony export */   nanoid: () => (/* binding */ generateId),\n/* harmony export */   parseStreamPart: () => (/* binding */ parseStreamPart),\n/* harmony export */   readDataStream: () => (/* binding */ readDataStream),\n/* harmony export */   readableFromAsyncIterable: () => (/* binding */ readableFromAsyncIterable),\n/* harmony export */   streamToResponse: () => (/* binding */ streamToResponse),\n/* harmony export */   tool: () => (/* binding */ tool),\n/* harmony export */   trimStartOfStreamHelper: () => (/* binding */ trimStartOfStreamHelper)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ai-sdk/provider */ \"(rsc)/./node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(rsc)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var zod_to_json_schema__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zod-to-json-schema */ \"(rsc)/./node_modules/zod-to-json-schema/dist/esm/index.js\");\n/* harmony import */ var secure_json_parse__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! secure-json-parse */ \"(rsc)/./node_modules/secure-json-parse/index.js\");\n/* harmony import */ var nanoid_non_secure__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! nanoid/non-secure */ \"(rsc)/./node_modules/nanoid/non-secure/index.js\");\n/* harmony import */ var eventsource_parser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! eventsource-parser */ \"(rsc)/./node_modules/eventsource-parser/dist/index.js\");\n// core/generate-object/generate-object.ts\n\n\n\n// core/generate-text/token-usage.ts\nfunction calculateTokenUsage(usage) {\n  return {\n    promptTokens: usage.promptTokens,\n    completionTokens: usage.completionTokens,\n    totalTokens: usage.promptTokens + usage.completionTokens\n  };\n}\n\n// core/util/detect-image-mimetype.ts\nvar mimeTypeSignatures = [\n  { mimeType: \"image/gif\", bytes: [71, 73, 70] },\n  { mimeType: \"image/png\", bytes: [137, 80, 78, 71] },\n  { mimeType: \"image/jpeg\", bytes: [255, 216] },\n  { mimeType: \"image/webp\", bytes: [82, 73, 70, 70] }\n];\nfunction detectImageMimeType(image) {\n  for (const { bytes, mimeType } of mimeTypeSignatures) {\n    if (image.length >= bytes.length && bytes.every((byte, index) => image[index] === byte)) {\n      return mimeType;\n    }\n  }\n  return void 0;\n}\n\n// core/prompt/data-content.ts\n\n\nfunction convertDataContentToBase64String(content) {\n  if (typeof content === \"string\") {\n    return content;\n  }\n  if (content instanceof ArrayBuffer) {\n    return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.convertUint8ArrayToBase64)(new Uint8Array(content));\n  }\n  return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.convertUint8ArrayToBase64)(content);\n}\nfunction convertDataContentToUint8Array(content) {\n  if (content instanceof Uint8Array) {\n    return content;\n  }\n  if (typeof content === \"string\") {\n    return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.convertBase64ToUint8Array)(content);\n  }\n  if (content instanceof ArrayBuffer) {\n    return new Uint8Array(content);\n  }\n  throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidDataContentError({ content });\n}\n\n// core/prompt/convert-to-language-model-prompt.ts\nfunction convertToLanguageModelPrompt(prompt) {\n  const languageModelMessages = [];\n  if (prompt.system != null) {\n    languageModelMessages.push({ role: \"system\", content: prompt.system });\n  }\n  switch (prompt.type) {\n    case \"prompt\": {\n      languageModelMessages.push({\n        role: \"user\",\n        content: [{ type: \"text\", text: prompt.prompt }]\n      });\n      break;\n    }\n    case \"messages\": {\n      languageModelMessages.push(\n        ...prompt.messages.map((message) => {\n          switch (message.role) {\n            case \"user\": {\n              if (typeof message.content === \"string\") {\n                return {\n                  role: \"user\",\n                  content: [{ type: \"text\", text: message.content }]\n                };\n              }\n              return {\n                role: \"user\",\n                content: message.content.map(\n                  (part) => {\n                    var _a;\n                    switch (part.type) {\n                      case \"text\": {\n                        return part;\n                      }\n                      case \"image\": {\n                        if (part.image instanceof URL) {\n                          return {\n                            type: \"image\",\n                            image: part.image,\n                            mimeType: part.mimeType\n                          };\n                        }\n                        const imageUint8 = convertDataContentToUint8Array(\n                          part.image\n                        );\n                        return {\n                          type: \"image\",\n                          image: imageUint8,\n                          mimeType: (_a = part.mimeType) != null ? _a : detectImageMimeType(imageUint8)\n                        };\n                      }\n                    }\n                  }\n                )\n              };\n            }\n            case \"assistant\": {\n              if (typeof message.content === \"string\") {\n                return {\n                  role: \"assistant\",\n                  content: [{ type: \"text\", text: message.content }]\n                };\n              }\n              return { role: \"assistant\", content: message.content };\n            }\n            case \"tool\": {\n              return message;\n            }\n          }\n        })\n      );\n      break;\n    }\n    default: {\n      const _exhaustiveCheck = prompt;\n      throw new Error(`Unsupported prompt type: ${_exhaustiveCheck}`);\n    }\n  }\n  return languageModelMessages;\n}\n\n// core/prompt/get-validated-prompt.ts\n\nfunction getValidatedPrompt(prompt) {\n  if (prompt.prompt == null && prompt.messages == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError({\n      prompt,\n      message: \"prompt or messages must be defined\"\n    });\n  }\n  if (prompt.prompt != null && prompt.messages != null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError({\n      prompt,\n      message: \"prompt and messages cannot be defined at the same time\"\n    });\n  }\n  return prompt.prompt != null ? {\n    type: \"prompt\",\n    prompt: prompt.prompt,\n    messages: void 0,\n    system: prompt.system\n  } : {\n    type: \"messages\",\n    prompt: void 0,\n    messages: prompt.messages,\n    // only possible case bc of checks above\n    system: prompt.system\n  };\n}\n\n// core/prompt/prepare-call-settings.ts\n\nfunction prepareCallSettings({\n  maxTokens,\n  temperature,\n  topP,\n  presencePenalty,\n  frequencyPenalty,\n  seed,\n  maxRetries\n}) {\n  if (maxTokens != null) {\n    if (!Number.isInteger(maxTokens)) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n        parameter: \"maxTokens\",\n        value: maxTokens,\n        message: \"maxTokens must be an integer\"\n      });\n    }\n    if (maxTokens < 1) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n        parameter: \"maxTokens\",\n        value: maxTokens,\n        message: \"maxTokens must be >= 1\"\n      });\n    }\n  }\n  if (temperature != null) {\n    if (typeof temperature !== \"number\") {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n        parameter: \"temperature\",\n        value: temperature,\n        message: \"temperature must be a number\"\n      });\n    }\n  }\n  if (topP != null) {\n    if (typeof topP !== \"number\") {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n        parameter: \"topP\",\n        value: topP,\n        message: \"topP must be a number\"\n      });\n    }\n  }\n  if (presencePenalty != null) {\n    if (typeof presencePenalty !== \"number\") {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n        parameter: \"presencePenalty\",\n        value: presencePenalty,\n        message: \"presencePenalty must be a number\"\n      });\n    }\n  }\n  if (frequencyPenalty != null) {\n    if (typeof frequencyPenalty !== \"number\") {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n        parameter: \"frequencyPenalty\",\n        value: frequencyPenalty,\n        message: \"frequencyPenalty must be a number\"\n      });\n    }\n  }\n  if (seed != null) {\n    if (!Number.isInteger(seed)) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n        parameter: \"seed\",\n        value: seed,\n        message: \"seed must be an integer\"\n      });\n    }\n  }\n  if (maxRetries != null) {\n    if (!Number.isInteger(maxRetries)) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n        parameter: \"maxRetries\",\n        value: maxRetries,\n        message: \"maxRetries must be an integer\"\n      });\n    }\n    if (maxRetries < 0) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n        parameter: \"maxRetries\",\n        value: maxRetries,\n        message: \"maxRetries must be >= 0\"\n      });\n    }\n  }\n  return {\n    maxTokens,\n    temperature: temperature != null ? temperature : 0,\n    topP,\n    presencePenalty,\n    frequencyPenalty,\n    seed,\n    maxRetries: maxRetries != null ? maxRetries : 2\n  };\n}\n\n// core/util/convert-zod-to-json-schema.ts\n\nfunction convertZodToJSONSchema(zodSchema) {\n  return (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(zodSchema);\n}\n\n// core/util/retry-with-exponential-backoff.ts\n\n\n\n// core/util/delay.ts\nasync function delay(delayInMs) {\n  return new Promise((resolve) => setTimeout(resolve, delayInMs));\n}\n\n// core/util/retry-with-exponential-backoff.ts\nvar retryWithExponentialBackoff = ({\n  maxRetries = 2,\n  initialDelayInMs = 2e3,\n  backoffFactor = 2\n} = {}) => async (f) => _retryWithExponentialBackoff(f, {\n  maxRetries,\n  delayInMs: initialDelayInMs,\n  backoffFactor\n});\nasync function _retryWithExponentialBackoff(f, {\n  maxRetries,\n  delayInMs,\n  backoffFactor\n}, errors = []) {\n  try {\n    return await f();\n  } catch (error) {\n    if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.isAbortError)(error)) {\n      throw error;\n    }\n    if (maxRetries === 0) {\n      throw error;\n    }\n    const errorMessage = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage)(error);\n    const newErrors = [...errors, error];\n    const tryNumber = newErrors.length;\n    if (tryNumber > maxRetries) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.RetryError({\n        message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,\n        reason: \"maxRetriesExceeded\",\n        errors: newErrors\n      });\n    }\n    if (error instanceof Error && _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError.isAPICallError(error) && error.isRetryable === true && tryNumber <= maxRetries) {\n      await delay(delayInMs);\n      return _retryWithExponentialBackoff(\n        f,\n        { maxRetries, delayInMs: backoffFactor * delayInMs, backoffFactor },\n        newErrors\n      );\n    }\n    if (tryNumber === 1) {\n      throw error;\n    }\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.RetryError({\n      message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,\n      reason: \"errorNotRetryable\",\n      errors: newErrors\n    });\n  }\n}\n\n// core/generate-object/inject-json-schema-into-system.ts\nvar DEFAULT_SCHEMA_PREFIX = \"JSON schema:\";\nvar DEFAULT_SCHEMA_SUFFIX = \"You MUST answer with a JSON object that matches the JSON schema above.\";\nfunction injectJsonSchemaIntoSystem({\n  system,\n  schema,\n  schemaPrefix = DEFAULT_SCHEMA_PREFIX,\n  schemaSuffix = DEFAULT_SCHEMA_SUFFIX\n}) {\n  return [\n    system,\n    system != null ? \"\" : null,\n    // add a newline if system is not null\n    schemaPrefix,\n    JSON.stringify(schema),\n    schemaSuffix\n  ].filter((line) => line != null).join(\"\\n\");\n}\n\n// core/generate-object/generate-object.ts\nasync function experimental_generateObject({\n  model,\n  schema,\n  mode,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  ...settings\n}) {\n  var _a, _b;\n  const retry = retryWithExponentialBackoff({ maxRetries });\n  const jsonSchema = convertZodToJSONSchema(schema);\n  if (mode === \"auto\" || mode == null) {\n    mode = model.defaultObjectGenerationMode;\n  }\n  let result;\n  let finishReason;\n  let usage;\n  let warnings;\n  let rawResponse;\n  let logprobs;\n  switch (mode) {\n    case \"json\": {\n      const validatedPrompt = getValidatedPrompt({\n        system: injectJsonSchemaIntoSystem({ system, schema: jsonSchema }),\n        prompt,\n        messages\n      });\n      const generateResult = await retry(() => {\n        return model.doGenerate({\n          mode: { type: \"object-json\" },\n          ...prepareCallSettings(settings),\n          inputFormat: validatedPrompt.type,\n          prompt: convertToLanguageModelPrompt(validatedPrompt),\n          abortSignal\n        });\n      });\n      if (generateResult.text === void 0) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoObjectGeneratedError();\n      }\n      result = generateResult.text;\n      finishReason = generateResult.finishReason;\n      usage = generateResult.usage;\n      warnings = generateResult.warnings;\n      rawResponse = generateResult.rawResponse;\n      logprobs = generateResult.logprobs;\n      break;\n    }\n    case \"grammar\": {\n      const validatedPrompt = getValidatedPrompt({\n        system: injectJsonSchemaIntoSystem({ system, schema: jsonSchema }),\n        prompt,\n        messages\n      });\n      const generateResult = await retry(\n        () => model.doGenerate({\n          mode: { type: \"object-grammar\", schema: jsonSchema },\n          ...settings,\n          inputFormat: validatedPrompt.type,\n          prompt: convertToLanguageModelPrompt(validatedPrompt),\n          abortSignal\n        })\n      );\n      if (generateResult.text === void 0) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoObjectGeneratedError();\n      }\n      result = generateResult.text;\n      finishReason = generateResult.finishReason;\n      usage = generateResult.usage;\n      warnings = generateResult.warnings;\n      rawResponse = generateResult.rawResponse;\n      logprobs = generateResult.logprobs;\n      break;\n    }\n    case \"tool\": {\n      const validatedPrompt = getValidatedPrompt({\n        system,\n        prompt,\n        messages\n      });\n      const generateResult = await retry(\n        () => model.doGenerate({\n          mode: {\n            type: \"object-tool\",\n            tool: {\n              type: \"function\",\n              name: \"json\",\n              description: \"Respond with a JSON object.\",\n              parameters: jsonSchema\n            }\n          },\n          ...settings,\n          inputFormat: validatedPrompt.type,\n          prompt: convertToLanguageModelPrompt(validatedPrompt),\n          abortSignal\n        })\n      );\n      const functionArgs = (_b = (_a = generateResult.toolCalls) == null ? void 0 : _a[0]) == null ? void 0 : _b.args;\n      if (functionArgs === void 0) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoObjectGeneratedError();\n      }\n      result = functionArgs;\n      finishReason = generateResult.finishReason;\n      usage = generateResult.usage;\n      warnings = generateResult.warnings;\n      rawResponse = generateResult.rawResponse;\n      logprobs = generateResult.logprobs;\n      break;\n    }\n    case void 0: {\n      throw new Error(\"Model does not have a default object generation mode.\");\n    }\n    default: {\n      const _exhaustiveCheck = mode;\n      throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);\n    }\n  }\n  const parseResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.safeParseJSON)({ text: result, schema });\n  if (!parseResult.success) {\n    throw parseResult.error;\n  }\n  return new GenerateObjectResult({\n    object: parseResult.value,\n    finishReason,\n    usage: calculateTokenUsage(usage),\n    warnings,\n    rawResponse,\n    logprobs\n  });\n}\nvar GenerateObjectResult = class {\n  constructor(options) {\n    this.object = options.object;\n    this.finishReason = options.finishReason;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.rawResponse = options.rawResponse;\n    this.logprobs = options.logprobs;\n  }\n};\n\n// core/util/async-iterable-stream.ts\nfunction createAsyncIterableStream(source, transformer) {\n  const transformedStream = source.pipeThrough(\n    new TransformStream(transformer)\n  );\n  transformedStream[Symbol.asyncIterator] = () => {\n    const reader = transformedStream.getReader();\n    return {\n      async next() {\n        const { done, value } = await reader.read();\n        return done ? { done: true, value: void 0 } : { done: false, value };\n      }\n    };\n  };\n  return transformedStream;\n}\n\n// core/util/is-deep-equal-data.ts\nfunction isDeepEqualData(obj1, obj2) {\n  if (obj1 === obj2)\n    return true;\n  if (obj1 == null || obj2 == null)\n    return false;\n  if (typeof obj1 !== \"object\" && typeof obj2 !== \"object\")\n    return obj1 === obj2;\n  if (obj1.constructor !== obj2.constructor)\n    return false;\n  if (obj1 instanceof Date && obj2 instanceof Date) {\n    return obj1.getTime() === obj2.getTime();\n  }\n  if (Array.isArray(obj1)) {\n    if (obj1.length !== obj2.length)\n      return false;\n    for (let i = 0; i < obj1.length; i++) {\n      if (!isDeepEqualData(obj1[i], obj2[i]))\n        return false;\n    }\n    return true;\n  }\n  const keys1 = Object.keys(obj1);\n  const keys2 = Object.keys(obj2);\n  if (keys1.length !== keys2.length)\n    return false;\n  for (const key of keys1) {\n    if (!keys2.includes(key))\n      return false;\n    if (!isDeepEqualData(obj1[key], obj2[key]))\n      return false;\n  }\n  return true;\n}\n\n// core/util/parse-partial-json.ts\n\n\n// core/util/fix-json.ts\nfunction fixJson(input) {\n  const stack = [\"ROOT\"];\n  let lastValidIndex = -1;\n  let literalStart = null;\n  function processValueStart(char, i, swapState) {\n    {\n      switch (char) {\n        case '\"': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_STRING\");\n          break;\n        }\n        case \"f\":\n        case \"t\":\n        case \"n\": {\n          lastValidIndex = i;\n          literalStart = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_LITERAL\");\n          break;\n        }\n        case \"-\": {\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_NUMBER\");\n          break;\n        }\n        case \"0\":\n        case \"1\":\n        case \"2\":\n        case \"3\":\n        case \"4\":\n        case \"5\":\n        case \"6\":\n        case \"7\":\n        case \"8\":\n        case \"9\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_NUMBER\");\n          break;\n        }\n        case \"{\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_OBJECT_START\");\n          break;\n        }\n        case \"[\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_ARRAY_START\");\n          break;\n        }\n      }\n    }\n  }\n  function processAfterObjectValue(char, i) {\n    switch (char) {\n      case \",\": {\n        stack.pop();\n        stack.push(\"INSIDE_OBJECT_AFTER_COMMA\");\n        break;\n      }\n      case \"}\": {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n  function processAfterArrayValue(char, i) {\n    switch (char) {\n      case \",\": {\n        stack.pop();\n        stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n        break;\n      }\n      case \"]\": {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i];\n    const currentState = stack[stack.length - 1];\n    switch (currentState) {\n      case \"ROOT\":\n        processValueStart(char, i, \"FINISH\");\n        break;\n      case \"INSIDE_OBJECT_START\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_KEY\");\n            break;\n          }\n          case \"}\": {\n            stack.pop();\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_AFTER_COMMA\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_KEY\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_KEY\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_AFTER_KEY\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_AFTER_KEY\": {\n        switch (char) {\n          case \":\": {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_BEFORE_VALUE\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_BEFORE_VALUE\": {\n        processValueStart(char, i, \"INSIDE_OBJECT_AFTER_VALUE\");\n        break;\n      }\n      case \"INSIDE_OBJECT_AFTER_VALUE\": {\n        processAfterObjectValue(char, i);\n        break;\n      }\n      case \"INSIDE_STRING\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            lastValidIndex = i;\n            break;\n          }\n          case \"\\\\\": {\n            stack.push(\"INSIDE_STRING_ESCAPE\");\n            break;\n          }\n          default: {\n            lastValidIndex = i;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_ARRAY_START\": {\n        switch (char) {\n          case \"]\": {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n          default: {\n            lastValidIndex = i;\n            processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_ARRAY_AFTER_VALUE\": {\n        switch (char) {\n          case \",\": {\n            stack.pop();\n            stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n            break;\n          }\n          case \"]\": {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n          default: {\n            lastValidIndex = i;\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_ARRAY_AFTER_COMMA\": {\n        processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n        break;\n      }\n      case \"INSIDE_STRING_ESCAPE\": {\n        stack.pop();\n        lastValidIndex = i;\n        break;\n      }\n      case \"INSIDE_NUMBER\": {\n        switch (char) {\n          case \"0\":\n          case \"1\":\n          case \"2\":\n          case \"3\":\n          case \"4\":\n          case \"5\":\n          case \"6\":\n          case \"7\":\n          case \"8\":\n          case \"9\": {\n            lastValidIndex = i;\n            break;\n          }\n          case \"e\":\n          case \"E\":\n          case \"-\":\n          case \".\": {\n            break;\n          }\n          case \",\": {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n              processAfterArrayValue(char, i);\n            }\n            if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n              processAfterObjectValue(char, i);\n            }\n            break;\n          }\n          case \"}\": {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n              processAfterObjectValue(char, i);\n            }\n            break;\n          }\n          case \"]\": {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n              processAfterArrayValue(char, i);\n            }\n            break;\n          }\n          default: {\n            stack.pop();\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_LITERAL\": {\n        const partialLiteral = input.substring(literalStart, i + 1);\n        if (!\"false\".startsWith(partialLiteral) && !\"true\".startsWith(partialLiteral) && !\"null\".startsWith(partialLiteral)) {\n          stack.pop();\n          if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n            processAfterObjectValue(char, i);\n          } else if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n            processAfterArrayValue(char, i);\n          }\n        } else {\n          lastValidIndex = i;\n        }\n        break;\n      }\n    }\n  }\n  let result = input.slice(0, lastValidIndex + 1);\n  for (let i = stack.length - 1; i >= 0; i--) {\n    const state = stack[i];\n    switch (state) {\n      case \"INSIDE_STRING\": {\n        result += '\"';\n        break;\n      }\n      case \"INSIDE_OBJECT_KEY\":\n      case \"INSIDE_OBJECT_AFTER_KEY\":\n      case \"INSIDE_OBJECT_AFTER_COMMA\":\n      case \"INSIDE_OBJECT_START\":\n      case \"INSIDE_OBJECT_BEFORE_VALUE\":\n      case \"INSIDE_OBJECT_AFTER_VALUE\": {\n        result += \"}\";\n        break;\n      }\n      case \"INSIDE_ARRAY_START\":\n      case \"INSIDE_ARRAY_AFTER_COMMA\":\n      case \"INSIDE_ARRAY_AFTER_VALUE\": {\n        result += \"]\";\n        break;\n      }\n      case \"INSIDE_LITERAL\": {\n        const partialLiteral = input.substring(literalStart, input.length);\n        if (\"true\".startsWith(partialLiteral)) {\n          result += \"true\".slice(partialLiteral.length);\n        } else if (\"false\".startsWith(partialLiteral)) {\n          result += \"false\".slice(partialLiteral.length);\n        } else if (\"null\".startsWith(partialLiteral)) {\n          result += \"null\".slice(partialLiteral.length);\n        }\n      }\n    }\n  }\n  return result;\n}\n\n// core/util/parse-partial-json.ts\nfunction parsePartialJson(jsonText) {\n  if (jsonText == null) {\n    return void 0;\n  }\n  try {\n    return secure_json_parse__WEBPACK_IMPORTED_MODULE_3__.parse(jsonText);\n  } catch (ignored) {\n    try {\n      const fixedJsonText = fixJson(jsonText);\n      return secure_json_parse__WEBPACK_IMPORTED_MODULE_3__.parse(fixedJsonText);\n    } catch (ignored2) {\n    }\n  }\n  return void 0;\n}\n\n// core/generate-object/stream-object.ts\nasync function experimental_streamObject({\n  model,\n  schema,\n  mode,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  ...settings\n}) {\n  const retry = retryWithExponentialBackoff({ maxRetries });\n  const jsonSchema = convertZodToJSONSchema(schema);\n  if (mode === \"auto\" || mode == null) {\n    mode = model.defaultObjectGenerationMode;\n  }\n  let callOptions;\n  let transformer;\n  switch (mode) {\n    case \"json\": {\n      const validatedPrompt = getValidatedPrompt({\n        system: injectJsonSchemaIntoSystem({ system, schema: jsonSchema }),\n        prompt,\n        messages\n      });\n      callOptions = {\n        mode: { type: \"object-json\" },\n        ...prepareCallSettings(settings),\n        inputFormat: validatedPrompt.type,\n        prompt: convertToLanguageModelPrompt(validatedPrompt),\n        abortSignal\n      };\n      transformer = {\n        transform: (chunk, controller) => {\n          switch (chunk.type) {\n            case \"text-delta\":\n              controller.enqueue(chunk.textDelta);\n              break;\n            case \"finish\":\n            case \"error\":\n              controller.enqueue(chunk);\n              break;\n          }\n        }\n      };\n      break;\n    }\n    case \"grammar\": {\n      const validatedPrompt = getValidatedPrompt({\n        system: injectJsonSchemaIntoSystem({ system, schema: jsonSchema }),\n        prompt,\n        messages\n      });\n      callOptions = {\n        mode: { type: \"object-grammar\", schema: jsonSchema },\n        ...settings,\n        inputFormat: validatedPrompt.type,\n        prompt: convertToLanguageModelPrompt(validatedPrompt),\n        abortSignal\n      };\n      transformer = {\n        transform: (chunk, controller) => {\n          switch (chunk.type) {\n            case \"text-delta\":\n              controller.enqueue(chunk.textDelta);\n              break;\n            case \"finish\":\n            case \"error\":\n              controller.enqueue(chunk);\n              break;\n          }\n        }\n      };\n      break;\n    }\n    case \"tool\": {\n      const validatedPrompt = getValidatedPrompt({\n        system,\n        prompt,\n        messages\n      });\n      callOptions = {\n        mode: {\n          type: \"object-tool\",\n          tool: {\n            type: \"function\",\n            name: \"json\",\n            description: \"Respond with a JSON object.\",\n            parameters: jsonSchema\n          }\n        },\n        ...settings,\n        inputFormat: validatedPrompt.type,\n        prompt: convertToLanguageModelPrompt(validatedPrompt),\n        abortSignal\n      };\n      transformer = {\n        transform(chunk, controller) {\n          switch (chunk.type) {\n            case \"tool-call-delta\":\n              controller.enqueue(chunk.argsTextDelta);\n              break;\n            case \"finish\":\n            case \"error\":\n              controller.enqueue(chunk);\n              break;\n          }\n        }\n      };\n      break;\n    }\n    case void 0: {\n      throw new Error(\"Model does not have a default object generation mode.\");\n    }\n    default: {\n      const _exhaustiveCheck = mode;\n      throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);\n    }\n  }\n  const result = await retry(() => model.doStream(callOptions));\n  return new StreamObjectResult({\n    stream: result.stream.pipeThrough(new TransformStream(transformer)),\n    warnings: result.warnings,\n    rawResponse: result.rawResponse\n  });\n}\nvar StreamObjectResult = class {\n  constructor({\n    stream,\n    warnings,\n    rawResponse\n  }) {\n    this.originalStream = stream;\n    this.warnings = warnings;\n    this.rawResponse = rawResponse;\n  }\n  get partialObjectStream() {\n    let accumulatedText = \"\";\n    let latestObject = void 0;\n    return createAsyncIterableStream(this.originalStream, {\n      transform(chunk, controller) {\n        if (typeof chunk === \"string\") {\n          accumulatedText += chunk;\n          const currentObject = parsePartialJson(\n            accumulatedText\n          );\n          if (!isDeepEqualData(latestObject, currentObject)) {\n            latestObject = currentObject;\n            controller.enqueue(currentObject);\n          }\n        } else if (chunk.type === \"error\") {\n          throw chunk.error;\n        }\n      }\n    });\n  }\n  get fullStream() {\n    let accumulatedText = \"\";\n    let latestObject = void 0;\n    return createAsyncIterableStream(this.originalStream, {\n      transform(chunk, controller) {\n        if (typeof chunk === \"string\") {\n          accumulatedText += chunk;\n          const currentObject = parsePartialJson(\n            accumulatedText\n          );\n          if (!isDeepEqualData(latestObject, currentObject)) {\n            latestObject = currentObject;\n            controller.enqueue({ type: \"object\", object: currentObject });\n          }\n        } else {\n          switch (chunk.type) {\n            case \"finish\":\n              controller.enqueue({\n                ...chunk,\n                usage: calculateTokenUsage(chunk.usage)\n              });\n              break;\n            default:\n              controller.enqueue(chunk);\n              break;\n          }\n        }\n      }\n    });\n  }\n};\n\n// core/generate-text/tool-call.ts\n\n\nfunction parseToolCall({\n  toolCall,\n  tools\n}) {\n  const toolName = toolCall.toolName;\n  if (tools == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchToolError({ toolName: toolCall.toolName });\n  }\n  const tool2 = tools[toolName];\n  if (tool2 == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchToolError({\n      toolName: toolCall.toolName,\n      availableTools: Object.keys(tools)\n    });\n  }\n  const parseResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.safeParseJSON)({\n    text: toolCall.args,\n    schema: tool2.parameters\n  });\n  if (parseResult.success === false) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidToolArgumentsError({\n      toolName,\n      toolArgs: toolCall.args,\n      cause: parseResult.error\n    });\n  }\n  return {\n    type: \"tool-call\",\n    toolCallId: toolCall.toolCallId,\n    toolName,\n    args: parseResult.value\n  };\n}\n\n// core/generate-text/generate-text.ts\nasync function experimental_generateText({\n  model,\n  tools,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  ...settings\n}) {\n  var _a, _b;\n  const retry = retryWithExponentialBackoff({ maxRetries });\n  const validatedPrompt = getValidatedPrompt({ system, prompt, messages });\n  const modelResponse = await retry(() => {\n    return model.doGenerate({\n      mode: {\n        type: \"regular\",\n        tools: tools == null ? void 0 : Object.entries(tools).map(([name, tool2]) => ({\n          type: \"function\",\n          name,\n          description: tool2.description,\n          parameters: convertZodToJSONSchema(tool2.parameters)\n        }))\n      },\n      ...prepareCallSettings(settings),\n      inputFormat: validatedPrompt.type,\n      prompt: convertToLanguageModelPrompt(validatedPrompt),\n      abortSignal\n    });\n  });\n  const toolCalls = [];\n  for (const modelToolCall of (_a = modelResponse.toolCalls) != null ? _a : []) {\n    toolCalls.push(parseToolCall({ toolCall: modelToolCall, tools }));\n  }\n  const toolResults = tools == null ? [] : await executeTools({ toolCalls, tools });\n  return new GenerateTextResult({\n    // Always return a string so that the caller doesn't have to check for undefined.\n    // If they need to check if the model did not return any text,\n    // they can check the length of the string:\n    text: (_b = modelResponse.text) != null ? _b : \"\",\n    toolCalls,\n    toolResults,\n    finishReason: modelResponse.finishReason,\n    usage: calculateTokenUsage(modelResponse.usage),\n    warnings: modelResponse.warnings,\n    rawResponse: modelResponse.rawResponse,\n    logprobs: modelResponse.logprobs\n  });\n}\nasync function executeTools({\n  toolCalls,\n  tools\n}) {\n  const toolResults = await Promise.all(\n    toolCalls.map(async (toolCall) => {\n      const tool2 = tools[toolCall.toolName];\n      if ((tool2 == null ? void 0 : tool2.execute) == null) {\n        return void 0;\n      }\n      const result = await tool2.execute(toolCall.args);\n      return {\n        toolCallId: toolCall.toolCallId,\n        toolName: toolCall.toolName,\n        args: toolCall.args,\n        result\n      };\n    })\n  );\n  return toolResults.filter(\n    (result) => result != null\n  );\n}\nvar GenerateTextResult = class {\n  constructor(options) {\n    this.text = options.text;\n    this.toolCalls = options.toolCalls;\n    this.toolResults = options.toolResults;\n    this.finishReason = options.finishReason;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.rawResponse = options.rawResponse;\n    this.logprobs = options.logprobs;\n  }\n};\n\n// core/generate-text/run-tools-transformation.ts\n\n\n// shared/generate-id.ts\n\nvar generateId = (0,nanoid_non_secure__WEBPACK_IMPORTED_MODULE_4__.customAlphabet)(\n  \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\",\n  7\n);\n\n// core/generate-text/run-tools-transformation.ts\nfunction runToolsTransformation({\n  tools,\n  generatorStream\n}) {\n  let canClose = false;\n  const outstandingToolCalls = /* @__PURE__ */ new Set();\n  let toolResultsStreamController = null;\n  const toolResultsStream = new ReadableStream({\n    start(controller) {\n      toolResultsStreamController = controller;\n    }\n  });\n  const forwardStream = new TransformStream({\n    transform(chunk, controller) {\n      const chunkType = chunk.type;\n      switch (chunkType) {\n        case \"text-delta\":\n        case \"error\": {\n          controller.enqueue(chunk);\n          break;\n        }\n        case \"tool-call\": {\n          const toolName = chunk.toolName;\n          if (tools == null) {\n            toolResultsStreamController.enqueue({\n              type: \"error\",\n              error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchToolError({ toolName: chunk.toolName })\n            });\n            break;\n          }\n          const tool2 = tools[toolName];\n          if (tool2 == null) {\n            toolResultsStreamController.enqueue({\n              type: \"error\",\n              error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchToolError({\n                toolName: chunk.toolName,\n                availableTools: Object.keys(tools)\n              })\n            });\n            break;\n          }\n          try {\n            const toolCall = parseToolCall({\n              toolCall: chunk,\n              tools\n            });\n            controller.enqueue(toolCall);\n            if (tool2.execute != null) {\n              const toolExecutionId = generateId();\n              outstandingToolCalls.add(toolExecutionId);\n              tool2.execute(toolCall.args).then(\n                (result) => {\n                  toolResultsStreamController.enqueue({\n                    ...toolCall,\n                    type: \"tool-result\",\n                    result\n                  });\n                  outstandingToolCalls.delete(toolExecutionId);\n                  if (canClose && outstandingToolCalls.size === 0) {\n                    toolResultsStreamController.close();\n                  }\n                },\n                (error) => {\n                  toolResultsStreamController.enqueue({\n                    type: \"error\",\n                    error\n                  });\n                  outstandingToolCalls.delete(toolExecutionId);\n                  if (canClose && outstandingToolCalls.size === 0) {\n                    toolResultsStreamController.close();\n                  }\n                }\n              );\n            }\n          } catch (error) {\n            toolResultsStreamController.enqueue({\n              type: \"error\",\n              error\n            });\n          }\n          break;\n        }\n        case \"finish\": {\n          controller.enqueue({\n            type: \"finish\",\n            finishReason: chunk.finishReason,\n            logprobs: chunk.logprobs,\n            usage: calculateTokenUsage(chunk.usage)\n          });\n          break;\n        }\n        case \"tool-call-delta\": {\n          break;\n        }\n        default: {\n          const _exhaustiveCheck = chunkType;\n          throw new Error(`Unhandled chunk type: ${_exhaustiveCheck}`);\n        }\n      }\n    },\n    flush() {\n      canClose = true;\n      if (outstandingToolCalls.size === 0) {\n        toolResultsStreamController.close();\n      }\n    }\n  });\n  return new ReadableStream({\n    async start(controller) {\n      return Promise.all([\n        generatorStream.pipeThrough(forwardStream).pipeTo(\n          new WritableStream({\n            write(chunk) {\n              controller.enqueue(chunk);\n            },\n            close() {\n            }\n          })\n        ),\n        toolResultsStream.pipeTo(\n          new WritableStream({\n            write(chunk) {\n              controller.enqueue(chunk);\n            },\n            close() {\n              controller.close();\n            }\n          })\n        )\n      ]);\n    }\n  });\n}\n\n// core/generate-text/stream-text.ts\nasync function experimental_streamText({\n  model,\n  tools,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  ...settings\n}) {\n  const retry = retryWithExponentialBackoff({ maxRetries });\n  const validatedPrompt = getValidatedPrompt({ system, prompt, messages });\n  const { stream, warnings, rawResponse } = await retry(\n    () => model.doStream({\n      mode: {\n        type: \"regular\",\n        tools: tools == null ? void 0 : Object.entries(tools).map(([name, tool2]) => ({\n          type: \"function\",\n          name,\n          description: tool2.description,\n          parameters: convertZodToJSONSchema(tool2.parameters)\n        }))\n      },\n      ...prepareCallSettings(settings),\n      inputFormat: validatedPrompt.type,\n      prompt: convertToLanguageModelPrompt(validatedPrompt),\n      abortSignal\n    })\n  );\n  return new StreamTextResult({\n    stream: runToolsTransformation({\n      tools,\n      generatorStream: stream\n    }),\n    warnings,\n    rawResponse\n  });\n}\nvar StreamTextResult = class {\n  constructor({\n    stream,\n    warnings,\n    rawResponse\n  }) {\n    this.originalStream = stream;\n    this.warnings = warnings;\n    this.rawResponse = rawResponse;\n  }\n  /**\n  A text stream that returns only the generated text deltas. You can use it\n  as either an AsyncIterable or a ReadableStream. When an error occurs, the\n  stream will throw the error.\n     */\n  get textStream() {\n    return createAsyncIterableStream(this.originalStream, {\n      transform(chunk, controller) {\n        if (chunk.type === \"text-delta\") {\n          if (chunk.textDelta.length > 0) {\n            controller.enqueue(chunk.textDelta);\n          }\n        } else if (chunk.type === \"error\") {\n          throw chunk.error;\n        }\n      }\n    });\n  }\n  /**\n  A stream with all events, including text deltas, tool calls, tool results, and\n  errors.\n  You can use it as either an AsyncIterable or a ReadableStream. When an error occurs, the\n  stream will throw the error.\n     */\n  get fullStream() {\n    return createAsyncIterableStream(this.originalStream, {\n      transform(chunk, controller) {\n        if (chunk.type === \"text-delta\") {\n          if (chunk.textDelta.length > 0) {\n            controller.enqueue(chunk);\n          }\n        } else {\n          controller.enqueue(chunk);\n        }\n      }\n    });\n  }\n  /**\n  Converts the result to an `AIStream` object that is compatible with `StreamingTextResponse`.\n  It can be used with the `useChat` and `useCompletion` hooks.\n  \n  @param callbacks \n  Stream callbacks that will be called when the stream emits events.\n  \n  @returns an `AIStream` object.\n     */\n  toAIStream(callbacks) {\n    return this.textStream.pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n  }\n  /**\n  Writes stream data output to a Node.js response-like object.\n  It sets a `Content-Type` header to `text/plain; charset=utf-8` and \n  writes each stream data part as a separate chunk.\n  \n  @param response A Node.js response-like object (ServerResponse).\n  @param init Optional headers and status code.\n     */\n  pipeAIStreamToResponse(response, init) {\n    var _a;\n    response.writeHead((_a = init == null ? void 0 : init.status) != null ? _a : 200, {\n      \"Content-Type\": \"text/plain; charset=utf-8\",\n      ...init == null ? void 0 : init.headers\n    });\n    const reader = this.textStream.pipeThrough(createCallbacksTransformer(void 0)).pipeThrough(createStreamDataTransformer()).getReader();\n    const read = async () => {\n      try {\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done)\n            break;\n          response.write(value);\n        }\n      } catch (error) {\n        throw error;\n      } finally {\n        response.end();\n      }\n    };\n    read();\n  }\n  /**\n  Writes text delta output to a Node.js response-like object.\n  It sets a `Content-Type` header to `text/plain; charset=utf-8` and \n  writes each text delta as a separate chunk.\n  \n  @param response A Node.js response-like object (ServerResponse).\n  @param init Optional headers and status code.\n     */\n  pipeTextStreamToResponse(response, init) {\n    var _a;\n    response.writeHead((_a = init == null ? void 0 : init.status) != null ? _a : 200, {\n      \"Content-Type\": \"text/plain; charset=utf-8\",\n      ...init == null ? void 0 : init.headers\n    });\n    const reader = this.textStream.getReader();\n    const read = async () => {\n      const encoder = new TextEncoder();\n      try {\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done)\n            break;\n          response.write(encoder.encode(value));\n        }\n      } catch (error) {\n        throw error;\n      } finally {\n        response.end();\n      }\n    };\n    read();\n  }\n  /**\n  Converts the result to a streamed response object with a stream data part stream.\n  It can be used with the `useChat` and `useCompletion` hooks.\n  \n  @param init Optional headers.\n  \n  @return A response object.\n     */\n  toAIStreamResponse(init) {\n    return new StreamingTextResponse(this.toAIStream(), init);\n  }\n  /**\n  Creates a simple text stream response.\n  Each text delta is encoded as UTF-8 and sent as a separate chunk.\n  Non-text-delta events are ignored.\n  \n  @param init Optional headers and status code.\n     */\n  toTextStreamResponse(init) {\n    var _a;\n    const encoder = new TextEncoder();\n    return new Response(\n      this.textStream.pipeThrough(\n        new TransformStream({\n          transform(chunk, controller) {\n            controller.enqueue(encoder.encode(chunk));\n          }\n        })\n      ),\n      {\n        status: (_a = init == null ? void 0 : init.status) != null ? _a : 200,\n        headers: {\n          \"Content-Type\": \"text/plain; charset=utf-8\",\n          ...init == null ? void 0 : init.headers\n        }\n      }\n    );\n  }\n};\n\n// core/tool/tool.ts\nfunction tool(tool2) {\n  return tool2;\n}\n\n// core/types/errors.ts\n\n\n// shared/stream-parts.ts\nvar textStreamPart = {\n  code: \"0\",\n  name: \"text\",\n  parse: (value) => {\n    if (typeof value !== \"string\") {\n      throw new Error('\"text\" parts expect a string value.');\n    }\n    return { type: \"text\", value };\n  }\n};\nvar functionCallStreamPart = {\n  code: \"1\",\n  name: \"function_call\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"function_call\" in value) || typeof value.function_call !== \"object\" || value.function_call == null || !(\"name\" in value.function_call) || !(\"arguments\" in value.function_call) || typeof value.function_call.name !== \"string\" || typeof value.function_call.arguments !== \"string\") {\n      throw new Error(\n        '\"function_call\" parts expect an object with a \"function_call\" property.'\n      );\n    }\n    return {\n      type: \"function_call\",\n      value\n    };\n  }\n};\nvar dataStreamPart = {\n  code: \"2\",\n  name: \"data\",\n  parse: (value) => {\n    if (!Array.isArray(value)) {\n      throw new Error('\"data\" parts expect an array value.');\n    }\n    return { type: \"data\", value };\n  }\n};\nvar errorStreamPart = {\n  code: \"3\",\n  name: \"error\",\n  parse: (value) => {\n    if (typeof value !== \"string\") {\n      throw new Error('\"error\" parts expect a string value.');\n    }\n    return { type: \"error\", value };\n  }\n};\nvar assistantMessageStreamPart = {\n  code: \"4\",\n  name: \"assistant_message\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"id\" in value) || !(\"role\" in value) || !(\"content\" in value) || typeof value.id !== \"string\" || typeof value.role !== \"string\" || value.role !== \"assistant\" || !Array.isArray(value.content) || !value.content.every(\n      (item) => item != null && typeof item === \"object\" && \"type\" in item && item.type === \"text\" && \"text\" in item && item.text != null && typeof item.text === \"object\" && \"value\" in item.text && typeof item.text.value === \"string\"\n    )) {\n      throw new Error(\n        '\"assistant_message\" parts expect an object with an \"id\", \"role\", and \"content\" property.'\n      );\n    }\n    return {\n      type: \"assistant_message\",\n      value\n    };\n  }\n};\nvar assistantControlDataStreamPart = {\n  code: \"5\",\n  name: \"assistant_control_data\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"threadId\" in value) || !(\"messageId\" in value) || typeof value.threadId !== \"string\" || typeof value.messageId !== \"string\") {\n      throw new Error(\n        '\"assistant_control_data\" parts expect an object with a \"threadId\" and \"messageId\" property.'\n      );\n    }\n    return {\n      type: \"assistant_control_data\",\n      value: {\n        threadId: value.threadId,\n        messageId: value.messageId\n      }\n    };\n  }\n};\nvar dataMessageStreamPart = {\n  code: \"6\",\n  name: \"data_message\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"role\" in value) || !(\"data\" in value) || typeof value.role !== \"string\" || value.role !== \"data\") {\n      throw new Error(\n        '\"data_message\" parts expect an object with a \"role\" and \"data\" property.'\n      );\n    }\n    return {\n      type: \"data_message\",\n      value\n    };\n  }\n};\nvar toolCallStreamPart = {\n  code: \"7\",\n  name: \"tool_calls\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"tool_calls\" in value) || typeof value.tool_calls !== \"object\" || value.tool_calls == null || !Array.isArray(value.tool_calls) || value.tool_calls.some(\n      (tc) => tc == null || typeof tc !== \"object\" || !(\"id\" in tc) || typeof tc.id !== \"string\" || !(\"type\" in tc) || typeof tc.type !== \"string\" || !(\"function\" in tc) || tc.function == null || typeof tc.function !== \"object\" || !(\"arguments\" in tc.function) || typeof tc.function.name !== \"string\" || typeof tc.function.arguments !== \"string\"\n    )) {\n      throw new Error(\n        '\"tool_calls\" parts expect an object with a ToolCallPayload.'\n      );\n    }\n    return {\n      type: \"tool_calls\",\n      value\n    };\n  }\n};\nvar messageAnnotationsStreamPart = {\n  code: \"8\",\n  name: \"message_annotations\",\n  parse: (value) => {\n    if (!Array.isArray(value)) {\n      throw new Error('\"message_annotations\" parts expect an array value.');\n    }\n    return { type: \"message_annotations\", value };\n  }\n};\nvar streamParts = [\n  textStreamPart,\n  functionCallStreamPart,\n  dataStreamPart,\n  errorStreamPart,\n  assistantMessageStreamPart,\n  assistantControlDataStreamPart,\n  dataMessageStreamPart,\n  toolCallStreamPart,\n  messageAnnotationsStreamPart\n];\nvar streamPartsByCode = {\n  [textStreamPart.code]: textStreamPart,\n  [functionCallStreamPart.code]: functionCallStreamPart,\n  [dataStreamPart.code]: dataStreamPart,\n  [errorStreamPart.code]: errorStreamPart,\n  [assistantMessageStreamPart.code]: assistantMessageStreamPart,\n  [assistantControlDataStreamPart.code]: assistantControlDataStreamPart,\n  [dataMessageStreamPart.code]: dataMessageStreamPart,\n  [toolCallStreamPart.code]: toolCallStreamPart,\n  [messageAnnotationsStreamPart.code]: messageAnnotationsStreamPart\n};\nvar StreamStringPrefixes = {\n  [textStreamPart.name]: textStreamPart.code,\n  [functionCallStreamPart.name]: functionCallStreamPart.code,\n  [dataStreamPart.name]: dataStreamPart.code,\n  [errorStreamPart.name]: errorStreamPart.code,\n  [assistantMessageStreamPart.name]: assistantMessageStreamPart.code,\n  [assistantControlDataStreamPart.name]: assistantControlDataStreamPart.code,\n  [dataMessageStreamPart.name]: dataMessageStreamPart.code,\n  [toolCallStreamPart.name]: toolCallStreamPart.code,\n  [messageAnnotationsStreamPart.name]: messageAnnotationsStreamPart.code\n};\nvar validCodes = streamParts.map((part) => part.code);\nvar parseStreamPart = (line) => {\n  const firstSeparatorIndex = line.indexOf(\":\");\n  if (firstSeparatorIndex === -1) {\n    throw new Error(\"Failed to parse stream string. No separator found.\");\n  }\n  const prefix = line.slice(0, firstSeparatorIndex);\n  if (!validCodes.includes(prefix)) {\n    throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n  }\n  const code = prefix;\n  const textValue = line.slice(firstSeparatorIndex + 1);\n  const jsonValue = JSON.parse(textValue);\n  return streamPartsByCode[code].parse(jsonValue);\n};\nfunction formatStreamPart(type, value) {\n  const streamPart = streamParts.find((part) => part.name === type);\n  if (!streamPart) {\n    throw new Error(`Invalid stream part type: ${type}`);\n  }\n  return `${streamPart.code}:${JSON.stringify(value)}\n`;\n}\n\n// shared/read-data-stream.ts\nvar NEWLINE = \"\\n\".charCodeAt(0);\nfunction concatChunks(chunks, totalLength) {\n  const concatenatedChunks = new Uint8Array(totalLength);\n  let offset = 0;\n  for (const chunk of chunks) {\n    concatenatedChunks.set(chunk, offset);\n    offset += chunk.length;\n  }\n  chunks.length = 0;\n  return concatenatedChunks;\n}\nasync function* readDataStream(reader, {\n  isAborted\n} = {}) {\n  const decoder = new TextDecoder();\n  const chunks = [];\n  let totalLength = 0;\n  while (true) {\n    const { value } = await reader.read();\n    if (value) {\n      chunks.push(value);\n      totalLength += value.length;\n      if (value[value.length - 1] !== NEWLINE) {\n        continue;\n      }\n    }\n    if (chunks.length === 0) {\n      break;\n    }\n    const concatenatedChunks = concatChunks(chunks, totalLength);\n    totalLength = 0;\n    const streamParts2 = decoder.decode(concatenatedChunks, { stream: true }).split(\"\\n\").filter((line) => line !== \"\").map(parseStreamPart);\n    for (const streamPart of streamParts2) {\n      yield streamPart;\n    }\n    if (isAborted == null ? void 0 : isAborted()) {\n      reader.cancel();\n      break;\n    }\n  }\n}\n\n// shared/utils.ts\nfunction createChunkDecoder(complex) {\n  const decoder = new TextDecoder();\n  if (!complex) {\n    return function(chunk) {\n      if (!chunk)\n        return \"\";\n      return decoder.decode(chunk, { stream: true });\n    };\n  }\n  return function(chunk) {\n    const decoded = decoder.decode(chunk, { stream: true }).split(\"\\n\").filter((line) => line !== \"\");\n    return decoded.map(parseStreamPart).filter(Boolean);\n  };\n}\nvar isStreamStringEqualToType = (type, value) => value.startsWith(`${StreamStringPrefixes[type]}:`) && value.endsWith(\"\\n\");\n\n// streams/ai-stream.ts\n\nfunction createEventStreamTransformer(customParser) {\n  const textDecoder = new TextDecoder();\n  let eventSourceParser;\n  return new TransformStream({\n    async start(controller) {\n      eventSourceParser = (0,eventsource_parser__WEBPACK_IMPORTED_MODULE_5__.createParser)(\n        (event) => {\n          if (\"data\" in event && event.type === \"event\" && event.data === \"[DONE]\" || // Replicate doesn't send [DONE] but does send a 'done' event\n          // @see https://replicate.com/docs/streaming\n          event.event === \"done\") {\n            controller.terminate();\n            return;\n          }\n          if (\"data\" in event) {\n            const parsedMessage = customParser ? customParser(event.data, {\n              event: event.event\n            }) : event.data;\n            if (parsedMessage)\n              controller.enqueue(parsedMessage);\n          }\n        }\n      );\n    },\n    transform(chunk) {\n      eventSourceParser.feed(textDecoder.decode(chunk));\n    }\n  });\n}\nfunction createCallbacksTransformer(cb) {\n  const textEncoder = new TextEncoder();\n  let aggregatedResponse = \"\";\n  const callbacks = cb || {};\n  return new TransformStream({\n    async start() {\n      if (callbacks.onStart)\n        await callbacks.onStart();\n    },\n    async transform(message, controller) {\n      const content = typeof message === \"string\" ? message : message.content;\n      controller.enqueue(textEncoder.encode(content));\n      aggregatedResponse += content;\n      if (callbacks.onToken)\n        await callbacks.onToken(content);\n      if (callbacks.onText && typeof message === \"string\") {\n        await callbacks.onText(message);\n      }\n    },\n    async flush() {\n      const isOpenAICallbacks = isOfTypeOpenAIStreamCallbacks(callbacks);\n      if (callbacks.onCompletion) {\n        await callbacks.onCompletion(aggregatedResponse);\n      }\n      if (callbacks.onFinal && !isOpenAICallbacks) {\n        await callbacks.onFinal(aggregatedResponse);\n      }\n    }\n  });\n}\nfunction isOfTypeOpenAIStreamCallbacks(callbacks) {\n  return \"experimental_onFunctionCall\" in callbacks;\n}\nfunction trimStartOfStreamHelper() {\n  let isStreamStart = true;\n  return (text) => {\n    if (isStreamStart) {\n      text = text.trimStart();\n      if (text)\n        isStreamStart = false;\n    }\n    return text;\n  };\n}\nfunction AIStream(response, customParser, callbacks) {\n  if (!response.ok) {\n    if (response.body) {\n      const reader = response.body.getReader();\n      return new ReadableStream({\n        async start(controller) {\n          const { done, value } = await reader.read();\n          if (!done) {\n            const errorText = new TextDecoder().decode(value);\n            controller.error(new Error(`Response error: ${errorText}`));\n          }\n        }\n      });\n    } else {\n      return new ReadableStream({\n        start(controller) {\n          controller.error(new Error(\"Response error: No response body\"));\n        }\n      });\n    }\n  }\n  const responseBodyStream = response.body || createEmptyReadableStream();\n  return responseBodyStream.pipeThrough(createEventStreamTransformer(customParser)).pipeThrough(createCallbacksTransformer(callbacks));\n}\nfunction createEmptyReadableStream() {\n  return new ReadableStream({\n    start(controller) {\n      controller.close();\n    }\n  });\n}\nfunction readableFromAsyncIterable(iterable) {\n  let it = iterable[Symbol.asyncIterator]();\n  return new ReadableStream({\n    async pull(controller) {\n      const { done, value } = await it.next();\n      if (done)\n        controller.close();\n      else\n        controller.enqueue(value);\n    },\n    async cancel(reason) {\n      var _a;\n      await ((_a = it.return) == null ? void 0 : _a.call(it, reason));\n    }\n  });\n}\n\n// streams/stream-data.ts\nvar StreamData = class {\n  constructor() {\n    this.encoder = new TextEncoder();\n    this.controller = null;\n    // closing the stream is synchronous, but we want to return a promise\n    // in case we're doing async work\n    this.isClosedPromise = null;\n    this.isClosedPromiseResolver = void 0;\n    this.isClosed = false;\n    // array to store appended data\n    this.data = [];\n    this.messageAnnotations = [];\n    this.isClosedPromise = new Promise((resolve) => {\n      this.isClosedPromiseResolver = resolve;\n    });\n    const self = this;\n    this.stream = new TransformStream({\n      start: async (controller) => {\n        self.controller = controller;\n      },\n      transform: async (chunk, controller) => {\n        if (self.data.length > 0) {\n          const encodedData = self.encoder.encode(\n            formatStreamPart(\"data\", self.data)\n          );\n          self.data = [];\n          controller.enqueue(encodedData);\n        }\n        if (self.messageAnnotations.length) {\n          const encodedMessageAnnotations = self.encoder.encode(\n            formatStreamPart(\"message_annotations\", self.messageAnnotations)\n          );\n          self.messageAnnotations = [];\n          controller.enqueue(encodedMessageAnnotations);\n        }\n        controller.enqueue(chunk);\n      },\n      async flush(controller) {\n        const warningTimeout =  true ? setTimeout(() => {\n          console.warn(\n            \"The data stream is hanging. Did you forget to close it with `data.close()`?\"\n          );\n        }, 3e3) : 0;\n        await self.isClosedPromise;\n        if (warningTimeout !== null) {\n          clearTimeout(warningTimeout);\n        }\n        if (self.data.length) {\n          const encodedData = self.encoder.encode(\n            formatStreamPart(\"data\", self.data)\n          );\n          controller.enqueue(encodedData);\n        }\n        if (self.messageAnnotations.length) {\n          const encodedData = self.encoder.encode(\n            formatStreamPart(\"message_annotations\", self.messageAnnotations)\n          );\n          controller.enqueue(encodedData);\n        }\n      }\n    });\n  }\n  async close() {\n    var _a;\n    if (this.isClosed) {\n      throw new Error(\"Data Stream has already been closed.\");\n    }\n    if (!this.controller) {\n      throw new Error(\"Stream controller is not initialized.\");\n    }\n    (_a = this.isClosedPromiseResolver) == null ? void 0 : _a.call(this);\n    this.isClosed = true;\n  }\n  append(value) {\n    if (this.isClosed) {\n      throw new Error(\"Data Stream has already been closed.\");\n    }\n    this.data.push(value);\n  }\n  appendMessageAnnotation(value) {\n    if (this.isClosed) {\n      throw new Error(\"Data Stream has already been closed.\");\n    }\n    this.messageAnnotations.push(value);\n  }\n};\nfunction createStreamDataTransformer() {\n  const encoder = new TextEncoder();\n  const decoder = new TextDecoder();\n  return new TransformStream({\n    transform: async (chunk, controller) => {\n      const message = decoder.decode(chunk);\n      controller.enqueue(encoder.encode(formatStreamPart(\"text\", message)));\n    }\n  });\n}\nvar experimental_StreamData = class extends StreamData {\n};\n\n// streams/anthropic-stream.ts\nfunction parseAnthropicStream() {\n  let previous = \"\";\n  return (data) => {\n    const json = JSON.parse(data);\n    if (\"error\" in json) {\n      throw new Error(`${json.error.type}: ${json.error.message}`);\n    }\n    if (!(\"completion\" in json)) {\n      return;\n    }\n    const text = json.completion;\n    if (!previous || text.length > previous.length && text.startsWith(previous)) {\n      const delta = text.slice(previous.length);\n      previous = text;\n      return delta;\n    }\n    return text;\n  };\n}\nasync function* streamable(stream) {\n  for await (const chunk of stream) {\n    if (\"completion\" in chunk) {\n      const text = chunk.completion;\n      if (text)\n        yield text;\n    } else if (\"delta\" in chunk) {\n      const { delta } = chunk;\n      if (\"text\" in delta) {\n        const text = delta.text;\n        if (text)\n          yield text;\n      }\n    }\n  }\n}\nfunction AnthropicStream(res, cb) {\n  if (Symbol.asyncIterator in res) {\n    return readableFromAsyncIterable(streamable(res)).pipeThrough(createCallbacksTransformer(cb)).pipeThrough(createStreamDataTransformer());\n  } else {\n    return AIStream(res, parseAnthropicStream(), cb).pipeThrough(\n      createStreamDataTransformer()\n    );\n  }\n}\n\n// streams/assistant-response.ts\nfunction AssistantResponse({ threadId, messageId }, process2) {\n  const stream = new ReadableStream({\n    async start(controller) {\n      var _a;\n      const textEncoder = new TextEncoder();\n      const sendMessage = (message) => {\n        controller.enqueue(\n          textEncoder.encode(formatStreamPart(\"assistant_message\", message))\n        );\n      };\n      const sendDataMessage = (message) => {\n        controller.enqueue(\n          textEncoder.encode(formatStreamPart(\"data_message\", message))\n        );\n      };\n      const sendError = (errorMessage) => {\n        controller.enqueue(\n          textEncoder.encode(formatStreamPart(\"error\", errorMessage))\n        );\n      };\n      const forwardStream = async (stream2) => {\n        var _a2, _b;\n        let result = void 0;\n        for await (const value of stream2) {\n          switch (value.event) {\n            case \"thread.message.created\": {\n              controller.enqueue(\n                textEncoder.encode(\n                  formatStreamPart(\"assistant_message\", {\n                    id: value.data.id,\n                    role: \"assistant\",\n                    content: [{ type: \"text\", text: { value: \"\" } }]\n                  })\n                )\n              );\n              break;\n            }\n            case \"thread.message.delta\": {\n              const content = (_a2 = value.data.delta.content) == null ? void 0 : _a2[0];\n              if ((content == null ? void 0 : content.type) === \"text\" && ((_b = content.text) == null ? void 0 : _b.value) != null) {\n                controller.enqueue(\n                  textEncoder.encode(\n                    formatStreamPart(\"text\", content.text.value)\n                  )\n                );\n              }\n              break;\n            }\n            case \"thread.run.completed\":\n            case \"thread.run.requires_action\": {\n              result = value.data;\n              break;\n            }\n          }\n        }\n        return result;\n      };\n      controller.enqueue(\n        textEncoder.encode(\n          formatStreamPart(\"assistant_control_data\", {\n            threadId,\n            messageId\n          })\n        )\n      );\n      try {\n        await process2({\n          threadId,\n          messageId,\n          sendMessage,\n          sendDataMessage,\n          forwardStream\n        });\n      } catch (error) {\n        sendError((_a = error.message) != null ? _a : `${error}`);\n      } finally {\n        controller.close();\n      }\n    },\n    pull(controller) {\n    },\n    cancel() {\n    }\n  });\n  return new Response(stream, {\n    status: 200,\n    headers: {\n      \"Content-Type\": \"text/plain; charset=utf-8\"\n    }\n  });\n}\nvar experimental_AssistantResponse = AssistantResponse;\n\n// streams/aws-bedrock-stream.ts\nasync function* asDeltaIterable(response, extractTextDeltaFromChunk) {\n  var _a, _b;\n  const decoder = new TextDecoder();\n  for await (const chunk of (_a = response.body) != null ? _a : []) {\n    const bytes = (_b = chunk.chunk) == null ? void 0 : _b.bytes;\n    if (bytes != null) {\n      const chunkText = decoder.decode(bytes);\n      const chunkJSON = JSON.parse(chunkText);\n      const delta = extractTextDeltaFromChunk(chunkJSON);\n      if (delta != null) {\n        yield delta;\n      }\n    }\n  }\n}\nfunction AWSBedrockAnthropicMessagesStream(response, callbacks) {\n  return AWSBedrockStream(response, callbacks, (chunk) => {\n    var _a;\n    return (_a = chunk.delta) == null ? void 0 : _a.text;\n  });\n}\nfunction AWSBedrockAnthropicStream(response, callbacks) {\n  return AWSBedrockStream(response, callbacks, (chunk) => chunk.completion);\n}\nfunction AWSBedrockCohereStream(response, callbacks) {\n  return AWSBedrockStream(response, callbacks, (chunk) => chunk == null ? void 0 : chunk.text);\n}\nfunction AWSBedrockLlama2Stream(response, callbacks) {\n  return AWSBedrockStream(response, callbacks, (chunk) => chunk.generation);\n}\nfunction AWSBedrockStream(response, callbacks, extractTextDeltaFromChunk) {\n  return readableFromAsyncIterable(\n    asDeltaIterable(response, extractTextDeltaFromChunk)\n  ).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\n\n// streams/cohere-stream.ts\nvar utf8Decoder = new TextDecoder(\"utf-8\");\nasync function processLines(lines, controller) {\n  for (const line of lines) {\n    const { text, is_finished } = JSON.parse(line);\n    if (!is_finished) {\n      controller.enqueue(text);\n    }\n  }\n}\nasync function readAndProcessLines(reader, controller) {\n  let segment = \"\";\n  while (true) {\n    const { value: chunk, done } = await reader.read();\n    if (done) {\n      break;\n    }\n    segment += utf8Decoder.decode(chunk, { stream: true });\n    const linesArray = segment.split(/\\r\\n|\\n|\\r/g);\n    segment = linesArray.pop() || \"\";\n    await processLines(linesArray, controller);\n  }\n  if (segment) {\n    const linesArray = [segment];\n    await processLines(linesArray, controller);\n  }\n  controller.close();\n}\nfunction createParser2(res) {\n  var _a;\n  const reader = (_a = res.body) == null ? void 0 : _a.getReader();\n  return new ReadableStream({\n    async start(controller) {\n      if (!reader) {\n        controller.close();\n        return;\n      }\n      await readAndProcessLines(reader, controller);\n    }\n  });\n}\nasync function* streamable2(stream) {\n  for await (const chunk of stream) {\n    if (chunk.eventType === \"text-generation\") {\n      const text = chunk.text;\n      if (text)\n        yield text;\n    }\n  }\n}\nfunction CohereStream(reader, callbacks) {\n  if (Symbol.asyncIterator in reader) {\n    return readableFromAsyncIterable(streamable2(reader)).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n  } else {\n    return createParser2(reader).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n  }\n}\n\n// streams/google-generative-ai-stream.ts\nasync function* streamable3(response) {\n  var _a, _b, _c;\n  for await (const chunk of response.stream) {\n    const parts = (_c = (_b = (_a = chunk.candidates) == null ? void 0 : _a[0]) == null ? void 0 : _b.content) == null ? void 0 : _c.parts;\n    if (parts === void 0) {\n      continue;\n    }\n    const firstPart = parts[0];\n    if (typeof firstPart.text === \"string\") {\n      yield firstPart.text;\n    }\n  }\n}\nfunction GoogleGenerativeAIStream(response, cb) {\n  return readableFromAsyncIterable(streamable3(response)).pipeThrough(createCallbacksTransformer(cb)).pipeThrough(createStreamDataTransformer());\n}\n\n// streams/huggingface-stream.ts\nfunction createParser3(res) {\n  const trimStartOfStream = trimStartOfStreamHelper();\n  return new ReadableStream({\n    async pull(controller) {\n      var _a, _b;\n      const { value, done } = await res.next();\n      if (done) {\n        controller.close();\n        return;\n      }\n      const text = trimStartOfStream((_b = (_a = value.token) == null ? void 0 : _a.text) != null ? _b : \"\");\n      if (!text)\n        return;\n      if (value.generated_text != null && value.generated_text.length > 0) {\n        return;\n      }\n      if (text === \"</s>\" || text === \"<|endoftext|>\" || text === \"<|end|>\") {\n        return;\n      }\n      controller.enqueue(text);\n    }\n  });\n}\nfunction HuggingFaceStream(res, callbacks) {\n  return createParser3(res).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\n\n// streams/inkeep-stream.ts\nfunction InkeepStream(res, callbacks) {\n  if (!res.body) {\n    throw new Error(\"Response body is null\");\n  }\n  let chat_session_id = \"\";\n  let records_cited;\n  const inkeepEventParser = (data, options) => {\n    var _a, _b;\n    const { event } = options;\n    if (event === \"records_cited\") {\n      records_cited = JSON.parse(data);\n      (_a = callbacks == null ? void 0 : callbacks.onRecordsCited) == null ? void 0 : _a.call(callbacks, records_cited);\n    }\n    if (event === \"message_chunk\") {\n      const inkeepMessageChunk = JSON.parse(data);\n      chat_session_id = (_b = inkeepMessageChunk.chat_session_id) != null ? _b : chat_session_id;\n      return inkeepMessageChunk.content_chunk;\n    }\n    return;\n  };\n  let { onRecordsCited, ...passThroughCallbacks } = callbacks || {};\n  passThroughCallbacks = {\n    ...passThroughCallbacks,\n    onFinal: (completion) => {\n      var _a;\n      const inkeepOnFinalMetadata = {\n        chat_session_id,\n        records_cited\n      };\n      (_a = callbacks == null ? void 0 : callbacks.onFinal) == null ? void 0 : _a.call(callbacks, completion, inkeepOnFinalMetadata);\n    }\n  };\n  return AIStream(res, inkeepEventParser, passThroughCallbacks).pipeThrough(\n    createStreamDataTransformer()\n  );\n}\n\n// streams/langchain-stream.ts\nfunction LangChainStream(callbacks) {\n  const stream = new TransformStream();\n  const writer = stream.writable.getWriter();\n  const runs = /* @__PURE__ */ new Set();\n  const handleError = async (e, runId) => {\n    runs.delete(runId);\n    await writer.ready;\n    await writer.abort(e);\n  };\n  const handleStart = async (runId) => {\n    runs.add(runId);\n  };\n  const handleEnd = async (runId) => {\n    runs.delete(runId);\n    if (runs.size === 0) {\n      await writer.ready;\n      await writer.close();\n    }\n  };\n  return {\n    stream: stream.readable.pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer()),\n    writer,\n    handlers: {\n      handleLLMNewToken: async (token) => {\n        await writer.ready;\n        await writer.write(token);\n      },\n      handleLLMStart: async (_llm, _prompts, runId) => {\n        handleStart(runId);\n      },\n      handleLLMEnd: async (_output, runId) => {\n        await handleEnd(runId);\n      },\n      handleLLMError: async (e, runId) => {\n        await handleError(e, runId);\n      },\n      handleChainStart: async (_chain, _inputs, runId) => {\n        handleStart(runId);\n      },\n      handleChainEnd: async (_outputs, runId) => {\n        await handleEnd(runId);\n      },\n      handleChainError: async (e, runId) => {\n        await handleError(e, runId);\n      },\n      handleToolStart: async (_tool, _input, runId) => {\n        handleStart(runId);\n      },\n      handleToolEnd: async (_output, runId) => {\n        await handleEnd(runId);\n      },\n      handleToolError: async (e, runId) => {\n        await handleError(e, runId);\n      }\n    }\n  };\n}\n\n// streams/mistral-stream.ts\nasync function* streamable4(stream) {\n  var _a, _b;\n  for await (const chunk of stream) {\n    const content = (_b = (_a = chunk.choices[0]) == null ? void 0 : _a.delta) == null ? void 0 : _b.content;\n    if (content === void 0 || content === \"\") {\n      continue;\n    }\n    yield content;\n  }\n}\nfunction MistralStream(response, callbacks) {\n  const stream = readableFromAsyncIterable(streamable4(response));\n  return stream.pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\n\n// streams/openai-stream.ts\nfunction parseOpenAIStream() {\n  const extract = chunkToText();\n  return (data) => extract(JSON.parse(data));\n}\nasync function* streamable5(stream) {\n  const extract = chunkToText();\n  for await (let chunk of stream) {\n    if (\"promptFilterResults\" in chunk) {\n      chunk = {\n        id: chunk.id,\n        created: chunk.created.getDate(),\n        object: chunk.object,\n        // not exposed by Azure API\n        model: chunk.model,\n        // not exposed by Azure API\n        choices: chunk.choices.map((choice) => {\n          var _a, _b, _c, _d, _e, _f, _g;\n          return {\n            delta: {\n              content: (_a = choice.delta) == null ? void 0 : _a.content,\n              function_call: (_b = choice.delta) == null ? void 0 : _b.functionCall,\n              role: (_c = choice.delta) == null ? void 0 : _c.role,\n              tool_calls: ((_e = (_d = choice.delta) == null ? void 0 : _d.toolCalls) == null ? void 0 : _e.length) ? (_g = (_f = choice.delta) == null ? void 0 : _f.toolCalls) == null ? void 0 : _g.map((toolCall, index) => ({\n                index,\n                id: toolCall.id,\n                function: toolCall.function,\n                type: toolCall.type\n              })) : void 0\n            },\n            finish_reason: choice.finishReason,\n            index: choice.index\n          };\n        })\n      };\n    }\n    const text = extract(chunk);\n    if (text)\n      yield text;\n  }\n}\nfunction chunkToText() {\n  const trimStartOfStream = trimStartOfStreamHelper();\n  let isFunctionStreamingIn;\n  return (json) => {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;\n    if (isChatCompletionChunk(json)) {\n      const delta = (_a = json.choices[0]) == null ? void 0 : _a.delta;\n      if ((_b = delta.function_call) == null ? void 0 : _b.name) {\n        isFunctionStreamingIn = true;\n        return {\n          isText: false,\n          content: `{\"function_call\": {\"name\": \"${delta.function_call.name}\", \"arguments\": \"`\n        };\n      } else if ((_e = (_d = (_c = delta.tool_calls) == null ? void 0 : _c[0]) == null ? void 0 : _d.function) == null ? void 0 : _e.name) {\n        isFunctionStreamingIn = true;\n        const toolCall = delta.tool_calls[0];\n        if (toolCall.index === 0) {\n          return {\n            isText: false,\n            content: `{\"tool_calls\":[ {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_f = toolCall.function) == null ? void 0 : _f.name}\", \"arguments\": \"`\n          };\n        } else {\n          return {\n            isText: false,\n            content: `\"}}, {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_g = toolCall.function) == null ? void 0 : _g.name}\", \"arguments\": \"`\n          };\n        }\n      } else if ((_h = delta.function_call) == null ? void 0 : _h.arguments) {\n        return {\n          isText: false,\n          content: cleanupArguments((_i = delta.function_call) == null ? void 0 : _i.arguments)\n        };\n      } else if ((_l = (_k = (_j = delta.tool_calls) == null ? void 0 : _j[0]) == null ? void 0 : _k.function) == null ? void 0 : _l.arguments) {\n        return {\n          isText: false,\n          content: cleanupArguments((_o = (_n = (_m = delta.tool_calls) == null ? void 0 : _m[0]) == null ? void 0 : _n.function) == null ? void 0 : _o.arguments)\n        };\n      } else if (isFunctionStreamingIn && (((_p = json.choices[0]) == null ? void 0 : _p.finish_reason) === \"function_call\" || ((_q = json.choices[0]) == null ? void 0 : _q.finish_reason) === \"stop\")) {\n        isFunctionStreamingIn = false;\n        return {\n          isText: false,\n          content: '\"}}'\n        };\n      } else if (isFunctionStreamingIn && ((_r = json.choices[0]) == null ? void 0 : _r.finish_reason) === \"tool_calls\") {\n        isFunctionStreamingIn = false;\n        return {\n          isText: false,\n          content: '\"}}]}'\n        };\n      }\n    }\n    const text = trimStartOfStream(\n      isChatCompletionChunk(json) && json.choices[0].delta.content ? json.choices[0].delta.content : isCompletion(json) ? json.choices[0].text : \"\"\n    );\n    return text;\n  };\n  function cleanupArguments(argumentChunk) {\n    let escapedPartialJson = argumentChunk.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\//g, \"\\\\/\").replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/\\t/g, \"\\\\t\").replace(/\\f/g, \"\\\\f\");\n    return `${escapedPartialJson}`;\n  }\n}\nvar __internal__OpenAIFnMessagesSymbol = Symbol(\n  \"internal_openai_fn_messages\"\n);\nfunction isChatCompletionChunk(data) {\n  return \"choices\" in data && data.choices && data.choices[0] && \"delta\" in data.choices[0];\n}\nfunction isCompletion(data) {\n  return \"choices\" in data && data.choices && data.choices[0] && \"text\" in data.choices[0];\n}\nfunction OpenAIStream(res, callbacks) {\n  const cb = callbacks;\n  let stream;\n  if (Symbol.asyncIterator in res) {\n    stream = readableFromAsyncIterable(streamable5(res)).pipeThrough(\n      createCallbacksTransformer(\n        (cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n          ...cb,\n          onFinal: void 0\n        } : {\n          ...cb\n        }\n      )\n    );\n  } else {\n    stream = AIStream(\n      res,\n      parseOpenAIStream(),\n      (cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n        ...cb,\n        onFinal: void 0\n      } : {\n        ...cb\n      }\n    );\n  }\n  if (cb && (cb.experimental_onFunctionCall || cb.experimental_onToolCall)) {\n    const functionCallTransformer = createFunctionCallTransformer(cb);\n    return stream.pipeThrough(functionCallTransformer);\n  } else {\n    return stream.pipeThrough(createStreamDataTransformer());\n  }\n}\nfunction createFunctionCallTransformer(callbacks) {\n  const textEncoder = new TextEncoder();\n  let isFirstChunk = true;\n  let aggregatedResponse = \"\";\n  let aggregatedFinalCompletionResponse = \"\";\n  let isFunctionStreamingIn = false;\n  let functionCallMessages = callbacks[__internal__OpenAIFnMessagesSymbol] || [];\n  const decode = createChunkDecoder();\n  return new TransformStream({\n    async transform(chunk, controller) {\n      const message = decode(chunk);\n      aggregatedFinalCompletionResponse += message;\n      const shouldHandleAsFunction = isFirstChunk && (message.startsWith('{\"function_call\":') || message.startsWith('{\"tool_calls\":'));\n      if (shouldHandleAsFunction) {\n        isFunctionStreamingIn = true;\n        aggregatedResponse += message;\n        isFirstChunk = false;\n        return;\n      }\n      if (!isFunctionStreamingIn) {\n        controller.enqueue(\n          textEncoder.encode(formatStreamPart(\"text\", message))\n        );\n        return;\n      } else {\n        aggregatedResponse += message;\n      }\n    },\n    async flush(controller) {\n      try {\n        if (!isFirstChunk && isFunctionStreamingIn && (callbacks.experimental_onFunctionCall || callbacks.experimental_onToolCall)) {\n          isFunctionStreamingIn = false;\n          const payload = JSON.parse(aggregatedResponse);\n          let newFunctionCallMessages = [\n            ...functionCallMessages\n          ];\n          let functionResponse = void 0;\n          if (callbacks.experimental_onFunctionCall) {\n            if (payload.function_call === void 0) {\n              console.warn(\n                \"experimental_onFunctionCall should not be defined when using tools\"\n              );\n            }\n            const argumentsPayload = JSON.parse(\n              payload.function_call.arguments\n            );\n            functionResponse = await callbacks.experimental_onFunctionCall(\n              {\n                name: payload.function_call.name,\n                arguments: argumentsPayload\n              },\n              (result) => {\n                newFunctionCallMessages = [\n                  ...functionCallMessages,\n                  {\n                    role: \"assistant\",\n                    content: \"\",\n                    function_call: payload.function_call\n                  },\n                  {\n                    role: \"function\",\n                    name: payload.function_call.name,\n                    content: JSON.stringify(result)\n                  }\n                ];\n                return newFunctionCallMessages;\n              }\n            );\n          }\n          if (callbacks.experimental_onToolCall) {\n            const toolCalls = {\n              tools: []\n            };\n            for (const tool2 of payload.tool_calls) {\n              toolCalls.tools.push({\n                id: tool2.id,\n                type: \"function\",\n                func: {\n                  name: tool2.function.name,\n                  arguments: JSON.parse(tool2.function.arguments)\n                }\n              });\n            }\n            let responseIndex = 0;\n            try {\n              functionResponse = await callbacks.experimental_onToolCall(\n                toolCalls,\n                (result) => {\n                  if (result) {\n                    const { tool_call_id, function_name, tool_call_result } = result;\n                    newFunctionCallMessages = [\n                      ...newFunctionCallMessages,\n                      // Only append the assistant message if it's the first response\n                      ...responseIndex === 0 ? [\n                        {\n                          role: \"assistant\",\n                          content: \"\",\n                          tool_calls: payload.tool_calls.map(\n                            (tc) => ({\n                              id: tc.id,\n                              type: \"function\",\n                              function: {\n                                name: tc.function.name,\n                                // we send the arguments an object to the user, but as the API expects a string, we need to stringify it\n                                arguments: JSON.stringify(\n                                  tc.function.arguments\n                                )\n                              }\n                            })\n                          )\n                        }\n                      ] : [],\n                      // Append the function call result message\n                      {\n                        role: \"tool\",\n                        tool_call_id,\n                        name: function_name,\n                        content: JSON.stringify(tool_call_result)\n                      }\n                    ];\n                    responseIndex++;\n                  }\n                  return newFunctionCallMessages;\n                }\n              );\n            } catch (e) {\n              console.error(\"Error calling experimental_onToolCall:\", e);\n            }\n          }\n          if (!functionResponse) {\n            controller.enqueue(\n              textEncoder.encode(\n                formatStreamPart(\n                  payload.function_call ? \"function_call\" : \"tool_calls\",\n                  // parse to prevent double-encoding:\n                  JSON.parse(aggregatedResponse)\n                )\n              )\n            );\n            return;\n          } else if (typeof functionResponse === \"string\") {\n            controller.enqueue(\n              textEncoder.encode(formatStreamPart(\"text\", functionResponse))\n            );\n            aggregatedFinalCompletionResponse = functionResponse;\n            return;\n          }\n          const filteredCallbacks = {\n            ...callbacks,\n            onStart: void 0\n          };\n          callbacks.onFinal = void 0;\n          const openAIStream = OpenAIStream(functionResponse, {\n            ...filteredCallbacks,\n            [__internal__OpenAIFnMessagesSymbol]: newFunctionCallMessages\n          });\n          const reader = openAIStream.getReader();\n          while (true) {\n            const { done, value } = await reader.read();\n            if (done) {\n              break;\n            }\n            controller.enqueue(value);\n          }\n        }\n      } finally {\n        if (callbacks.onFinal && aggregatedFinalCompletionResponse) {\n          await callbacks.onFinal(aggregatedFinalCompletionResponse);\n        }\n      }\n    }\n  });\n}\n\n// streams/replicate-stream.ts\nasync function ReplicateStream(res, cb, options) {\n  var _a;\n  const url = (_a = res.urls) == null ? void 0 : _a.stream;\n  if (!url) {\n    if (res.error)\n      throw new Error(res.error);\n    else\n      throw new Error(\"Missing stream URL in Replicate response\");\n  }\n  const eventStream = await fetch(url, {\n    method: \"GET\",\n    headers: {\n      Accept: \"text/event-stream\",\n      ...options == null ? void 0 : options.headers\n    }\n  });\n  return AIStream(eventStream, void 0, cb).pipeThrough(\n    createStreamDataTransformer()\n  );\n}\n\n// shared/parse-complex-response.ts\nfunction assignAnnotationsToMessage(message, annotations) {\n  if (!message || !annotations || !annotations.length)\n    return message;\n  return { ...message, annotations: [...annotations] };\n}\nasync function parseComplexResponse({\n  reader,\n  abortControllerRef,\n  update,\n  onFinish,\n  generateId: generateId2 = generateId,\n  getCurrentDate = () => /* @__PURE__ */ new Date()\n}) {\n  const createdAt = getCurrentDate();\n  const prefixMap = {\n    data: []\n  };\n  let message_annotations = void 0;\n  for await (const { type, value } of readDataStream(reader, {\n    isAborted: () => (abortControllerRef == null ? void 0 : abortControllerRef.current) === null\n  })) {\n    if (type === \"text\") {\n      if (prefixMap[\"text\"]) {\n        prefixMap[\"text\"] = {\n          ...prefixMap[\"text\"],\n          content: (prefixMap[\"text\"].content || \"\") + value\n        };\n      } else {\n        prefixMap[\"text\"] = {\n          id: generateId2(),\n          role: \"assistant\",\n          content: value,\n          createdAt\n        };\n      }\n    }\n    let functionCallMessage = null;\n    if (type === \"function_call\") {\n      prefixMap[\"function_call\"] = {\n        id: generateId2(),\n        role: \"assistant\",\n        content: \"\",\n        function_call: value.function_call,\n        name: value.function_call.name,\n        createdAt\n      };\n      functionCallMessage = prefixMap[\"function_call\"];\n    }\n    let toolCallMessage = null;\n    if (type === \"tool_calls\") {\n      prefixMap[\"tool_calls\"] = {\n        id: generateId2(),\n        role: \"assistant\",\n        content: \"\",\n        tool_calls: value.tool_calls,\n        createdAt\n      };\n      toolCallMessage = prefixMap[\"tool_calls\"];\n    }\n    if (type === \"data\") {\n      prefixMap[\"data\"].push(...value);\n    }\n    let responseMessage = prefixMap[\"text\"];\n    if (type === \"message_annotations\") {\n      if (!message_annotations) {\n        message_annotations = [...value];\n      } else {\n        message_annotations.push(...value);\n      }\n      functionCallMessage = assignAnnotationsToMessage(\n        prefixMap[\"function_call\"],\n        message_annotations\n      );\n      toolCallMessage = assignAnnotationsToMessage(\n        prefixMap[\"tool_calls\"],\n        message_annotations\n      );\n      responseMessage = assignAnnotationsToMessage(\n        prefixMap[\"text\"],\n        message_annotations\n      );\n    }\n    if (message_annotations == null ? void 0 : message_annotations.length) {\n      const messagePrefixKeys = [\n        \"text\",\n        \"function_call\",\n        \"tool_calls\"\n      ];\n      messagePrefixKeys.forEach((key) => {\n        if (prefixMap[key]) {\n          prefixMap[key].annotations = [...message_annotations];\n        }\n      });\n    }\n    const merged = [functionCallMessage, toolCallMessage, responseMessage].filter(Boolean).map((message) => ({\n      ...assignAnnotationsToMessage(message, message_annotations)\n    }));\n    update(merged, [...prefixMap[\"data\"]]);\n  }\n  onFinish == null ? void 0 : onFinish(prefixMap);\n  return {\n    messages: [\n      prefixMap.text,\n      prefixMap.function_call,\n      prefixMap.tool_calls\n    ].filter(Boolean),\n    data: prefixMap.data\n  };\n}\n\n// streams/streaming-react-response.ts\nvar experimental_StreamingReactResponse = class {\n  constructor(res, options) {\n    var _a, _b;\n    let resolveFunc = () => {\n    };\n    let next = new Promise((resolve) => {\n      resolveFunc = resolve;\n    });\n    const processedStream = (options == null ? void 0 : options.data) != null ? res.pipeThrough((_a = options == null ? void 0 : options.data) == null ? void 0 : _a.stream) : res;\n    let lastPayload = void 0;\n    parseComplexResponse({\n      reader: processedStream.getReader(),\n      update: (merged, data) => {\n        var _a2, _b2, _c;\n        const content = (_b2 = (_a2 = merged[0]) == null ? void 0 : _a2.content) != null ? _b2 : \"\";\n        const ui = ((_c = options == null ? void 0 : options.ui) == null ? void 0 : _c.call(options, { content, data })) || content;\n        const payload = { ui, content };\n        const resolvePrevious = resolveFunc;\n        const nextRow = new Promise((resolve) => {\n          resolveFunc = resolve;\n        });\n        resolvePrevious({\n          next: nextRow,\n          ...payload\n        });\n        lastPayload = payload;\n      },\n      generateId: (_b = options == null ? void 0 : options.generateId) != null ? _b : generateId,\n      onFinish: () => {\n        if (lastPayload !== void 0) {\n          resolveFunc({\n            next: null,\n            ...lastPayload\n          });\n        }\n      }\n    });\n    return next;\n  }\n};\n\n// streams/streaming-text-response.ts\nvar StreamingTextResponse = class extends Response {\n  constructor(res, init, data) {\n    let processedStream = res;\n    if (data) {\n      processedStream = res.pipeThrough(data.stream);\n    }\n    super(processedStream, {\n      ...init,\n      status: 200,\n      headers: {\n        \"Content-Type\": \"text/plain; charset=utf-8\",\n        ...init == null ? void 0 : init.headers\n      }\n    });\n  }\n};\nfunction streamToResponse(res, response, init) {\n  response.writeHead((init == null ? void 0 : init.status) || 200, {\n    \"Content-Type\": \"text/plain; charset=utf-8\",\n    ...init == null ? void 0 : init.headers\n  });\n  const reader = res.getReader();\n  function read() {\n    reader.read().then(({ done, value }) => {\n      if (done) {\n        response.end();\n        return;\n      }\n      response.write(value);\n      read();\n    });\n  }\n  read();\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWkvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQzBEO0FBQ0g7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUksNENBQTRDO0FBQ2hELElBQUksaURBQWlEO0FBQ3JELElBQUksMkNBQTJDO0FBQy9DLElBQUk7QUFDSjtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzJEO0FBSTNCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlGQUF5QjtBQUNwQztBQUNBLFNBQVMsaUZBQXlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUZBQXlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxRUFBdUIsR0FBRyxTQUFTO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHdDQUF3QztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1DQUFtQztBQUN2RCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIscUNBQXFDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHFDQUFxQztBQUNuRTtBQUNB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LG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUMyQzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxPQUFPO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxLQUFLO0FBQ3REO0FBQ0EsWUFBWSxnQkFBZ0IsR0FBRztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUk7QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsY0FBYztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsY0FBYztBQUNuRDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsY0FBYztBQUMxRDtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsMkJBQTJCOztBQUVoRztBQUc0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdFQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQSwwREFBMEQsVUFBVTtBQUNwRTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxjQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLCtCQUErQixLQUFzQztBQUNyRTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFNBQVMsQ0FBSTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdCQUFnQixJQUFJLG1CQUFtQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLHFCQUFxQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msc0JBQXNCLGFBQWE7QUFDbkUsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUix5REFBeUQsTUFBTTtBQUMvRCxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxjQUFjO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwQ0FBMEM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUcsZUFBZTtBQUN0SCwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwwQkFBMEIsYUFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBK0RFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1haS1ib3QvLi9ub2RlX21vZHVsZXMvYWkvZGlzdC9pbmRleC5tanM/YjQ1MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBjb3JlL2dlbmVyYXRlLW9iamVjdC9nZW5lcmF0ZS1vYmplY3QudHNcbmltcG9ydCB7IE5vT2JqZWN0R2VuZXJhdGVkRXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuaW1wb3J0IHsgc2FmZVBhcnNlSlNPTiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIGNvcmUvZ2VuZXJhdGUtdGV4dC90b2tlbi11c2FnZS50c1xuZnVuY3Rpb24gY2FsY3VsYXRlVG9rZW5Vc2FnZSh1c2FnZSkge1xuICByZXR1cm4ge1xuICAgIHByb21wdFRva2VuczogdXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgIGNvbXBsZXRpb25Ub2tlbnM6IHVzYWdlLmNvbXBsZXRpb25Ub2tlbnMsXG4gICAgdG90YWxUb2tlbnM6IHVzYWdlLnByb21wdFRva2VucyArIHVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcbiAgfTtcbn1cblxuLy8gY29yZS91dGlsL2RldGVjdC1pbWFnZS1taW1ldHlwZS50c1xudmFyIG1pbWVUeXBlU2lnbmF0dXJlcyA9IFtcbiAgeyBtaW1lVHlwZTogXCJpbWFnZS9naWZcIiwgYnl0ZXM6IFs3MSwgNzMsIDcwXSB9LFxuICB7IG1pbWVUeXBlOiBcImltYWdlL3BuZ1wiLCBieXRlczogWzEzNywgODAsIDc4LCA3MV0gfSxcbiAgeyBtaW1lVHlwZTogXCJpbWFnZS9qcGVnXCIsIGJ5dGVzOiBbMjU1LCAyMTZdIH0sXG4gIHsgbWltZVR5cGU6IFwiaW1hZ2Uvd2VicFwiLCBieXRlczogWzgyLCA3MywgNzAsIDcwXSB9XG5dO1xuZnVuY3Rpb24gZGV0ZWN0SW1hZ2VNaW1lVHlwZShpbWFnZSkge1xuICBmb3IgKGNvbnN0IHsgYnl0ZXMsIG1pbWVUeXBlIH0gb2YgbWltZVR5cGVTaWduYXR1cmVzKSB7XG4gICAgaWYgKGltYWdlLmxlbmd0aCA+PSBieXRlcy5sZW5ndGggJiYgYnl0ZXMuZXZlcnkoKGJ5dGUsIGluZGV4KSA9PiBpbWFnZVtpbmRleF0gPT09IGJ5dGUpKSB7XG4gICAgICByZXR1cm4gbWltZVR5cGU7XG4gICAgfVxuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5cbi8vIGNvcmUvcHJvbXB0L2RhdGEtY29udGVudC50c1xuaW1wb3J0IHsgSW52YWxpZERhdGFDb250ZW50RXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuaW1wb3J0IHtcbiAgY29udmVydEJhc2U2NFRvVWludDhBcnJheSxcbiAgY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NFxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuZnVuY3Rpb24gY29udmVydERhdGFDb250ZW50VG9CYXNlNjRTdHJpbmcoY29udGVudCkge1xuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuICBpZiAoY29udGVudCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQobmV3IFVpbnQ4QXJyYXkoY29udGVudCkpO1xuICB9XG4gIHJldHVybiBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0KGNvbnRlbnQpO1xufVxuZnVuY3Rpb24gY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5KGNvbnRlbnQpIHtcbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkoY29udGVudCk7XG4gIH1cbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShjb250ZW50KTtcbiAgfVxuICB0aHJvdyBuZXcgSW52YWxpZERhdGFDb250ZW50RXJyb3IoeyBjb250ZW50IH0pO1xufVxuXG4vLyBjb3JlL3Byb21wdC9jb252ZXJ0LXRvLWxhbmd1YWdlLW1vZGVsLXByb21wdC50c1xuZnVuY3Rpb24gY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdChwcm9tcHQpIHtcbiAgY29uc3QgbGFuZ3VhZ2VNb2RlbE1lc3NhZ2VzID0gW107XG4gIGlmIChwcm9tcHQuc3lzdGVtICE9IG51bGwpIHtcbiAgICBsYW5ndWFnZU1vZGVsTWVzc2FnZXMucHVzaCh7IHJvbGU6IFwic3lzdGVtXCIsIGNvbnRlbnQ6IHByb21wdC5zeXN0ZW0gfSk7XG4gIH1cbiAgc3dpdGNoIChwcm9tcHQudHlwZSkge1xuICAgIGNhc2UgXCJwcm9tcHRcIjoge1xuICAgICAgbGFuZ3VhZ2VNb2RlbE1lc3NhZ2VzLnB1c2goe1xuICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgY29udGVudDogW3sgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IHByb21wdC5wcm9tcHQgfV1cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJtZXNzYWdlc1wiOiB7XG4gICAgICBsYW5ndWFnZU1vZGVsTWVzc2FnZXMucHVzaChcbiAgICAgICAgLi4ucHJvbXB0Lm1lc3NhZ2VzLm1hcCgobWVzc2FnZSkgPT4ge1xuICAgICAgICAgIHN3aXRjaCAobWVzc2FnZS5yb2xlKSB7XG4gICAgICAgICAgICBjYXNlIFwidXNlclwiOiB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgICAgICAgICAgY29udGVudDogW3sgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IG1lc3NhZ2UuY29udGVudCB9XVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICAgICAgICBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQubWFwKFxuICAgICAgICAgICAgICAgICAgKHBhcnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHBhcnQudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0O1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaW1hZ2VcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnQuaW1hZ2UgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImltYWdlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IHBhcnQuaW1hZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWltZVR5cGU6IHBhcnQubWltZVR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlVWludDggPSBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnQuaW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImltYWdlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlOiBpbWFnZVVpbnQ4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZTogKF9hID0gcGFydC5taW1lVHlwZSkgIT0gbnVsbCA/IF9hIDogZGV0ZWN0SW1hZ2VNaW1lVHlwZShpbWFnZVVpbnQ4KVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiYXNzaXN0YW50XCI6IHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFt7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBtZXNzYWdlLmNvbnRlbnQgfV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB7IHJvbGU6IFwiYXNzaXN0YW50XCIsIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2xcIjoge1xuICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSBwcm9tcHQ7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHByb21wdCB0eXBlOiAke19leGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBsYW5ndWFnZU1vZGVsTWVzc2FnZXM7XG59XG5cbi8vIGNvcmUvcHJvbXB0L2dldC12YWxpZGF0ZWQtcHJvbXB0LnRzXG5pbXBvcnQgeyBJbnZhbGlkUHJvbXB0RXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuZnVuY3Rpb24gZ2V0VmFsaWRhdGVkUHJvbXB0KHByb21wdCkge1xuICBpZiAocHJvbXB0LnByb21wdCA9PSBudWxsICYmIHByb21wdC5tZXNzYWdlcyA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRQcm9tcHRFcnJvcih7XG4gICAgICBwcm9tcHQsXG4gICAgICBtZXNzYWdlOiBcInByb21wdCBvciBtZXNzYWdlcyBtdXN0IGJlIGRlZmluZWRcIlxuICAgIH0pO1xuICB9XG4gIGlmIChwcm9tcHQucHJvbXB0ICE9IG51bGwgJiYgcHJvbXB0Lm1lc3NhZ2VzICE9IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6IFwicHJvbXB0IGFuZCBtZXNzYWdlcyBjYW5ub3QgYmUgZGVmaW5lZCBhdCB0aGUgc2FtZSB0aW1lXCJcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcHJvbXB0LnByb21wdCAhPSBudWxsID8ge1xuICAgIHR5cGU6IFwicHJvbXB0XCIsXG4gICAgcHJvbXB0OiBwcm9tcHQucHJvbXB0LFxuICAgIG1lc3NhZ2VzOiB2b2lkIDAsXG4gICAgc3lzdGVtOiBwcm9tcHQuc3lzdGVtXG4gIH0gOiB7XG4gICAgdHlwZTogXCJtZXNzYWdlc1wiLFxuICAgIHByb21wdDogdm9pZCAwLFxuICAgIG1lc3NhZ2VzOiBwcm9tcHQubWVzc2FnZXMsXG4gICAgLy8gb25seSBwb3NzaWJsZSBjYXNlIGJjIG9mIGNoZWNrcyBhYm92ZVxuICAgIHN5c3RlbTogcHJvbXB0LnN5c3RlbVxuICB9O1xufVxuXG4vLyBjb3JlL3Byb21wdC9wcmVwYXJlLWNhbGwtc2V0dGluZ3MudHNcbmltcG9ydCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmZ1bmN0aW9uIHByZXBhcmVDYWxsU2V0dGluZ3Moe1xuICBtYXhUb2tlbnMsXG4gIHRlbXBlcmF0dXJlLFxuICB0b3BQLFxuICBwcmVzZW5jZVBlbmFsdHksXG4gIGZyZXF1ZW5jeVBlbmFsdHksXG4gIHNlZWQsXG4gIG1heFJldHJpZXNcbn0pIHtcbiAgaWYgKG1heFRva2VucyAhPSBudWxsKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFRva2VucykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtYXhUb2tlbnNcIixcbiAgICAgICAgdmFsdWU6IG1heFRva2VucyxcbiAgICAgICAgbWVzc2FnZTogXCJtYXhUb2tlbnMgbXVzdCBiZSBhbiBpbnRlZ2VyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAobWF4VG9rZW5zIDwgMSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcIm1heFRva2Vuc1wiLFxuICAgICAgICB2YWx1ZTogbWF4VG9rZW5zLFxuICAgICAgICBtZXNzYWdlOiBcIm1heFRva2VucyBtdXN0IGJlID49IDFcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmICh0ZW1wZXJhdHVyZSAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiB0ZW1wZXJhdHVyZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInRlbXBlcmF0dXJlXCIsXG4gICAgICAgIHZhbHVlOiB0ZW1wZXJhdHVyZSxcbiAgICAgICAgbWVzc2FnZTogXCJ0ZW1wZXJhdHVyZSBtdXN0IGJlIGEgbnVtYmVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAodG9wUCAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiB0b3BQICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwidG9wUFwiLFxuICAgICAgICB2YWx1ZTogdG9wUCxcbiAgICAgICAgbWVzc2FnZTogXCJ0b3BQIG11c3QgYmUgYSBudW1iZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChwcmVzZW5jZVBlbmFsdHkgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgcHJlc2VuY2VQZW5hbHR5ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwicHJlc2VuY2VQZW5hbHR5XCIsXG4gICAgICAgIHZhbHVlOiBwcmVzZW5jZVBlbmFsdHksXG4gICAgICAgIG1lc3NhZ2U6IFwicHJlc2VuY2VQZW5hbHR5IG11c3QgYmUgYSBudW1iZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChmcmVxdWVuY3lQZW5hbHR5ICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIGZyZXF1ZW5jeVBlbmFsdHkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJmcmVxdWVuY3lQZW5hbHR5XCIsXG4gICAgICAgIHZhbHVlOiBmcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICBtZXNzYWdlOiBcImZyZXF1ZW5jeVBlbmFsdHkgbXVzdCBiZSBhIG51bWJlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHNlZWQgIT0gbnVsbCkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihzZWVkKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNlZWRcIixcbiAgICAgICAgdmFsdWU6IHNlZWQsXG4gICAgICAgIG1lc3NhZ2U6IFwic2VlZCBtdXN0IGJlIGFuIGludGVnZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChtYXhSZXRyaWVzICE9IG51bGwpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobWF4UmV0cmllcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtYXhSZXRyaWVzXCIsXG4gICAgICAgIHZhbHVlOiBtYXhSZXRyaWVzLFxuICAgICAgICBtZXNzYWdlOiBcIm1heFJldHJpZXMgbXVzdCBiZSBhbiBpbnRlZ2VyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAobWF4UmV0cmllcyA8IDApIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtYXhSZXRyaWVzXCIsXG4gICAgICAgIHZhbHVlOiBtYXhSZXRyaWVzLFxuICAgICAgICBtZXNzYWdlOiBcIm1heFJldHJpZXMgbXVzdCBiZSA+PSAwXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIG1heFRva2VucyxcbiAgICB0ZW1wZXJhdHVyZTogdGVtcGVyYXR1cmUgIT0gbnVsbCA/IHRlbXBlcmF0dXJlIDogMCxcbiAgICB0b3BQLFxuICAgIHByZXNlbmNlUGVuYWx0eSxcbiAgICBmcmVxdWVuY3lQZW5hbHR5LFxuICAgIHNlZWQsXG4gICAgbWF4UmV0cmllczogbWF4UmV0cmllcyAhPSBudWxsID8gbWF4UmV0cmllcyA6IDJcbiAgfTtcbn1cblxuLy8gY29yZS91dGlsL2NvbnZlcnQtem9kLXRvLWpzb24tc2NoZW1hLnRzXG5pbXBvcnQgem9kVG9Kc29uU2NoZW1hIGZyb20gXCJ6b2QtdG8tanNvbi1zY2hlbWFcIjtcbmZ1bmN0aW9uIGNvbnZlcnRab2RUb0pTT05TY2hlbWEoem9kU2NoZW1hKSB7XG4gIHJldHVybiB6b2RUb0pzb25TY2hlbWEoem9kU2NoZW1hKTtcbn1cblxuLy8gY29yZS91dGlsL3JldHJ5LXdpdGgtZXhwb25lbnRpYWwtYmFja29mZi50c1xuaW1wb3J0IHsgQVBJQ2FsbEVycm9yLCBSZXRyeUVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7IGdldEVycm9yTWVzc2FnZSwgaXNBYm9ydEVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gY29yZS91dGlsL2RlbGF5LnRzXG5hc3luYyBmdW5jdGlvbiBkZWxheShkZWxheUluTXMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5SW5NcykpO1xufVxuXG4vLyBjb3JlL3V0aWwvcmV0cnktd2l0aC1leHBvbmVudGlhbC1iYWNrb2ZmLnRzXG52YXIgcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmID0gKHtcbiAgbWF4UmV0cmllcyA9IDIsXG4gIGluaXRpYWxEZWxheUluTXMgPSAyZTMsXG4gIGJhY2tvZmZGYWN0b3IgPSAyXG59ID0ge30pID0+IGFzeW5jIChmKSA9PiBfcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKGYsIHtcbiAgbWF4UmV0cmllcyxcbiAgZGVsYXlJbk1zOiBpbml0aWFsRGVsYXlJbk1zLFxuICBiYWNrb2ZmRmFjdG9yXG59KTtcbmFzeW5jIGZ1bmN0aW9uIF9yZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoZiwge1xuICBtYXhSZXRyaWVzLFxuICBkZWxheUluTXMsXG4gIGJhY2tvZmZGYWN0b3Jcbn0sIGVycm9ycyA9IFtdKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IGYoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoaXNBYm9ydEVycm9yKGVycm9yKSkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGlmIChtYXhSZXRyaWVzID09PSAwKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZ2V0RXJyb3JNZXNzYWdlKGVycm9yKTtcbiAgICBjb25zdCBuZXdFcnJvcnMgPSBbLi4uZXJyb3JzLCBlcnJvcl07XG4gICAgY29uc3QgdHJ5TnVtYmVyID0gbmV3RXJyb3JzLmxlbmd0aDtcbiAgICBpZiAodHJ5TnVtYmVyID4gbWF4UmV0cmllcykge1xuICAgICAgdGhyb3cgbmV3IFJldHJ5RXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBgRmFpbGVkIGFmdGVyICR7dHJ5TnVtYmVyfSBhdHRlbXB0cy4gTGFzdCBlcnJvcjogJHtlcnJvck1lc3NhZ2V9YCxcbiAgICAgICAgcmVhc29uOiBcIm1heFJldHJpZXNFeGNlZWRlZFwiLFxuICAgICAgICBlcnJvcnM6IG5ld0Vycm9yc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIEFQSUNhbGxFcnJvci5pc0FQSUNhbGxFcnJvcihlcnJvcikgJiYgZXJyb3IuaXNSZXRyeWFibGUgPT09IHRydWUgJiYgdHJ5TnVtYmVyIDw9IG1heFJldHJpZXMpIHtcbiAgICAgIGF3YWl0IGRlbGF5KGRlbGF5SW5Ncyk7XG4gICAgICByZXR1cm4gX3JldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZihcbiAgICAgICAgZixcbiAgICAgICAgeyBtYXhSZXRyaWVzLCBkZWxheUluTXM6IGJhY2tvZmZGYWN0b3IgKiBkZWxheUluTXMsIGJhY2tvZmZGYWN0b3IgfSxcbiAgICAgICAgbmV3RXJyb3JzXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAodHJ5TnVtYmVyID09PSAxKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFJldHJ5RXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYEZhaWxlZCBhZnRlciAke3RyeU51bWJlcn0gYXR0ZW1wdHMgd2l0aCBub24tcmV0cnlhYmxlIGVycm9yOiAnJHtlcnJvck1lc3NhZ2V9J2AsXG4gICAgICByZWFzb246IFwiZXJyb3JOb3RSZXRyeWFibGVcIixcbiAgICAgIGVycm9yczogbmV3RXJyb3JzXG4gICAgfSk7XG4gIH1cbn1cblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3QvaW5qZWN0LWpzb24tc2NoZW1hLWludG8tc3lzdGVtLnRzXG52YXIgREVGQVVMVF9TQ0hFTUFfUFJFRklYID0gXCJKU09OIHNjaGVtYTpcIjtcbnZhciBERUZBVUxUX1NDSEVNQV9TVUZGSVggPSBcIllvdSBNVVNUIGFuc3dlciB3aXRoIGEgSlNPTiBvYmplY3QgdGhhdCBtYXRjaGVzIHRoZSBKU09OIHNjaGVtYSBhYm92ZS5cIjtcbmZ1bmN0aW9uIGluamVjdEpzb25TY2hlbWFJbnRvU3lzdGVtKHtcbiAgc3lzdGVtLFxuICBzY2hlbWEsXG4gIHNjaGVtYVByZWZpeCA9IERFRkFVTFRfU0NIRU1BX1BSRUZJWCxcbiAgc2NoZW1hU3VmZml4ID0gREVGQVVMVF9TQ0hFTUFfU1VGRklYXG59KSB7XG4gIHJldHVybiBbXG4gICAgc3lzdGVtLFxuICAgIHN5c3RlbSAhPSBudWxsID8gXCJcIiA6IG51bGwsXG4gICAgLy8gYWRkIGEgbmV3bGluZSBpZiBzeXN0ZW0gaXMgbm90IG51bGxcbiAgICBzY2hlbWFQcmVmaXgsXG4gICAgSlNPTi5zdHJpbmdpZnkoc2NoZW1hKSxcbiAgICBzY2hlbWFTdWZmaXhcbiAgXS5maWx0ZXIoKGxpbmUpID0+IGxpbmUgIT0gbnVsbCkuam9pbihcIlxcblwiKTtcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3QvZ2VuZXJhdGUtb2JqZWN0LnRzXG5hc3luYyBmdW5jdGlvbiBleHBlcmltZW50YWxfZ2VuZXJhdGVPYmplY3Qoe1xuICBtb2RlbCxcbiAgc2NoZW1hLFxuICBtb2RlLFxuICBzeXN0ZW0sXG4gIHByb21wdCxcbiAgbWVzc2FnZXMsXG4gIG1heFJldHJpZXMsXG4gIGFib3J0U2lnbmFsLFxuICAuLi5zZXR0aW5nc1xufSkge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCByZXRyeSA9IHJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZih7IG1heFJldHJpZXMgfSk7XG4gIGNvbnN0IGpzb25TY2hlbWEgPSBjb252ZXJ0Wm9kVG9KU09OU2NoZW1hKHNjaGVtYSk7XG4gIGlmIChtb2RlID09PSBcImF1dG9cIiB8fCBtb2RlID09IG51bGwpIHtcbiAgICBtb2RlID0gbW9kZWwuZGVmYXVsdE9iamVjdEdlbmVyYXRpb25Nb2RlO1xuICB9XG4gIGxldCByZXN1bHQ7XG4gIGxldCBmaW5pc2hSZWFzb247XG4gIGxldCB1c2FnZTtcbiAgbGV0IHdhcm5pbmdzO1xuICBsZXQgcmF3UmVzcG9uc2U7XG4gIGxldCBsb2dwcm9icztcbiAgc3dpdGNoIChtb2RlKSB7XG4gICAgY2FzZSBcImpzb25cIjoge1xuICAgICAgY29uc3QgdmFsaWRhdGVkUHJvbXB0ID0gZ2V0VmFsaWRhdGVkUHJvbXB0KHtcbiAgICAgICAgc3lzdGVtOiBpbmplY3RKc29uU2NoZW1hSW50b1N5c3RlbSh7IHN5c3RlbSwgc2NoZW1hOiBqc29uU2NoZW1hIH0pLFxuICAgICAgICBwcm9tcHQsXG4gICAgICAgIG1lc3NhZ2VzXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGdlbmVyYXRlUmVzdWx0ID0gYXdhaXQgcmV0cnkoKCkgPT4ge1xuICAgICAgICByZXR1cm4gbW9kZWwuZG9HZW5lcmF0ZSh7XG4gICAgICAgICAgbW9kZTogeyB0eXBlOiBcIm9iamVjdC1qc29uXCIgfSxcbiAgICAgICAgICAuLi5wcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKSxcbiAgICAgICAgICBpbnB1dEZvcm1hdDogdmFsaWRhdGVkUHJvbXB0LnR5cGUsXG4gICAgICAgICAgcHJvbXB0OiBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHZhbGlkYXRlZFByb21wdCksXG4gICAgICAgICAgYWJvcnRTaWduYWxcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGlmIChnZW5lcmF0ZVJlc3VsdC50ZXh0ID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IE5vT2JqZWN0R2VuZXJhdGVkRXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGdlbmVyYXRlUmVzdWx0LnRleHQ7XG4gICAgICBmaW5pc2hSZWFzb24gPSBnZW5lcmF0ZVJlc3VsdC5maW5pc2hSZWFzb247XG4gICAgICB1c2FnZSA9IGdlbmVyYXRlUmVzdWx0LnVzYWdlO1xuICAgICAgd2FybmluZ3MgPSBnZW5lcmF0ZVJlc3VsdC53YXJuaW5ncztcbiAgICAgIHJhd1Jlc3BvbnNlID0gZ2VuZXJhdGVSZXN1bHQucmF3UmVzcG9uc2U7XG4gICAgICBsb2dwcm9icyA9IGdlbmVyYXRlUmVzdWx0LmxvZ3Byb2JzO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJncmFtbWFyXCI6IHtcbiAgICAgIGNvbnN0IHZhbGlkYXRlZFByb21wdCA9IGdldFZhbGlkYXRlZFByb21wdCh7XG4gICAgICAgIHN5c3RlbTogaW5qZWN0SnNvblNjaGVtYUludG9TeXN0ZW0oeyBzeXN0ZW0sIHNjaGVtYToganNvblNjaGVtYSB9KSxcbiAgICAgICAgcHJvbXB0LFxuICAgICAgICBtZXNzYWdlc1xuICAgICAgfSk7XG4gICAgICBjb25zdCBnZW5lcmF0ZVJlc3VsdCA9IGF3YWl0IHJldHJ5KFxuICAgICAgICAoKSA9PiBtb2RlbC5kb0dlbmVyYXRlKHtcbiAgICAgICAgICBtb2RlOiB7IHR5cGU6IFwib2JqZWN0LWdyYW1tYXJcIiwgc2NoZW1hOiBqc29uU2NoZW1hIH0sXG4gICAgICAgICAgLi4uc2V0dGluZ3MsXG4gICAgICAgICAgaW5wdXRGb3JtYXQ6IHZhbGlkYXRlZFByb21wdC50eXBlLFxuICAgICAgICAgIHByb21wdDogY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh2YWxpZGF0ZWRQcm9tcHQpLFxuICAgICAgICAgIGFib3J0U2lnbmFsXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgaWYgKGdlbmVyYXRlUmVzdWx0LnRleHQgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcigpO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gZ2VuZXJhdGVSZXN1bHQudGV4dDtcbiAgICAgIGZpbmlzaFJlYXNvbiA9IGdlbmVyYXRlUmVzdWx0LmZpbmlzaFJlYXNvbjtcbiAgICAgIHVzYWdlID0gZ2VuZXJhdGVSZXN1bHQudXNhZ2U7XG4gICAgICB3YXJuaW5ncyA9IGdlbmVyYXRlUmVzdWx0Lndhcm5pbmdzO1xuICAgICAgcmF3UmVzcG9uc2UgPSBnZW5lcmF0ZVJlc3VsdC5yYXdSZXNwb25zZTtcbiAgICAgIGxvZ3Byb2JzID0gZ2VuZXJhdGVSZXN1bHQubG9ncHJvYnM7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcInRvb2xcIjoge1xuICAgICAgY29uc3QgdmFsaWRhdGVkUHJvbXB0ID0gZ2V0VmFsaWRhdGVkUHJvbXB0KHtcbiAgICAgICAgc3lzdGVtLFxuICAgICAgICBwcm9tcHQsXG4gICAgICAgIG1lc3NhZ2VzXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGdlbmVyYXRlUmVzdWx0ID0gYXdhaXQgcmV0cnkoXG4gICAgICAgICgpID0+IG1vZGVsLmRvR2VuZXJhdGUoe1xuICAgICAgICAgIG1vZGU6IHtcbiAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0LXRvb2xcIixcbiAgICAgICAgICAgIHRvb2w6IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICBuYW1lOiBcImpzb25cIixcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiUmVzcG9uZCB3aXRoIGEgSlNPTiBvYmplY3QuXCIsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IGpzb25TY2hlbWFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIC4uLnNldHRpbmdzLFxuICAgICAgICAgIGlucHV0Rm9ybWF0OiB2YWxpZGF0ZWRQcm9tcHQudHlwZSxcbiAgICAgICAgICBwcm9tcHQ6IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQodmFsaWRhdGVkUHJvbXB0KSxcbiAgICAgICAgICBhYm9ydFNpZ25hbFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIGNvbnN0IGZ1bmN0aW9uQXJncyA9IChfYiA9IChfYSA9IGdlbmVyYXRlUmVzdWx0LnRvb2xDYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2IuYXJncztcbiAgICAgIGlmIChmdW5jdGlvbkFyZ3MgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcigpO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gZnVuY3Rpb25BcmdzO1xuICAgICAgZmluaXNoUmVhc29uID0gZ2VuZXJhdGVSZXN1bHQuZmluaXNoUmVhc29uO1xuICAgICAgdXNhZ2UgPSBnZW5lcmF0ZVJlc3VsdC51c2FnZTtcbiAgICAgIHdhcm5pbmdzID0gZ2VuZXJhdGVSZXN1bHQud2FybmluZ3M7XG4gICAgICByYXdSZXNwb25zZSA9IGdlbmVyYXRlUmVzdWx0LnJhd1Jlc3BvbnNlO1xuICAgICAgbG9ncHJvYnMgPSBnZW5lcmF0ZVJlc3VsdC5sb2dwcm9icztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIHZvaWQgMDoge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTW9kZWwgZG9lcyBub3QgaGF2ZSBhIGRlZmF1bHQgb2JqZWN0IGdlbmVyYXRpb24gbW9kZS5cIik7XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSBtb2RlO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBtb2RlOiAke19leGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHBhcnNlUmVzdWx0ID0gc2FmZVBhcnNlSlNPTih7IHRleHQ6IHJlc3VsdCwgc2NoZW1hIH0pO1xuICBpZiAoIXBhcnNlUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICB0aHJvdyBwYXJzZVJlc3VsdC5lcnJvcjtcbiAgfVxuICByZXR1cm4gbmV3IEdlbmVyYXRlT2JqZWN0UmVzdWx0KHtcbiAgICBvYmplY3Q6IHBhcnNlUmVzdWx0LnZhbHVlLFxuICAgIGZpbmlzaFJlYXNvbixcbiAgICB1c2FnZTogY2FsY3VsYXRlVG9rZW5Vc2FnZSh1c2FnZSksXG4gICAgd2FybmluZ3MsXG4gICAgcmF3UmVzcG9uc2UsXG4gICAgbG9ncHJvYnNcbiAgfSk7XG59XG52YXIgR2VuZXJhdGVPYmplY3RSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9iamVjdCA9IG9wdGlvbnMub2JqZWN0O1xuICAgIHRoaXMuZmluaXNoUmVhc29uID0gb3B0aW9ucy5maW5pc2hSZWFzb247XG4gICAgdGhpcy51c2FnZSA9IG9wdGlvbnMudXNhZ2U7XG4gICAgdGhpcy53YXJuaW5ncyA9IG9wdGlvbnMud2FybmluZ3M7XG4gICAgdGhpcy5yYXdSZXNwb25zZSA9IG9wdGlvbnMucmF3UmVzcG9uc2U7XG4gICAgdGhpcy5sb2dwcm9icyA9IG9wdGlvbnMubG9ncHJvYnM7XG4gIH1cbn07XG5cbi8vIGNvcmUvdXRpbC9hc3luYy1pdGVyYWJsZS1zdHJlYW0udHNcbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0oc291cmNlLCB0cmFuc2Zvcm1lcikge1xuICBjb25zdCB0cmFuc2Zvcm1lZFN0cmVhbSA9IHNvdXJjZS5waXBlVGhyb3VnaChcbiAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHRyYW5zZm9ybWVyKVxuICApO1xuICB0cmFuc2Zvcm1lZFN0cmVhbVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSAoKSA9PiB7XG4gICAgY29uc3QgcmVhZGVyID0gdHJhbnNmb3JtZWRTdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFzeW5jIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgIHJldHVybiBkb25lID8geyBkb25lOiB0cnVlLCB2YWx1ZTogdm9pZCAwIH0gOiB7IGRvbmU6IGZhbHNlLCB2YWx1ZSB9O1xuICAgICAgfVxuICAgIH07XG4gIH07XG4gIHJldHVybiB0cmFuc2Zvcm1lZFN0cmVhbTtcbn1cblxuLy8gY29yZS91dGlsL2lzLWRlZXAtZXF1YWwtZGF0YS50c1xuZnVuY3Rpb24gaXNEZWVwRXF1YWxEYXRhKG9iajEsIG9iajIpIHtcbiAgaWYgKG9iajEgPT09IG9iajIpXG4gICAgcmV0dXJuIHRydWU7XG4gIGlmIChvYmoxID09IG51bGwgfHwgb2JqMiA9PSBudWxsKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBvYmoxICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmoyICE9PSBcIm9iamVjdFwiKVxuICAgIHJldHVybiBvYmoxID09PSBvYmoyO1xuICBpZiAob2JqMS5jb25zdHJ1Y3RvciAhPT0gb2JqMi5jb25zdHJ1Y3RvcilcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChvYmoxIGluc3RhbmNlb2YgRGF0ZSAmJiBvYmoyIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiBvYmoxLmdldFRpbWUoKSA9PT0gb2JqMi5nZXRUaW1lKCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqMSkpIHtcbiAgICBpZiAob2JqMS5sZW5ndGggIT09IG9iajIubGVuZ3RoKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqMS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFpc0RlZXBFcXVhbERhdGEob2JqMVtpXSwgb2JqMltpXSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3Qga2V5czEgPSBPYmplY3Qua2V5cyhvYmoxKTtcbiAgY29uc3Qga2V5czIgPSBPYmplY3Qua2V5cyhvYmoyKTtcbiAgaWYgKGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5czEpIHtcbiAgICBpZiAoIWtleXMyLmluY2x1ZGVzKGtleSkpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFpc0RlZXBFcXVhbERhdGEob2JqMVtrZXldLCBvYmoyW2tleV0pKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBjb3JlL3V0aWwvcGFyc2UtcGFydGlhbC1qc29uLnRzXG5pbXBvcnQgU2VjdXJlSlNPTiBmcm9tIFwic2VjdXJlLWpzb24tcGFyc2VcIjtcblxuLy8gY29yZS91dGlsL2ZpeC1qc29uLnRzXG5mdW5jdGlvbiBmaXhKc29uKGlucHV0KSB7XG4gIGNvbnN0IHN0YWNrID0gW1wiUk9PVFwiXTtcbiAgbGV0IGxhc3RWYWxpZEluZGV4ID0gLTE7XG4gIGxldCBsaXRlcmFsU3RhcnQgPSBudWxsO1xuICBmdW5jdGlvbiBwcm9jZXNzVmFsdWVTdGFydChjaGFyLCBpLCBzd2FwU3RhdGUpIHtcbiAgICB7XG4gICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgY2FzZSAnXCInOiB7XG4gICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgIHN0YWNrLnB1c2goc3dhcFN0YXRlKTtcbiAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX1NUUklOR1wiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZlwiOlxuICAgICAgICBjYXNlIFwidFwiOlxuICAgICAgICBjYXNlIFwiblwiOiB7XG4gICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgIGxpdGVyYWxTdGFydCA9IGk7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfTElURVJBTFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiLVwiOiB7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfTlVNQkVSXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCIwXCI6XG4gICAgICAgIGNhc2UgXCIxXCI6XG4gICAgICAgIGNhc2UgXCIyXCI6XG4gICAgICAgIGNhc2UgXCIzXCI6XG4gICAgICAgIGNhc2UgXCI0XCI6XG4gICAgICAgIGNhc2UgXCI1XCI6XG4gICAgICAgIGNhc2UgXCI2XCI6XG4gICAgICAgIGNhc2UgXCI3XCI6XG4gICAgICAgIGNhc2UgXCI4XCI6XG4gICAgICAgIGNhc2UgXCI5XCI6IHtcbiAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfTlVNQkVSXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ7XCI6IHtcbiAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfT0JKRUNUX1NUQVJUXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJbXCI6IHtcbiAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfQVJSQVlfU1RBUlRcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcHJvY2Vzc0FmdGVyT2JqZWN0VmFsdWUoY2hhciwgaSkge1xuICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgY2FzZSBcIixcIjoge1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9PQkpFQ1RfQUZURVJfQ09NTUFcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIn1cIjoge1xuICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcHJvY2Vzc0FmdGVyQXJyYXlWYWx1ZShjaGFyLCBpKSB7XG4gICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICBjYXNlIFwiLFwiOiB7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX0FSUkFZX0FGVEVSX0NPTU1BXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJdXCI6IHtcbiAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGFyID0gaW5wdXRbaV07XG4gICAgY29uc3QgY3VycmVudFN0YXRlID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgc3dpdGNoIChjdXJyZW50U3RhdGUpIHtcbiAgICAgIGNhc2UgXCJST09UXCI6XG4gICAgICAgIHByb2Nlc3NWYWx1ZVN0YXJ0KGNoYXIsIGksIFwiRklOSVNIXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX1NUQVJUXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSAnXCInOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfT0JKRUNUX0tFWVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwifVwiOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0FGVEVSX0NPTU1BXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSAnXCInOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfT0JKRUNUX0tFWVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0tFWVwiOiB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgIGNhc2UgJ1wiJzoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX09CSkVDVF9BRlRFUl9LRVlcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9BRlRFUl9LRVlcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlIFwiOlwiOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfT0JKRUNUX0JFRk9SRV9WQUxVRVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0JFRk9SRV9WQUxVRVwiOiB7XG4gICAgICAgIHByb2Nlc3NWYWx1ZVN0YXJ0KGNoYXIsIGksIFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiOiB7XG4gICAgICAgIHByb2Nlc3NBZnRlck9iamVjdFZhbHVlKGNoYXIsIGkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfU1RSSU5HXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSAnXCInOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiXFxcXFwiOiB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX1NUUklOR19FU0NBUEVcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfQVJSQVlfU1RBUlRcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlIFwiXVwiOiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBwcm9jZXNzVmFsdWVTdGFydChjaGFyLCBpLCBcIklOU0lERV9BUlJBWV9BRlRFUl9WQUxVRVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfQVJSQVlfQUZURVJfVkFMVUVcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlIFwiLFwiOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfQVJSQVlfQUZURVJfQ09NTUFcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIl1cIjoge1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9BUlJBWV9BRlRFUl9DT01NQVwiOiB7XG4gICAgICAgIHByb2Nlc3NWYWx1ZVN0YXJ0KGNoYXIsIGksIFwiSU5TSURFX0FSUkFZX0FGVEVSX1ZBTFVFXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfU1RSSU5HX0VTQ0FQRVwiOiB7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9OVU1CRVJcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlIFwiMFwiOlxuICAgICAgICAgIGNhc2UgXCIxXCI6XG4gICAgICAgICAgY2FzZSBcIjJcIjpcbiAgICAgICAgICBjYXNlIFwiM1wiOlxuICAgICAgICAgIGNhc2UgXCI0XCI6XG4gICAgICAgICAgY2FzZSBcIjVcIjpcbiAgICAgICAgICBjYXNlIFwiNlwiOlxuICAgICAgICAgIGNhc2UgXCI3XCI6XG4gICAgICAgICAgY2FzZSBcIjhcIjpcbiAgICAgICAgICBjYXNlIFwiOVwiOiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImVcIjpcbiAgICAgICAgICBjYXNlIFwiRVwiOlxuICAgICAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgICAgY2FzZSBcIi5cIjoge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCIsXCI6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBcIklOU0lERV9BUlJBWV9BRlRFUl9WQUxVRVwiKSB7XG4gICAgICAgICAgICAgIHByb2Nlc3NBZnRlckFycmF5VmFsdWUoY2hhciwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiKSB7XG4gICAgICAgICAgICAgIHByb2Nlc3NBZnRlck9iamVjdFZhbHVlKGNoYXIsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJ9XCI6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBcIklOU0lERV9PQkpFQ1RfQUZURVJfVkFMVUVcIikge1xuICAgICAgICAgICAgICBwcm9jZXNzQWZ0ZXJPYmplY3RWYWx1ZShjaGFyLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiXVwiOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGlmIChzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gXCJJTlNJREVfQVJSQVlfQUZURVJfVkFMVUVcIikge1xuICAgICAgICAgICAgICBwcm9jZXNzQWZ0ZXJBcnJheVZhbHVlKGNoYXIsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9MSVRFUkFMXCI6IHtcbiAgICAgICAgY29uc3QgcGFydGlhbExpdGVyYWwgPSBpbnB1dC5zdWJzdHJpbmcobGl0ZXJhbFN0YXJ0LCBpICsgMSk7XG4gICAgICAgIGlmICghXCJmYWxzZVwiLnN0YXJ0c1dpdGgocGFydGlhbExpdGVyYWwpICYmICFcInRydWVcIi5zdGFydHNXaXRoKHBhcnRpYWxMaXRlcmFsKSAmJiAhXCJudWxsXCIuc3RhcnRzV2l0aChwYXJ0aWFsTGl0ZXJhbCkpIHtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiKSB7XG4gICAgICAgICAgICBwcm9jZXNzQWZ0ZXJPYmplY3RWYWx1ZShjaGFyLCBpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBcIklOU0lERV9BUlJBWV9BRlRFUl9WQUxVRVwiKSB7XG4gICAgICAgICAgICBwcm9jZXNzQWZ0ZXJBcnJheVZhbHVlKGNoYXIsIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxldCByZXN1bHQgPSBpbnB1dC5zbGljZSgwLCBsYXN0VmFsaWRJbmRleCArIDEpO1xuICBmb3IgKGxldCBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBzdGF0ZSA9IHN0YWNrW2ldO1xuICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgIGNhc2UgXCJJTlNJREVfU1RSSU5HXCI6IHtcbiAgICAgICAgcmVzdWx0ICs9ICdcIic7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfS0VZXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9BRlRFUl9LRVlcIjpcbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0FGVEVSX0NPTU1BXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9TVEFSVFwiOlxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfQkVGT1JFX1ZBTFVFXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiOiB7XG4gICAgICAgIHJlc3VsdCArPSBcIn1cIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX0FSUkFZX1NUQVJUXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX0FSUkFZX0FGVEVSX0NPTU1BXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX0FSUkFZX0FGVEVSX1ZBTFVFXCI6IHtcbiAgICAgICAgcmVzdWx0ICs9IFwiXVwiO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfTElURVJBTFwiOiB7XG4gICAgICAgIGNvbnN0IHBhcnRpYWxMaXRlcmFsID0gaW5wdXQuc3Vic3RyaW5nKGxpdGVyYWxTdGFydCwgaW5wdXQubGVuZ3RoKTtcbiAgICAgICAgaWYgKFwidHJ1ZVwiLnN0YXJ0c1dpdGgocGFydGlhbExpdGVyYWwpKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IFwidHJ1ZVwiLnNsaWNlKHBhcnRpYWxMaXRlcmFsLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAoXCJmYWxzZVwiLnN0YXJ0c1dpdGgocGFydGlhbExpdGVyYWwpKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IFwiZmFsc2VcIi5zbGljZShwYXJ0aWFsTGl0ZXJhbC5sZW5ndGgpO1xuICAgICAgICB9IGVsc2UgaWYgKFwibnVsbFwiLnN0YXJ0c1dpdGgocGFydGlhbExpdGVyYWwpKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IFwibnVsbFwiLnNsaWNlKHBhcnRpYWxMaXRlcmFsLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gY29yZS91dGlsL3BhcnNlLXBhcnRpYWwtanNvbi50c1xuZnVuY3Rpb24gcGFyc2VQYXJ0aWFsSnNvbihqc29uVGV4dCkge1xuICBpZiAoanNvblRleHQgPT0gbnVsbCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gU2VjdXJlSlNPTi5wYXJzZShqc29uVGV4dCk7XG4gIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZml4ZWRKc29uVGV4dCA9IGZpeEpzb24oanNvblRleHQpO1xuICAgICAgcmV0dXJuIFNlY3VyZUpTT04ucGFyc2UoZml4ZWRKc29uVGV4dCk7XG4gICAgfSBjYXRjaCAoaWdub3JlZDIpIHtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3Qvc3RyZWFtLW9iamVjdC50c1xuYXN5bmMgZnVuY3Rpb24gZXhwZXJpbWVudGFsX3N0cmVhbU9iamVjdCh7XG4gIG1vZGVsLFxuICBzY2hlbWEsXG4gIG1vZGUsXG4gIHN5c3RlbSxcbiAgcHJvbXB0LFxuICBtZXNzYWdlcyxcbiAgbWF4UmV0cmllcyxcbiAgYWJvcnRTaWduYWwsXG4gIC4uLnNldHRpbmdzXG59KSB7XG4gIGNvbnN0IHJldHJ5ID0gcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKHsgbWF4UmV0cmllcyB9KTtcbiAgY29uc3QganNvblNjaGVtYSA9IGNvbnZlcnRab2RUb0pTT05TY2hlbWEoc2NoZW1hKTtcbiAgaWYgKG1vZGUgPT09IFwiYXV0b1wiIHx8IG1vZGUgPT0gbnVsbCkge1xuICAgIG1vZGUgPSBtb2RlbC5kZWZhdWx0T2JqZWN0R2VuZXJhdGlvbk1vZGU7XG4gIH1cbiAgbGV0IGNhbGxPcHRpb25zO1xuICBsZXQgdHJhbnNmb3JtZXI7XG4gIHN3aXRjaCAobW9kZSkge1xuICAgIGNhc2UgXCJqc29uXCI6IHtcbiAgICAgIGNvbnN0IHZhbGlkYXRlZFByb21wdCA9IGdldFZhbGlkYXRlZFByb21wdCh7XG4gICAgICAgIHN5c3RlbTogaW5qZWN0SnNvblNjaGVtYUludG9TeXN0ZW0oeyBzeXN0ZW0sIHNjaGVtYToganNvblNjaGVtYSB9KSxcbiAgICAgICAgcHJvbXB0LFxuICAgICAgICBtZXNzYWdlc1xuICAgICAgfSk7XG4gICAgICBjYWxsT3B0aW9ucyA9IHtcbiAgICAgICAgbW9kZTogeyB0eXBlOiBcIm9iamVjdC1qc29uXCIgfSxcbiAgICAgICAgLi4ucHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyksXG4gICAgICAgIGlucHV0Rm9ybWF0OiB2YWxpZGF0ZWRQcm9tcHQudHlwZSxcbiAgICAgICAgcHJvbXB0OiBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHZhbGlkYXRlZFByb21wdCksXG4gICAgICAgIGFib3J0U2lnbmFsXG4gICAgICB9O1xuICAgICAgdHJhbnNmb3JtZXIgPSB7XG4gICAgICAgIHRyYW5zZm9ybTogKGNodW5rLCBjb250cm9sbGVyKSA9PiB7XG4gICAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOlxuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmsudGV4dERlbHRhKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6XG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJncmFtbWFyXCI6IHtcbiAgICAgIGNvbnN0IHZhbGlkYXRlZFByb21wdCA9IGdldFZhbGlkYXRlZFByb21wdCh7XG4gICAgICAgIHN5c3RlbTogaW5qZWN0SnNvblNjaGVtYUludG9TeXN0ZW0oeyBzeXN0ZW0sIHNjaGVtYToganNvblNjaGVtYSB9KSxcbiAgICAgICAgcHJvbXB0LFxuICAgICAgICBtZXNzYWdlc1xuICAgICAgfSk7XG4gICAgICBjYWxsT3B0aW9ucyA9IHtcbiAgICAgICAgbW9kZTogeyB0eXBlOiBcIm9iamVjdC1ncmFtbWFyXCIsIHNjaGVtYToganNvblNjaGVtYSB9LFxuICAgICAgICAuLi5zZXR0aW5ncyxcbiAgICAgICAgaW5wdXRGb3JtYXQ6IHZhbGlkYXRlZFByb21wdC50eXBlLFxuICAgICAgICBwcm9tcHQ6IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQodmFsaWRhdGVkUHJvbXB0KSxcbiAgICAgICAgYWJvcnRTaWduYWxcbiAgICAgIH07XG4gICAgICB0cmFuc2Zvcm1lciA9IHtcbiAgICAgICAgdHJhbnNmb3JtOiAoY2h1bmssIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgICBzd2l0Y2ggKGNodW5rLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0LWRlbHRhXCI6XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay50ZXh0RGVsdGEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjpcbiAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcInRvb2xcIjoge1xuICAgICAgY29uc3QgdmFsaWRhdGVkUHJvbXB0ID0gZ2V0VmFsaWRhdGVkUHJvbXB0KHtcbiAgICAgICAgc3lzdGVtLFxuICAgICAgICBwcm9tcHQsXG4gICAgICAgIG1lc3NhZ2VzXG4gICAgICB9KTtcbiAgICAgIGNhbGxPcHRpb25zID0ge1xuICAgICAgICBtb2RlOiB7XG4gICAgICAgICAgdHlwZTogXCJvYmplY3QtdG9vbFwiLFxuICAgICAgICAgIHRvb2w6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgIG5hbWU6IFwianNvblwiLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiUmVzcG9uZCB3aXRoIGEgSlNPTiBvYmplY3QuXCIsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBqc29uU2NoZW1hXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAuLi5zZXR0aW5ncyxcbiAgICAgICAgaW5wdXRGb3JtYXQ6IHZhbGlkYXRlZFByb21wdC50eXBlLFxuICAgICAgICBwcm9tcHQ6IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQodmFsaWRhdGVkUHJvbXB0KSxcbiAgICAgICAgYWJvcnRTaWduYWxcbiAgICAgIH07XG4gICAgICB0cmFuc2Zvcm1lciA9IHtcbiAgICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsLWRlbHRhXCI6XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay5hcmdzVGV4dERlbHRhKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6XG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2Ugdm9pZCAwOiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNb2RlbCBkb2VzIG5vdCBoYXZlIGEgZGVmYXVsdCBvYmplY3QgZ2VuZXJhdGlvbiBtb2RlLlwiKTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IG1vZGU7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG1vZGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmV0cnkoKCkgPT4gbW9kZWwuZG9TdHJlYW0oY2FsbE9wdGlvbnMpKTtcbiAgcmV0dXJuIG5ldyBTdHJlYW1PYmplY3RSZXN1bHQoe1xuICAgIHN0cmVhbTogcmVzdWx0LnN0cmVhbS5waXBlVGhyb3VnaChuZXcgVHJhbnNmb3JtU3RyZWFtKHRyYW5zZm9ybWVyKSksXG4gICAgd2FybmluZ3M6IHJlc3VsdC53YXJuaW5ncyxcbiAgICByYXdSZXNwb25zZTogcmVzdWx0LnJhd1Jlc3BvbnNlXG4gIH0pO1xufVxudmFyIFN0cmVhbU9iamVjdFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHN0cmVhbSxcbiAgICB3YXJuaW5ncyxcbiAgICByYXdSZXNwb25zZVxuICB9KSB7XG4gICAgdGhpcy5vcmlnaW5hbFN0cmVhbSA9IHN0cmVhbTtcbiAgICB0aGlzLndhcm5pbmdzID0gd2FybmluZ3M7XG4gICAgdGhpcy5yYXdSZXNwb25zZSA9IHJhd1Jlc3BvbnNlO1xuICB9XG4gIGdldCBwYXJ0aWFsT2JqZWN0U3RyZWFtKCkge1xuICAgIGxldCBhY2N1bXVsYXRlZFRleHQgPSBcIlwiO1xuICAgIGxldCBsYXRlc3RPYmplY3QgPSB2b2lkIDA7XG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0odGhpcy5vcmlnaW5hbFN0cmVhbSwge1xuICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBhY2N1bXVsYXRlZFRleHQgKz0gY2h1bms7XG4gICAgICAgICAgY29uc3QgY3VycmVudE9iamVjdCA9IHBhcnNlUGFydGlhbEpzb24oXG4gICAgICAgICAgICBhY2N1bXVsYXRlZFRleHRcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmICghaXNEZWVwRXF1YWxEYXRhKGxhdGVzdE9iamVjdCwgY3VycmVudE9iamVjdCkpIHtcbiAgICAgICAgICAgIGxhdGVzdE9iamVjdCA9IGN1cnJlbnRPYmplY3Q7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY3VycmVudE9iamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNodW5rLnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgIHRocm93IGNodW5rLmVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0IGZ1bGxTdHJlYW0oKSB7XG4gICAgbGV0IGFjY3VtdWxhdGVkVGV4dCA9IFwiXCI7XG4gICAgbGV0IGxhdGVzdE9iamVjdCA9IHZvaWQgMDtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbSh0aGlzLm9yaWdpbmFsU3RyZWFtLCB7XG4gICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGFjY3VtdWxhdGVkVGV4dCArPSBjaHVuaztcbiAgICAgICAgICBjb25zdCBjdXJyZW50T2JqZWN0ID0gcGFyc2VQYXJ0aWFsSnNvbihcbiAgICAgICAgICAgIGFjY3VtdWxhdGVkVGV4dFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKCFpc0RlZXBFcXVhbERhdGEobGF0ZXN0T2JqZWN0LCBjdXJyZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgbGF0ZXN0T2JqZWN0ID0gY3VycmVudE9iamVjdDtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwib2JqZWN0XCIsIG9iamVjdDogY3VycmVudE9iamVjdCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgLi4uY2h1bmssXG4gICAgICAgICAgICAgICAgdXNhZ2U6IGNhbGN1bGF0ZVRva2VuVXNhZ2UoY2h1bmsudXNhZ2UpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBjb3JlL2dlbmVyYXRlLXRleHQvdG9vbC1jYWxsLnRzXG5pbXBvcnQge1xuICBJbnZhbGlkVG9vbEFyZ3VtZW50c0Vycm9yLFxuICBOb1N1Y2hUb29sRXJyb3Jcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7IHNhZmVQYXJzZUpTT04gYXMgc2FmZVBhcnNlSlNPTjIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuZnVuY3Rpb24gcGFyc2VUb29sQ2FsbCh7XG4gIHRvb2xDYWxsLFxuICB0b29sc1xufSkge1xuICBjb25zdCB0b29sTmFtZSA9IHRvb2xDYWxsLnRvb2xOYW1lO1xuICBpZiAodG9vbHMgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBOb1N1Y2hUb29sRXJyb3IoeyB0b29sTmFtZTogdG9vbENhbGwudG9vbE5hbWUgfSk7XG4gIH1cbiAgY29uc3QgdG9vbDIgPSB0b29sc1t0b29sTmFtZV07XG4gIGlmICh0b29sMiA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IE5vU3VjaFRvb2xFcnJvcih7XG4gICAgICB0b29sTmFtZTogdG9vbENhbGwudG9vbE5hbWUsXG4gICAgICBhdmFpbGFibGVUb29sczogT2JqZWN0LmtleXModG9vbHMpXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgcGFyc2VSZXN1bHQgPSBzYWZlUGFyc2VKU09OMih7XG4gICAgdGV4dDogdG9vbENhbGwuYXJncyxcbiAgICBzY2hlbWE6IHRvb2wyLnBhcmFtZXRlcnNcbiAgfSk7XG4gIGlmIChwYXJzZVJlc3VsdC5zdWNjZXNzID09PSBmYWxzZSkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkVG9vbEFyZ3VtZW50c0Vycm9yKHtcbiAgICAgIHRvb2xOYW1lLFxuICAgICAgdG9vbEFyZ3M6IHRvb2xDYWxsLmFyZ3MsXG4gICAgICBjYXVzZTogcGFyc2VSZXN1bHQuZXJyb3JcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidG9vbC1jYWxsXCIsXG4gICAgdG9vbENhbGxJZDogdG9vbENhbGwudG9vbENhbGxJZCxcbiAgICB0b29sTmFtZSxcbiAgICBhcmdzOiBwYXJzZVJlc3VsdC52YWx1ZVxuICB9O1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLXRleHQvZ2VuZXJhdGUtdGV4dC50c1xuYXN5bmMgZnVuY3Rpb24gZXhwZXJpbWVudGFsX2dlbmVyYXRlVGV4dCh7XG4gIG1vZGVsLFxuICB0b29scyxcbiAgc3lzdGVtLFxuICBwcm9tcHQsXG4gIG1lc3NhZ2VzLFxuICBtYXhSZXRyaWVzLFxuICBhYm9ydFNpZ25hbCxcbiAgLi4uc2V0dGluZ3Ncbn0pIHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgcmV0cnkgPSByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoeyBtYXhSZXRyaWVzIH0pO1xuICBjb25zdCB2YWxpZGF0ZWRQcm9tcHQgPSBnZXRWYWxpZGF0ZWRQcm9tcHQoeyBzeXN0ZW0sIHByb21wdCwgbWVzc2FnZXMgfSk7XG4gIGNvbnN0IG1vZGVsUmVzcG9uc2UgPSBhd2FpdCByZXRyeSgoKSA9PiB7XG4gICAgcmV0dXJuIG1vZGVsLmRvR2VuZXJhdGUoe1xuICAgICAgbW9kZToge1xuICAgICAgICB0eXBlOiBcInJlZ3VsYXJcIixcbiAgICAgICAgdG9vbHM6IHRvb2xzID09IG51bGwgPyB2b2lkIDAgOiBPYmplY3QuZW50cmllcyh0b29scykubWFwKChbbmFtZSwgdG9vbDJdKSA9PiAoe1xuICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiB0b29sMi5kZXNjcmlwdGlvbixcbiAgICAgICAgICBwYXJhbWV0ZXJzOiBjb252ZXJ0Wm9kVG9KU09OU2NoZW1hKHRvb2wyLnBhcmFtZXRlcnMpXG4gICAgICAgIH0pKVxuICAgICAgfSxcbiAgICAgIC4uLnByZXBhcmVDYWxsU2V0dGluZ3Moc2V0dGluZ3MpLFxuICAgICAgaW5wdXRGb3JtYXQ6IHZhbGlkYXRlZFByb21wdC50eXBlLFxuICAgICAgcHJvbXB0OiBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHZhbGlkYXRlZFByb21wdCksXG4gICAgICBhYm9ydFNpZ25hbFxuICAgIH0pO1xuICB9KTtcbiAgY29uc3QgdG9vbENhbGxzID0gW107XG4gIGZvciAoY29uc3QgbW9kZWxUb29sQ2FsbCBvZiAoX2EgPSBtb2RlbFJlc3BvbnNlLnRvb2xDYWxscykgIT0gbnVsbCA/IF9hIDogW10pIHtcbiAgICB0b29sQ2FsbHMucHVzaChwYXJzZVRvb2xDYWxsKHsgdG9vbENhbGw6IG1vZGVsVG9vbENhbGwsIHRvb2xzIH0pKTtcbiAgfVxuICBjb25zdCB0b29sUmVzdWx0cyA9IHRvb2xzID09IG51bGwgPyBbXSA6IGF3YWl0IGV4ZWN1dGVUb29scyh7IHRvb2xDYWxscywgdG9vbHMgfSk7XG4gIHJldHVybiBuZXcgR2VuZXJhdGVUZXh0UmVzdWx0KHtcbiAgICAvLyBBbHdheXMgcmV0dXJuIGEgc3RyaW5nIHNvIHRoYXQgdGhlIGNhbGxlciBkb2Vzbid0IGhhdmUgdG8gY2hlY2sgZm9yIHVuZGVmaW5lZC5cbiAgICAvLyBJZiB0aGV5IG5lZWQgdG8gY2hlY2sgaWYgdGhlIG1vZGVsIGRpZCBub3QgcmV0dXJuIGFueSB0ZXh0LFxuICAgIC8vIHRoZXkgY2FuIGNoZWNrIHRoZSBsZW5ndGggb2YgdGhlIHN0cmluZzpcbiAgICB0ZXh0OiAoX2IgPSBtb2RlbFJlc3BvbnNlLnRleHQpICE9IG51bGwgPyBfYiA6IFwiXCIsXG4gICAgdG9vbENhbGxzLFxuICAgIHRvb2xSZXN1bHRzLFxuICAgIGZpbmlzaFJlYXNvbjogbW9kZWxSZXNwb25zZS5maW5pc2hSZWFzb24sXG4gICAgdXNhZ2U6IGNhbGN1bGF0ZVRva2VuVXNhZ2UobW9kZWxSZXNwb25zZS51c2FnZSksXG4gICAgd2FybmluZ3M6IG1vZGVsUmVzcG9uc2Uud2FybmluZ3MsXG4gICAgcmF3UmVzcG9uc2U6IG1vZGVsUmVzcG9uc2UucmF3UmVzcG9uc2UsXG4gICAgbG9ncHJvYnM6IG1vZGVsUmVzcG9uc2UubG9ncHJvYnNcbiAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBleGVjdXRlVG9vbHMoe1xuICB0b29sQ2FsbHMsXG4gIHRvb2xzXG59KSB7XG4gIGNvbnN0IHRvb2xSZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgdG9vbENhbGxzLm1hcChhc3luYyAodG9vbENhbGwpID0+IHtcbiAgICAgIGNvbnN0IHRvb2wyID0gdG9vbHNbdG9vbENhbGwudG9vbE5hbWVdO1xuICAgICAgaWYgKCh0b29sMiA9PSBudWxsID8gdm9pZCAwIDogdG9vbDIuZXhlY3V0ZSkgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdG9vbDIuZXhlY3V0ZSh0b29sQ2FsbC5hcmdzKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvb2xDYWxsSWQ6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgICAgIHRvb2xOYW1lOiB0b29sQ2FsbC50b29sTmFtZSxcbiAgICAgICAgYXJnczogdG9vbENhbGwuYXJncyxcbiAgICAgICAgcmVzdWx0XG4gICAgICB9O1xuICAgIH0pXG4gICk7XG4gIHJldHVybiB0b29sUmVzdWx0cy5maWx0ZXIoXG4gICAgKHJlc3VsdCkgPT4gcmVzdWx0ICE9IG51bGxcbiAgKTtcbn1cbnZhciBHZW5lcmF0ZVRleHRSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLnRleHQgPSBvcHRpb25zLnRleHQ7XG4gICAgdGhpcy50b29sQ2FsbHMgPSBvcHRpb25zLnRvb2xDYWxscztcbiAgICB0aGlzLnRvb2xSZXN1bHRzID0gb3B0aW9ucy50b29sUmVzdWx0cztcbiAgICB0aGlzLmZpbmlzaFJlYXNvbiA9IG9wdGlvbnMuZmluaXNoUmVhc29uO1xuICAgIHRoaXMudXNhZ2UgPSBvcHRpb25zLnVzYWdlO1xuICAgIHRoaXMud2FybmluZ3MgPSBvcHRpb25zLndhcm5pbmdzO1xuICAgIHRoaXMucmF3UmVzcG9uc2UgPSBvcHRpb25zLnJhd1Jlc3BvbnNlO1xuICAgIHRoaXMubG9ncHJvYnMgPSBvcHRpb25zLmxvZ3Byb2JzO1xuICB9XG59O1xuXG4vLyBjb3JlL2dlbmVyYXRlLXRleHQvcnVuLXRvb2xzLXRyYW5zZm9ybWF0aW9uLnRzXG5pbXBvcnQgeyBOb1N1Y2hUb29sRXJyb3IgYXMgTm9TdWNoVG9vbEVycm9yMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5cbi8vIHNoYXJlZC9nZW5lcmF0ZS1pZC50c1xuaW1wb3J0IHsgY3VzdG9tQWxwaGFiZXQgfSBmcm9tIFwibmFub2lkL25vbi1zZWN1cmVcIjtcbnZhciBnZW5lcmF0ZUlkID0gY3VzdG9tQWxwaGFiZXQoXG4gIFwiMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIixcbiAgN1xuKTtcblxuLy8gY29yZS9nZW5lcmF0ZS10ZXh0L3J1bi10b29scy10cmFuc2Zvcm1hdGlvbi50c1xuZnVuY3Rpb24gcnVuVG9vbHNUcmFuc2Zvcm1hdGlvbih7XG4gIHRvb2xzLFxuICBnZW5lcmF0b3JTdHJlYW1cbn0pIHtcbiAgbGV0IGNhbkNsb3NlID0gZmFsc2U7XG4gIGNvbnN0IG91dHN0YW5kaW5nVG9vbENhbGxzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgbGV0IHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlciA9IG51bGw7XG4gIGNvbnN0IHRvb2xSZXN1bHRzU3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGZvcndhcmRTdHJlYW0gPSBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnN0IGNodW5rVHlwZSA9IGNodW5rLnR5cGU7XG4gICAgICBzd2l0Y2ggKGNodW5rVHlwZSkge1xuICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOlxuICAgICAgICBjYXNlIFwiZXJyb3JcIjoge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInRvb2wtY2FsbFwiOiB7XG4gICAgICAgICAgY29uc3QgdG9vbE5hbWUgPSBjaHVuay50b29sTmFtZTtcbiAgICAgICAgICBpZiAodG9vbHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgIGVycm9yOiBuZXcgTm9TdWNoVG9vbEVycm9yMih7IHRvb2xOYW1lOiBjaHVuay50b29sTmFtZSB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdG9vbDIgPSB0b29sc1t0b29sTmFtZV07XG4gICAgICAgICAgaWYgKHRvb2wyID09IG51bGwpIHtcbiAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICBlcnJvcjogbmV3IE5vU3VjaFRvb2xFcnJvcjIoe1xuICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBjaHVuay50b29sTmFtZSxcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVUb29sczogT2JqZWN0LmtleXModG9vbHMpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdG9vbENhbGwgPSBwYXJzZVRvb2xDYWxsKHtcbiAgICAgICAgICAgICAgdG9vbENhbGw6IGNodW5rLFxuICAgICAgICAgICAgICB0b29sc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodG9vbENhbGwpO1xuICAgICAgICAgICAgaWYgKHRvb2wyLmV4ZWN1dGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBjb25zdCB0b29sRXhlY3V0aW9uSWQgPSBnZW5lcmF0ZUlkKCk7XG4gICAgICAgICAgICAgIG91dHN0YW5kaW5nVG9vbENhbGxzLmFkZCh0b29sRXhlY3V0aW9uSWQpO1xuICAgICAgICAgICAgICB0b29sMi5leGVjdXRlKHRvb2xDYWxsLmFyZ3MpLnRoZW4oXG4gICAgICAgICAgICAgICAgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAuLi50b29sQ2FsbCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHRcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgb3V0c3RhbmRpbmdUb29sQ2FsbHMuZGVsZXRlKHRvb2xFeGVjdXRpb25JZCk7XG4gICAgICAgICAgICAgICAgICBpZiAoY2FuQ2xvc2UgJiYgb3V0c3RhbmRpbmdUb29sQ2FsbHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIG91dHN0YW5kaW5nVG9vbENhbGxzLmRlbGV0ZSh0b29sRXhlY3V0aW9uSWQpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNhbkNsb3NlICYmIG91dHN0YW5kaW5nVG9vbENhbGxzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZmluaXNoXCI6IHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgdHlwZTogXCJmaW5pc2hcIixcbiAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogY2h1bmsuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgbG9ncHJvYnM6IGNodW5rLmxvZ3Byb2JzLFxuICAgICAgICAgICAgdXNhZ2U6IGNhbGN1bGF0ZVRva2VuVXNhZ2UoY2h1bmsudXNhZ2UpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInRvb2wtY2FsbC1kZWx0YVwiOiB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSBjaHVua1R5cGU7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmhhbmRsZWQgY2h1bmsgdHlwZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBmbHVzaCgpIHtcbiAgICAgIGNhbkNsb3NlID0gdHJ1ZTtcbiAgICAgIGlmIChvdXRzdGFuZGluZ1Rvb2xDYWxscy5zaXplID09PSAwKSB7XG4gICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgIGdlbmVyYXRvclN0cmVhbS5waXBlVGhyb3VnaChmb3J3YXJkU3RyZWFtKS5waXBlVG8oXG4gICAgICAgICAgbmV3IFdyaXRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgIHdyaXRlKGNodW5rKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvc2UoKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKSxcbiAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW0ucGlwZVRvKFxuICAgICAgICAgIG5ldyBXcml0YWJsZVN0cmVhbSh7XG4gICAgICAgICAgICB3cml0ZShjaHVuaykge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsb3NlKCkge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgXSk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS10ZXh0L3N0cmVhbS10ZXh0LnRzXG5hc3luYyBmdW5jdGlvbiBleHBlcmltZW50YWxfc3RyZWFtVGV4dCh7XG4gIG1vZGVsLFxuICB0b29scyxcbiAgc3lzdGVtLFxuICBwcm9tcHQsXG4gIG1lc3NhZ2VzLFxuICBtYXhSZXRyaWVzLFxuICBhYm9ydFNpZ25hbCxcbiAgLi4uc2V0dGluZ3Ncbn0pIHtcbiAgY29uc3QgcmV0cnkgPSByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoeyBtYXhSZXRyaWVzIH0pO1xuICBjb25zdCB2YWxpZGF0ZWRQcm9tcHQgPSBnZXRWYWxpZGF0ZWRQcm9tcHQoeyBzeXN0ZW0sIHByb21wdCwgbWVzc2FnZXMgfSk7XG4gIGNvbnN0IHsgc3RyZWFtLCB3YXJuaW5ncywgcmF3UmVzcG9uc2UgfSA9IGF3YWl0IHJldHJ5KFxuICAgICgpID0+IG1vZGVsLmRvU3RyZWFtKHtcbiAgICAgIG1vZGU6IHtcbiAgICAgICAgdHlwZTogXCJyZWd1bGFyXCIsXG4gICAgICAgIHRvb2xzOiB0b29scyA9PSBudWxsID8gdm9pZCAwIDogT2JqZWN0LmVudHJpZXModG9vbHMpLm1hcCgoW25hbWUsIHRvb2wyXSkgPT4gKHtcbiAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogdG9vbDIuZGVzY3JpcHRpb24sXG4gICAgICAgICAgcGFyYW1ldGVyczogY29udmVydFpvZFRvSlNPTlNjaGVtYSh0b29sMi5wYXJhbWV0ZXJzKVxuICAgICAgICB9KSlcbiAgICAgIH0sXG4gICAgICAuLi5wcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKSxcbiAgICAgIGlucHV0Rm9ybWF0OiB2YWxpZGF0ZWRQcm9tcHQudHlwZSxcbiAgICAgIHByb21wdDogY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh2YWxpZGF0ZWRQcm9tcHQpLFxuICAgICAgYWJvcnRTaWduYWxcbiAgICB9KVxuICApO1xuICByZXR1cm4gbmV3IFN0cmVhbVRleHRSZXN1bHQoe1xuICAgIHN0cmVhbTogcnVuVG9vbHNUcmFuc2Zvcm1hdGlvbih7XG4gICAgICB0b29scyxcbiAgICAgIGdlbmVyYXRvclN0cmVhbTogc3RyZWFtXG4gICAgfSksXG4gICAgd2FybmluZ3MsXG4gICAgcmF3UmVzcG9uc2VcbiAgfSk7XG59XG52YXIgU3RyZWFtVGV4dFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHN0cmVhbSxcbiAgICB3YXJuaW5ncyxcbiAgICByYXdSZXNwb25zZVxuICB9KSB7XG4gICAgdGhpcy5vcmlnaW5hbFN0cmVhbSA9IHN0cmVhbTtcbiAgICB0aGlzLndhcm5pbmdzID0gd2FybmluZ3M7XG4gICAgdGhpcy5yYXdSZXNwb25zZSA9IHJhd1Jlc3BvbnNlO1xuICB9XG4gIC8qKlxuICBBIHRleHQgc3RyZWFtIHRoYXQgcmV0dXJucyBvbmx5IHRoZSBnZW5lcmF0ZWQgdGV4dCBkZWx0YXMuIFlvdSBjYW4gdXNlIGl0XG4gIGFzIGVpdGhlciBhbiBBc3luY0l0ZXJhYmxlIG9yIGEgUmVhZGFibGVTdHJlYW0uIFdoZW4gYW4gZXJyb3Igb2NjdXJzLCB0aGVcbiAgc3RyZWFtIHdpbGwgdGhyb3cgdGhlIGVycm9yLlxuICAgICAqL1xuICBnZXQgdGV4dFN0cmVhbSgpIHtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbSh0aGlzLm9yaWdpbmFsU3RyZWFtLCB7XG4gICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgaWYgKGNodW5rLnR5cGUgPT09IFwidGV4dC1kZWx0YVwiKSB7XG4gICAgICAgICAgaWYgKGNodW5rLnRleHREZWx0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmsudGV4dERlbHRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY2h1bmsudHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgdGhyb3cgY2h1bmsuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgQSBzdHJlYW0gd2l0aCBhbGwgZXZlbnRzLCBpbmNsdWRpbmcgdGV4dCBkZWx0YXMsIHRvb2wgY2FsbHMsIHRvb2wgcmVzdWx0cywgYW5kXG4gIGVycm9ycy5cbiAgWW91IGNhbiB1c2UgaXQgYXMgZWl0aGVyIGFuIEFzeW5jSXRlcmFibGUgb3IgYSBSZWFkYWJsZVN0cmVhbS4gV2hlbiBhbiBlcnJvciBvY2N1cnMsIHRoZVxuICBzdHJlYW0gd2lsbCB0aHJvdyB0aGUgZXJyb3IuXG4gICAgICovXG4gIGdldCBmdWxsU3RyZWFtKCkge1xuICAgIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKHRoaXMub3JpZ2luYWxTdHJlYW0sIHtcbiAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJ0ZXh0LWRlbHRhXCIpIHtcbiAgICAgICAgICBpZiAoY2h1bmsudGV4dERlbHRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgQ29udmVydHMgdGhlIHJlc3VsdCB0byBhbiBgQUlTdHJlYW1gIG9iamVjdCB0aGF0IGlzIGNvbXBhdGlibGUgd2l0aCBgU3RyZWFtaW5nVGV4dFJlc3BvbnNlYC5cbiAgSXQgY2FuIGJlIHVzZWQgd2l0aCB0aGUgYHVzZUNoYXRgIGFuZCBgdXNlQ29tcGxldGlvbmAgaG9va3MuXG4gIFxuICBAcGFyYW0gY2FsbGJhY2tzIFxuICBTdHJlYW0gY2FsbGJhY2tzIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgc3RyZWFtIGVtaXRzIGV2ZW50cy5cbiAgXG4gIEByZXR1cm5zIGFuIGBBSVN0cmVhbWAgb2JqZWN0LlxuICAgICAqL1xuICB0b0FJU3RyZWFtKGNhbGxiYWNrcykge1xuICAgIHJldHVybiB0aGlzLnRleHRTdHJlYW0ucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSkucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkpO1xuICB9XG4gIC8qKlxuICBXcml0ZXMgc3RyZWFtIGRhdGEgb3V0cHV0IHRvIGEgTm9kZS5qcyByZXNwb25zZS1saWtlIG9iamVjdC5cbiAgSXQgc2V0cyBhIGBDb250ZW50LVR5cGVgIGhlYWRlciB0byBgdGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOGAgYW5kIFxuICB3cml0ZXMgZWFjaCBzdHJlYW0gZGF0YSBwYXJ0IGFzIGEgc2VwYXJhdGUgY2h1bmsuXG4gIFxuICBAcGFyYW0gcmVzcG9uc2UgQSBOb2RlLmpzIHJlc3BvbnNlLWxpa2Ugb2JqZWN0IChTZXJ2ZXJSZXNwb25zZSkuXG4gIEBwYXJhbSBpbml0IE9wdGlvbmFsIGhlYWRlcnMgYW5kIHN0YXR1cyBjb2RlLlxuICAgICAqL1xuICBwaXBlQUlTdHJlYW1Ub1Jlc3BvbnNlKHJlc3BvbnNlLCBpbml0KSB7XG4gICAgdmFyIF9hO1xuICAgIHJlc3BvbnNlLndyaXRlSGVhZCgoX2EgPSBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cykgIT0gbnVsbCA/IF9hIDogMjAwLCB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIixcbiAgICAgIC4uLmluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuaGVhZGVyc1xuICAgIH0pO1xuICAgIGNvbnN0IHJlYWRlciA9IHRoaXMudGV4dFN0cmVhbS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcih2b2lkIDApKS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSkuZ2V0UmVhZGVyKCk7XG4gICAgY29uc3QgcmVhZCA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIHJlc3BvbnNlLndyaXRlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICByZXNwb25zZS5lbmQoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJlYWQoKTtcbiAgfVxuICAvKipcbiAgV3JpdGVzIHRleHQgZGVsdGEgb3V0cHV0IHRvIGEgTm9kZS5qcyByZXNwb25zZS1saWtlIG9iamVjdC5cbiAgSXQgc2V0cyBhIGBDb250ZW50LVR5cGVgIGhlYWRlciB0byBgdGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOGAgYW5kIFxuICB3cml0ZXMgZWFjaCB0ZXh0IGRlbHRhIGFzIGEgc2VwYXJhdGUgY2h1bmsuXG4gIFxuICBAcGFyYW0gcmVzcG9uc2UgQSBOb2RlLmpzIHJlc3BvbnNlLWxpa2Ugb2JqZWN0IChTZXJ2ZXJSZXNwb25zZSkuXG4gIEBwYXJhbSBpbml0IE9wdGlvbmFsIGhlYWRlcnMgYW5kIHN0YXR1cyBjb2RlLlxuICAgICAqL1xuICBwaXBlVGV4dFN0cmVhbVRvUmVzcG9uc2UocmVzcG9uc2UsIGluaXQpIHtcbiAgICB2YXIgX2E7XG4gICAgcmVzcG9uc2Uud3JpdGVIZWFkKChfYSA9IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzKSAhPSBudWxsID8gX2EgOiAyMDAsIHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiLFxuICAgICAgLi4uaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5oZWFkZXJzXG4gICAgfSk7XG4gICAgY29uc3QgcmVhZGVyID0gdGhpcy50ZXh0U3RyZWFtLmdldFJlYWRlcigpO1xuICAgIGNvbnN0IHJlYWQgPSBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICB0cnkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICByZXNwb25zZS53cml0ZShlbmNvZGVyLmVuY29kZSh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHJlc3BvbnNlLmVuZCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmVhZCgpO1xuICB9XG4gIC8qKlxuICBDb252ZXJ0cyB0aGUgcmVzdWx0IHRvIGEgc3RyZWFtZWQgcmVzcG9uc2Ugb2JqZWN0IHdpdGggYSBzdHJlYW0gZGF0YSBwYXJ0IHN0cmVhbS5cbiAgSXQgY2FuIGJlIHVzZWQgd2l0aCB0aGUgYHVzZUNoYXRgIGFuZCBgdXNlQ29tcGxldGlvbmAgaG9va3MuXG4gIFxuICBAcGFyYW0gaW5pdCBPcHRpb25hbCBoZWFkZXJzLlxuICBcbiAgQHJldHVybiBBIHJlc3BvbnNlIG9iamVjdC5cbiAgICAgKi9cbiAgdG9BSVN0cmVhbVJlc3BvbnNlKGluaXQpIHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbWluZ1RleHRSZXNwb25zZSh0aGlzLnRvQUlTdHJlYW0oKSwgaW5pdCk7XG4gIH1cbiAgLyoqXG4gIENyZWF0ZXMgYSBzaW1wbGUgdGV4dCBzdHJlYW0gcmVzcG9uc2UuXG4gIEVhY2ggdGV4dCBkZWx0YSBpcyBlbmNvZGVkIGFzIFVURi04IGFuZCBzZW50IGFzIGEgc2VwYXJhdGUgY2h1bmsuXG4gIE5vbi10ZXh0LWRlbHRhIGV2ZW50cyBhcmUgaWdub3JlZC5cbiAgXG4gIEBwYXJhbSBpbml0IE9wdGlvbmFsIGhlYWRlcnMgYW5kIHN0YXR1cyBjb2RlLlxuICAgICAqL1xuICB0b1RleHRTdHJlYW1SZXNwb25zZShpbml0KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKFxuICAgICAgdGhpcy50ZXh0U3RyZWFtLnBpcGVUaHJvdWdoKFxuICAgICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVyLmVuY29kZShjaHVuaykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICksXG4gICAgICB7XG4gICAgICAgIHN0YXR1czogKF9hID0gaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXMpICE9IG51bGwgPyBfYSA6IDIwMCxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiLFxuICAgICAgICAgIC4uLmluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuaGVhZGVyc1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgfVxufTtcblxuLy8gY29yZS90b29sL3Rvb2wudHNcbmZ1bmN0aW9uIHRvb2wodG9vbDIpIHtcbiAgcmV0dXJuIHRvb2wyO1xufVxuXG4vLyBjb3JlL3R5cGVzL2Vycm9ycy50c1xuaW1wb3J0IHtcbiAgQVBJQ2FsbEVycm9yIGFzIEFQSUNhbGxFcnJvcjIsXG4gIEVtcHR5UmVzcG9uc2VCb2R5RXJyb3IsXG4gIEludmFsaWRBcmd1bWVudEVycm9yIGFzIEludmFsaWRBcmd1bWVudEVycm9yMixcbiAgSW52YWxpZERhdGFDb250ZW50RXJyb3IgYXMgSW52YWxpZERhdGFDb250ZW50RXJyb3IyLFxuICBJbnZhbGlkUHJvbXB0RXJyb3IgYXMgSW52YWxpZFByb21wdEVycm9yMixcbiAgSW52YWxpZFJlc3BvbnNlRGF0YUVycm9yLFxuICBJbnZhbGlkVG9vbEFyZ3VtZW50c0Vycm9yIGFzIEludmFsaWRUb29sQXJndW1lbnRzRXJyb3IyLFxuICBKU09OUGFyc2VFcnJvcixcbiAgTG9hZEFQSUtleUVycm9yLFxuICBOb09iamVjdEdlbmVyYXRlZEVycm9yIGFzIE5vT2JqZWN0R2VuZXJhdGVkRXJyb3IyLFxuICBOb1N1Y2hUb29sRXJyb3IgYXMgTm9TdWNoVG9vbEVycm9yMyxcbiAgUmV0cnlFcnJvciBhcyBSZXRyeUVycm9yMixcbiAgVG9vbENhbGxQYXJzZUVycm9yLFxuICBUeXBlVmFsaWRhdGlvbkVycm9yLFxuICBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcixcbiAgVW5zdXBwb3J0ZWRKU09OU2NoZW1hRXJyb3Jcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcblxuLy8gc2hhcmVkL3N0cmVhbS1wYXJ0cy50c1xudmFyIHRleHRTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjBcIixcbiAgbmFtZTogXCJ0ZXh0XCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1widGV4dFwiIHBhcnRzIGV4cGVjdCBhIHN0cmluZyB2YWx1ZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlIH07XG4gIH1cbn07XG52YXIgZnVuY3Rpb25DYWxsU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCIxXCIsXG4gIG5hbWU6IFwiZnVuY3Rpb25fY2FsbFwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJmdW5jdGlvbl9jYWxsXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5mdW5jdGlvbl9jYWxsICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlLmZ1bmN0aW9uX2NhbGwgPT0gbnVsbCB8fCAhKFwibmFtZVwiIGluIHZhbHVlLmZ1bmN0aW9uX2NhbGwpIHx8ICEoXCJhcmd1bWVudHNcIiBpbiB2YWx1ZS5mdW5jdGlvbl9jYWxsKSB8fCB0eXBlb2YgdmFsdWUuZnVuY3Rpb25fY2FsbC5uYW1lICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZS5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50cyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJmdW5jdGlvbl9jYWxsXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJmdW5jdGlvbl9jYWxsXCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZnVuY3Rpb25fY2FsbFwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG59O1xudmFyIGRhdGFTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjJcIixcbiAgbmFtZTogXCJkYXRhXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiZGF0YVwiIHBhcnRzIGV4cGVjdCBhbiBhcnJheSB2YWx1ZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJkYXRhXCIsIHZhbHVlIH07XG4gIH1cbn07XG52YXIgZXJyb3JTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjNcIixcbiAgbmFtZTogXCJlcnJvclwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImVycm9yXCIgcGFydHMgZXhwZWN0IGEgc3RyaW5nIHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHZhbHVlIH07XG4gIH1cbn07XG52YXIgYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiNFwiLFxuICBuYW1lOiBcImFzc2lzdGFudF9tZXNzYWdlXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcImlkXCIgaW4gdmFsdWUpIHx8ICEoXCJyb2xlXCIgaW4gdmFsdWUpIHx8ICEoXCJjb250ZW50XCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5pZCAhPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUucm9sZSAhPT0gXCJzdHJpbmdcIiB8fCB2YWx1ZS5yb2xlICE9PSBcImFzc2lzdGFudFwiIHx8ICFBcnJheS5pc0FycmF5KHZhbHVlLmNvbnRlbnQpIHx8ICF2YWx1ZS5jb250ZW50LmV2ZXJ5KFxuICAgICAgKGl0ZW0pID0+IGl0ZW0gIT0gbnVsbCAmJiB0eXBlb2YgaXRlbSA9PT0gXCJvYmplY3RcIiAmJiBcInR5cGVcIiBpbiBpdGVtICYmIGl0ZW0udHlwZSA9PT0gXCJ0ZXh0XCIgJiYgXCJ0ZXh0XCIgaW4gaXRlbSAmJiBpdGVtLnRleHQgIT0gbnVsbCAmJiB0eXBlb2YgaXRlbS50ZXh0ID09PSBcIm9iamVjdFwiICYmIFwidmFsdWVcIiBpbiBpdGVtLnRleHQgJiYgdHlwZW9mIGl0ZW0udGV4dC52YWx1ZSA9PT0gXCJzdHJpbmdcIlxuICAgICkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiYXNzaXN0YW50X21lc3NhZ2VcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYW4gXCJpZFwiLCBcInJvbGVcIiwgYW5kIFwiY29udGVudFwiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImFzc2lzdGFudF9tZXNzYWdlXCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbn07XG52YXIgYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjVcIixcbiAgbmFtZTogXCJhc3Npc3RhbnRfY29udHJvbF9kYXRhXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcInRocmVhZElkXCIgaW4gdmFsdWUpIHx8ICEoXCJtZXNzYWdlSWRcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLnRocmVhZElkICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZS5tZXNzYWdlSWQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiYXNzaXN0YW50X2NvbnRyb2xfZGF0YVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwidGhyZWFkSWRcIiBhbmQgXCJtZXNzYWdlSWRcIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJhc3Npc3RhbnRfY29udHJvbF9kYXRhXCIsXG4gICAgICB2YWx1ZToge1xuICAgICAgICB0aHJlYWRJZDogdmFsdWUudGhyZWFkSWQsXG4gICAgICAgIG1lc3NhZ2VJZDogdmFsdWUubWVzc2FnZUlkXG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcbnZhciBkYXRhTWVzc2FnZVN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiNlwiLFxuICBuYW1lOiBcImRhdGFfbWVzc2FnZVwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJyb2xlXCIgaW4gdmFsdWUpIHx8ICEoXCJkYXRhXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5yb2xlICE9PSBcInN0cmluZ1wiIHx8IHZhbHVlLnJvbGUgIT09IFwiZGF0YVwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImRhdGFfbWVzc2FnZVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwicm9sZVwiIGFuZCBcImRhdGFcIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJkYXRhX21lc3NhZ2VcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxufTtcbnZhciB0b29sQ2FsbFN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiN1wiLFxuICBuYW1lOiBcInRvb2xfY2FsbHNcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwidG9vbF9jYWxsc1wiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUudG9vbF9jYWxscyAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZS50b29sX2NhbGxzID09IG51bGwgfHwgIUFycmF5LmlzQXJyYXkodmFsdWUudG9vbF9jYWxscykgfHwgdmFsdWUudG9vbF9jYWxscy5zb21lKFxuICAgICAgKHRjKSA9PiB0YyA9PSBudWxsIHx8IHR5cGVvZiB0YyAhPT0gXCJvYmplY3RcIiB8fCAhKFwiaWRcIiBpbiB0YykgfHwgdHlwZW9mIHRjLmlkICE9PSBcInN0cmluZ1wiIHx8ICEoXCJ0eXBlXCIgaW4gdGMpIHx8IHR5cGVvZiB0Yy50eXBlICE9PSBcInN0cmluZ1wiIHx8ICEoXCJmdW5jdGlvblwiIGluIHRjKSB8fCB0Yy5mdW5jdGlvbiA9PSBudWxsIHx8IHR5cGVvZiB0Yy5mdW5jdGlvbiAhPT0gXCJvYmplY3RcIiB8fCAhKFwiYXJndW1lbnRzXCIgaW4gdGMuZnVuY3Rpb24pIHx8IHR5cGVvZiB0Yy5mdW5jdGlvbi5uYW1lICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB0Yy5mdW5jdGlvbi5hcmd1bWVudHMgIT09IFwic3RyaW5nXCJcbiAgICApKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcInRvb2xfY2FsbHNcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBUb29sQ2FsbFBheWxvYWQuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidG9vbF9jYWxsc1wiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG59O1xudmFyIG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiOFwiLFxuICBuYW1lOiBcIm1lc3NhZ2VfYW5ub3RhdGlvbnNcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJtZXNzYWdlX2Fubm90YXRpb25zXCIgcGFydHMgZXhwZWN0IGFuIGFycmF5IHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcIm1lc3NhZ2VfYW5ub3RhdGlvbnNcIiwgdmFsdWUgfTtcbiAgfVxufTtcbnZhciBzdHJlYW1QYXJ0cyA9IFtcbiAgdGV4dFN0cmVhbVBhcnQsXG4gIGZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQsXG4gIGRhdGFTdHJlYW1QYXJ0LFxuICBlcnJvclN0cmVhbVBhcnQsXG4gIGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0LFxuICBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQsXG4gIGRhdGFNZXNzYWdlU3RyZWFtUGFydCxcbiAgdG9vbENhbGxTdHJlYW1QYXJ0LFxuICBtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0XG5dO1xudmFyIHN0cmVhbVBhcnRzQnlDb2RlID0ge1xuICBbdGV4dFN0cmVhbVBhcnQuY29kZV06IHRleHRTdHJlYW1QYXJ0LFxuICBbZnVuY3Rpb25DYWxsU3RyZWFtUGFydC5jb2RlXTogZnVuY3Rpb25DYWxsU3RyZWFtUGFydCxcbiAgW2RhdGFTdHJlYW1QYXJ0LmNvZGVdOiBkYXRhU3RyZWFtUGFydCxcbiAgW2Vycm9yU3RyZWFtUGFydC5jb2RlXTogZXJyb3JTdHJlYW1QYXJ0LFxuICBbYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQuY29kZV06IGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0LFxuICBbYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0LmNvZGVdOiBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQsXG4gIFtkYXRhTWVzc2FnZVN0cmVhbVBhcnQuY29kZV06IGRhdGFNZXNzYWdlU3RyZWFtUGFydCxcbiAgW3Rvb2xDYWxsU3RyZWFtUGFydC5jb2RlXTogdG9vbENhbGxTdHJlYW1QYXJ0LFxuICBbbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydC5jb2RlXTogbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydFxufTtcbnZhciBTdHJlYW1TdHJpbmdQcmVmaXhlcyA9IHtcbiAgW3RleHRTdHJlYW1QYXJ0Lm5hbWVdOiB0ZXh0U3RyZWFtUGFydC5jb2RlLFxuICBbZnVuY3Rpb25DYWxsU3RyZWFtUGFydC5uYW1lXTogZnVuY3Rpb25DYWxsU3RyZWFtUGFydC5jb2RlLFxuICBbZGF0YVN0cmVhbVBhcnQubmFtZV06IGRhdGFTdHJlYW1QYXJ0LmNvZGUsXG4gIFtlcnJvclN0cmVhbVBhcnQubmFtZV06IGVycm9yU3RyZWFtUGFydC5jb2RlLFxuICBbYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQubmFtZV06IGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0LmNvZGUsXG4gIFthc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQubmFtZV06IGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydC5jb2RlLFxuICBbZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0Lm5hbWVdOiBkYXRhTWVzc2FnZVN0cmVhbVBhcnQuY29kZSxcbiAgW3Rvb2xDYWxsU3RyZWFtUGFydC5uYW1lXTogdG9vbENhbGxTdHJlYW1QYXJ0LmNvZGUsXG4gIFttZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0Lm5hbWVdOiBtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0LmNvZGVcbn07XG52YXIgdmFsaWRDb2RlcyA9IHN0cmVhbVBhcnRzLm1hcCgocGFydCkgPT4gcGFydC5jb2RlKTtcbnZhciBwYXJzZVN0cmVhbVBhcnQgPSAobGluZSkgPT4ge1xuICBjb25zdCBmaXJzdFNlcGFyYXRvckluZGV4ID0gbGluZS5pbmRleE9mKFwiOlwiKTtcbiAgaWYgKGZpcnN0U2VwYXJhdG9ySW5kZXggPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIHN0cmVhbSBzdHJpbmcuIE5vIHNlcGFyYXRvciBmb3VuZC5cIik7XG4gIH1cbiAgY29uc3QgcHJlZml4ID0gbGluZS5zbGljZSgwLCBmaXJzdFNlcGFyYXRvckluZGV4KTtcbiAgaWYgKCF2YWxpZENvZGVzLmluY2x1ZGVzKHByZWZpeCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBzdHJlYW0gc3RyaW5nLiBJbnZhbGlkIGNvZGUgJHtwcmVmaXh9LmApO1xuICB9XG4gIGNvbnN0IGNvZGUgPSBwcmVmaXg7XG4gIGNvbnN0IHRleHRWYWx1ZSA9IGxpbmUuc2xpY2UoZmlyc3RTZXBhcmF0b3JJbmRleCArIDEpO1xuICBjb25zdCBqc29uVmFsdWUgPSBKU09OLnBhcnNlKHRleHRWYWx1ZSk7XG4gIHJldHVybiBzdHJlYW1QYXJ0c0J5Q29kZVtjb2RlXS5wYXJzZShqc29uVmFsdWUpO1xufTtcbmZ1bmN0aW9uIGZvcm1hdFN0cmVhbVBhcnQodHlwZSwgdmFsdWUpIHtcbiAgY29uc3Qgc3RyZWFtUGFydCA9IHN0cmVhbVBhcnRzLmZpbmQoKHBhcnQpID0+IHBhcnQubmFtZSA9PT0gdHlwZSk7XG4gIGlmICghc3RyZWFtUGFydCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzdHJlYW0gcGFydCB0eXBlOiAke3R5cGV9YCk7XG4gIH1cbiAgcmV0dXJuIGAke3N0cmVhbVBhcnQuY29kZX06JHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9XG5gO1xufVxuXG4vLyBzaGFyZWQvcmVhZC1kYXRhLXN0cmVhbS50c1xudmFyIE5FV0xJTkUgPSBcIlxcblwiLmNoYXJDb2RlQXQoMCk7XG5mdW5jdGlvbiBjb25jYXRDaHVua3MoY2h1bmtzLCB0b3RhbExlbmd0aCkge1xuICBjb25zdCBjb25jYXRlbmF0ZWRDaHVua3MgPSBuZXcgVWludDhBcnJheSh0b3RhbExlbmd0aCk7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBmb3IgKGNvbnN0IGNodW5rIG9mIGNodW5rcykge1xuICAgIGNvbmNhdGVuYXRlZENodW5rcy5zZXQoY2h1bmssIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IGNodW5rLmxlbmd0aDtcbiAgfVxuICBjaHVua3MubGVuZ3RoID0gMDtcbiAgcmV0dXJuIGNvbmNhdGVuYXRlZENodW5rcztcbn1cbmFzeW5jIGZ1bmN0aW9uKiByZWFkRGF0YVN0cmVhbShyZWFkZXIsIHtcbiAgaXNBYm9ydGVkXG59ID0ge30pIHtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICBjb25zdCBjaHVua3MgPSBbXTtcbiAgbGV0IHRvdGFsTGVuZ3RoID0gMDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCB7IHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgY2h1bmtzLnB1c2godmFsdWUpO1xuICAgICAgdG90YWxMZW5ndGggKz0gdmFsdWUubGVuZ3RoO1xuICAgICAgaWYgKHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdICE9PSBORVdMSU5FKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2h1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IGNvbmNhdGVuYXRlZENodW5rcyA9IGNvbmNhdENodW5rcyhjaHVua3MsIHRvdGFsTGVuZ3RoKTtcbiAgICB0b3RhbExlbmd0aCA9IDA7XG4gICAgY29uc3Qgc3RyZWFtUGFydHMyID0gZGVjb2Rlci5kZWNvZGUoY29uY2F0ZW5hdGVkQ2h1bmtzLCB7IHN0cmVhbTogdHJ1ZSB9KS5zcGxpdChcIlxcblwiKS5maWx0ZXIoKGxpbmUpID0+IGxpbmUgIT09IFwiXCIpLm1hcChwYXJzZVN0cmVhbVBhcnQpO1xuICAgIGZvciAoY29uc3Qgc3RyZWFtUGFydCBvZiBzdHJlYW1QYXJ0czIpIHtcbiAgICAgIHlpZWxkIHN0cmVhbVBhcnQ7XG4gICAgfVxuICAgIGlmIChpc0Fib3J0ZWQgPT0gbnVsbCA/IHZvaWQgMCA6IGlzQWJvcnRlZCgpKSB7XG4gICAgICByZWFkZXIuY2FuY2VsKCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuLy8gc2hhcmVkL3V0aWxzLnRzXG5mdW5jdGlvbiBjcmVhdGVDaHVua0RlY29kZXIoY29tcGxleCkge1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIGlmICghY29tcGxleCkge1xuICAgIHJldHVybiBmdW5jdGlvbihjaHVuaykge1xuICAgICAgaWYgKCFjaHVuaylcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGUoY2h1bmssIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgY29uc3QgZGVjb2RlZCA9IGRlY29kZXIuZGVjb2RlKGNodW5rLCB7IHN0cmVhbTogdHJ1ZSB9KS5zcGxpdChcIlxcblwiKS5maWx0ZXIoKGxpbmUpID0+IGxpbmUgIT09IFwiXCIpO1xuICAgIHJldHVybiBkZWNvZGVkLm1hcChwYXJzZVN0cmVhbVBhcnQpLmZpbHRlcihCb29sZWFuKTtcbiAgfTtcbn1cbnZhciBpc1N0cmVhbVN0cmluZ0VxdWFsVG9UeXBlID0gKHR5cGUsIHZhbHVlKSA9PiB2YWx1ZS5zdGFydHNXaXRoKGAke1N0cmVhbVN0cmluZ1ByZWZpeGVzW3R5cGVdfTpgKSAmJiB2YWx1ZS5lbmRzV2l0aChcIlxcblwiKTtcblxuLy8gc3RyZWFtcy9haS1zdHJlYW0udHNcbmltcG9ydCB7XG4gIGNyZWF0ZVBhcnNlclxufSBmcm9tIFwiZXZlbnRzb3VyY2UtcGFyc2VyXCI7XG5mdW5jdGlvbiBjcmVhdGVFdmVudFN0cmVhbVRyYW5zZm9ybWVyKGN1c3RvbVBhcnNlcikge1xuICBjb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICBsZXQgZXZlbnRTb3VyY2VQYXJzZXI7XG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICBldmVudFNvdXJjZVBhcnNlciA9IGNyZWF0ZVBhcnNlcihcbiAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgaWYgKFwiZGF0YVwiIGluIGV2ZW50ICYmIGV2ZW50LnR5cGUgPT09IFwiZXZlbnRcIiAmJiBldmVudC5kYXRhID09PSBcIltET05FXVwiIHx8IC8vIFJlcGxpY2F0ZSBkb2Vzbid0IHNlbmQgW0RPTkVdIGJ1dCBkb2VzIHNlbmQgYSAnZG9uZScgZXZlbnRcbiAgICAgICAgICAvLyBAc2VlIGh0dHBzOi8vcmVwbGljYXRlLmNvbS9kb2NzL3N0cmVhbWluZ1xuICAgICAgICAgIGV2ZW50LmV2ZW50ID09PSBcImRvbmVcIikge1xuICAgICAgICAgICAgY29udHJvbGxlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFwiZGF0YVwiIGluIGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRNZXNzYWdlID0gY3VzdG9tUGFyc2VyID8gY3VzdG9tUGFyc2VyKGV2ZW50LmRhdGEsIHtcbiAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LmV2ZW50XG4gICAgICAgICAgICB9KSA6IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBpZiAocGFyc2VkTWVzc2FnZSlcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHBhcnNlZE1lc3NhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9LFxuICAgIHRyYW5zZm9ybShjaHVuaykge1xuICAgICAgZXZlbnRTb3VyY2VQYXJzZXIuZmVlZCh0ZXh0RGVjb2Rlci5kZWNvZGUoY2h1bmspKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2IpIHtcbiAgY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgbGV0IGFnZ3JlZ2F0ZWRSZXNwb25zZSA9IFwiXCI7XG4gIGNvbnN0IGNhbGxiYWNrcyA9IGNiIHx8IHt9O1xuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgYXN5bmMgc3RhcnQoKSB7XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uU3RhcnQpXG4gICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vblN0YXJ0KCk7XG4gICAgfSxcbiAgICBhc3luYyB0cmFuc2Zvcm0obWVzc2FnZSwgY29udHJvbGxlcikge1xuICAgICAgY29uc3QgY29udGVudCA9IHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8gbWVzc2FnZSA6IG1lc3NhZ2UuY29udGVudDtcbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh0ZXh0RW5jb2Rlci5lbmNvZGUoY29udGVudCkpO1xuICAgICAgYWdncmVnYXRlZFJlc3BvbnNlICs9IGNvbnRlbnQ7XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uVG9rZW4pXG4gICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vblRva2VuKGNvbnRlbnQpO1xuICAgICAgaWYgKGNhbGxiYWNrcy5vblRleHQgJiYgdHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uVGV4dChtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFzeW5jIGZsdXNoKCkge1xuICAgICAgY29uc3QgaXNPcGVuQUlDYWxsYmFja3MgPSBpc09mVHlwZU9wZW5BSVN0cmVhbUNhbGxiYWNrcyhjYWxsYmFja3MpO1xuICAgICAgaWYgKGNhbGxiYWNrcy5vbkNvbXBsZXRpb24pIHtcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uQ29tcGxldGlvbihhZ2dyZWdhdGVkUmVzcG9uc2UpO1xuICAgICAgfVxuICAgICAgaWYgKGNhbGxiYWNrcy5vbkZpbmFsICYmICFpc09wZW5BSUNhbGxiYWNrcykge1xuICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25GaW5hbChhZ2dyZWdhdGVkUmVzcG9uc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBpc09mVHlwZU9wZW5BSVN0cmVhbUNhbGxiYWNrcyhjYWxsYmFja3MpIHtcbiAgcmV0dXJuIFwiZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsXCIgaW4gY2FsbGJhY2tzO1xufVxuZnVuY3Rpb24gdHJpbVN0YXJ0T2ZTdHJlYW1IZWxwZXIoKSB7XG4gIGxldCBpc1N0cmVhbVN0YXJ0ID0gdHJ1ZTtcbiAgcmV0dXJuICh0ZXh0KSA9PiB7XG4gICAgaWYgKGlzU3RyZWFtU3RhcnQpIHtcbiAgICAgIHRleHQgPSB0ZXh0LnRyaW1TdGFydCgpO1xuICAgICAgaWYgKHRleHQpXG4gICAgICAgIGlzU3RyZWFtU3RhcnQgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG4gIH07XG59XG5mdW5jdGlvbiBBSVN0cmVhbShyZXNwb25zZSwgY3VzdG9tUGFyc2VyLCBjYWxsYmFja3MpIHtcbiAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgIGlmIChyZXNwb25zZS5ib2R5KSB7XG4gICAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICAgICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgIGlmICghZG9uZSkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JUZXh0ID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKHZhbHVlKTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IobmV3IEVycm9yKGBSZXNwb25zZSBlcnJvcjogJHtlcnJvclRleHR9YCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lcnJvcihuZXcgRXJyb3IoXCJSZXNwb25zZSBlcnJvcjogTm8gcmVzcG9uc2UgYm9keVwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBjb25zdCByZXNwb25zZUJvZHlTdHJlYW0gPSByZXNwb25zZS5ib2R5IHx8IGNyZWF0ZUVtcHR5UmVhZGFibGVTdHJlYW0oKTtcbiAgcmV0dXJuIHJlc3BvbnNlQm9keVN0cmVhbS5waXBlVGhyb3VnaChjcmVhdGVFdmVudFN0cmVhbVRyYW5zZm9ybWVyKGN1c3RvbVBhcnNlcikpLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcykpO1xufVxuZnVuY3Rpb24gY3JlYXRlRW1wdHlSZWFkYWJsZVN0cmVhbSgpIHtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlKGl0ZXJhYmxlKSB7XG4gIGxldCBpdCA9IGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IGl0Lm5leHQoKTtcbiAgICAgIGlmIChkb25lKVxuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICBlbHNlXG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG4gICAgfSxcbiAgICBhc3luYyBjYW5jZWwocmVhc29uKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBhd2FpdCAoKF9hID0gaXQucmV0dXJuKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChpdCwgcmVhc29uKSk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3RyZWFtcy9zdHJlYW0tZGF0YS50c1xudmFyIFN0cmVhbURhdGEgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIHRoaXMuY29udHJvbGxlciA9IG51bGw7XG4gICAgLy8gY2xvc2luZyB0aGUgc3RyZWFtIGlzIHN5bmNocm9ub3VzLCBidXQgd2Ugd2FudCB0byByZXR1cm4gYSBwcm9taXNlXG4gICAgLy8gaW4gY2FzZSB3ZSdyZSBkb2luZyBhc3luYyB3b3JrXG4gICAgdGhpcy5pc0Nsb3NlZFByb21pc2UgPSBudWxsO1xuICAgIHRoaXMuaXNDbG9zZWRQcm9taXNlUmVzb2x2ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5pc0Nsb3NlZCA9IGZhbHNlO1xuICAgIC8vIGFycmF5IHRvIHN0b3JlIGFwcGVuZGVkIGRhdGFcbiAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICB0aGlzLm1lc3NhZ2VBbm5vdGF0aW9ucyA9IFtdO1xuICAgIHRoaXMuaXNDbG9zZWRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHRoaXMuaXNDbG9zZWRQcm9taXNlUmVzb2x2ZXIgPSByZXNvbHZlO1xuICAgIH0pO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuc3RyZWFtID0gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICBzdGFydDogYXN5bmMgKGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgc2VsZi5jb250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm06IGFzeW5jIChjaHVuaywgY29udHJvbGxlcikgPT4ge1xuICAgICAgICBpZiAoc2VsZi5kYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBlbmNvZGVkRGF0YSA9IHNlbGYuZW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0KFwiZGF0YVwiLCBzZWxmLmRhdGEpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzZWxmLmRhdGEgPSBbXTtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZW5jb2RlZERhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLm1lc3NhZ2VBbm5vdGF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBlbmNvZGVkTWVzc2FnZUFubm90YXRpb25zID0gc2VsZi5lbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQoXCJtZXNzYWdlX2Fubm90YXRpb25zXCIsIHNlbGYubWVzc2FnZUFubm90YXRpb25zKVxuICAgICAgICAgICk7XG4gICAgICAgICAgc2VsZi5tZXNzYWdlQW5ub3RhdGlvbnMgPSBbXTtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZW5jb2RlZE1lc3NhZ2VBbm5vdGF0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgIH0sXG4gICAgICBhc3luYyBmbHVzaChjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnN0IHdhcm5pbmdUaW1lb3V0ID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIiA/IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIFwiVGhlIGRhdGEgc3RyZWFtIGlzIGhhbmdpbmcuIERpZCB5b3UgZm9yZ2V0IHRvIGNsb3NlIGl0IHdpdGggYGRhdGEuY2xvc2UoKWA/XCJcbiAgICAgICAgICApO1xuICAgICAgICB9LCAzZTMpIDogbnVsbDtcbiAgICAgICAgYXdhaXQgc2VsZi5pc0Nsb3NlZFByb21pc2U7XG4gICAgICAgIGlmICh3YXJuaW5nVGltZW91dCAhPT0gbnVsbCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh3YXJuaW5nVGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBlbmNvZGVkRGF0YSA9IHNlbGYuZW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0KFwiZGF0YVwiLCBzZWxmLmRhdGEpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZW5jb2RlZERhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLm1lc3NhZ2VBbm5vdGF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBlbmNvZGVkRGF0YSA9IHNlbGYuZW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0KFwibWVzc2FnZV9hbm5vdGF0aW9uc1wiLCBzZWxmLm1lc3NhZ2VBbm5vdGF0aW9ucylcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVkRGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhc3luYyBjbG9zZSgpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGEgU3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLlwiKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNvbnRyb2xsZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0cmVhbSBjb250cm9sbGVyIGlzIG5vdCBpbml0aWFsaXplZC5cIik7XG4gICAgfVxuICAgIChfYSA9IHRoaXMuaXNDbG9zZWRQcm9taXNlUmVzb2x2ZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpO1xuICAgIHRoaXMuaXNDbG9zZWQgPSB0cnVlO1xuICB9XG4gIGFwcGVuZCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhIFN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZC5cIik7XG4gICAgfVxuICAgIHRoaXMuZGF0YS5wdXNoKHZhbHVlKTtcbiAgfVxuICBhcHBlbmRNZXNzYWdlQW5ub3RhdGlvbih2YWx1ZSkge1xuICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhIFN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZC5cIik7XG4gICAgfVxuICAgIHRoaXMubWVzc2FnZUFubm90YXRpb25zLnB1c2godmFsdWUpO1xuICB9XG59O1xuZnVuY3Rpb24gY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkge1xuICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIHRyYW5zZm9ybTogYXN5bmMgKGNodW5rLCBjb250cm9sbGVyKSA9PiB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gZGVjb2Rlci5kZWNvZGUoY2h1bmspO1xuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGVuY29kZXIuZW5jb2RlKGZvcm1hdFN0cmVhbVBhcnQoXCJ0ZXh0XCIsIG1lc3NhZ2UpKSk7XG4gICAgfVxuICB9KTtcbn1cbnZhciBleHBlcmltZW50YWxfU3RyZWFtRGF0YSA9IGNsYXNzIGV4dGVuZHMgU3RyZWFtRGF0YSB7XG59O1xuXG4vLyBzdHJlYW1zL2FudGhyb3BpYy1zdHJlYW0udHNcbmZ1bmN0aW9uIHBhcnNlQW50aHJvcGljU3RyZWFtKCkge1xuICBsZXQgcHJldmlvdXMgPSBcIlwiO1xuICByZXR1cm4gKGRhdGEpID0+IHtcbiAgICBjb25zdCBqc29uID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICBpZiAoXCJlcnJvclwiIGluIGpzb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtqc29uLmVycm9yLnR5cGV9OiAke2pzb24uZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gICAgaWYgKCEoXCJjb21wbGV0aW9uXCIgaW4ganNvbikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGV4dCA9IGpzb24uY29tcGxldGlvbjtcbiAgICBpZiAoIXByZXZpb3VzIHx8IHRleHQubGVuZ3RoID4gcHJldmlvdXMubGVuZ3RoICYmIHRleHQuc3RhcnRzV2l0aChwcmV2aW91cykpIHtcbiAgICAgIGNvbnN0IGRlbHRhID0gdGV4dC5zbGljZShwcmV2aW91cy5sZW5ndGgpO1xuICAgICAgcHJldmlvdXMgPSB0ZXh0O1xuICAgICAgcmV0dXJuIGRlbHRhO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uKiBzdHJlYW1hYmxlKHN0cmVhbSkge1xuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgIGlmIChcImNvbXBsZXRpb25cIiBpbiBjaHVuaykge1xuICAgICAgY29uc3QgdGV4dCA9IGNodW5rLmNvbXBsZXRpb247XG4gICAgICBpZiAodGV4dClcbiAgICAgICAgeWllbGQgdGV4dDtcbiAgICB9IGVsc2UgaWYgKFwiZGVsdGFcIiBpbiBjaHVuaykge1xuICAgICAgY29uc3QgeyBkZWx0YSB9ID0gY2h1bms7XG4gICAgICBpZiAoXCJ0ZXh0XCIgaW4gZGVsdGEpIHtcbiAgICAgICAgY29uc3QgdGV4dCA9IGRlbHRhLnRleHQ7XG4gICAgICAgIGlmICh0ZXh0KVxuICAgICAgICAgIHlpZWxkIHRleHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBBbnRocm9waWNTdHJlYW0ocmVzLCBjYikge1xuICBpZiAoU3ltYm9sLmFzeW5jSXRlcmF0b3IgaW4gcmVzKSB7XG4gICAgcmV0dXJuIHJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGUoc3RyZWFtYWJsZShyZXMpKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYikpLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gQUlTdHJlYW0ocmVzLCBwYXJzZUFudGhyb3BpY1N0cmVhbSgpLCBjYikucGlwZVRocm91Z2goXG4gICAgICBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKVxuICAgICk7XG4gIH1cbn1cblxuLy8gc3RyZWFtcy9hc3Npc3RhbnQtcmVzcG9uc2UudHNcbmZ1bmN0aW9uIEFzc2lzdGFudFJlc3BvbnNlKHsgdGhyZWFkSWQsIG1lc3NhZ2VJZCB9LCBwcm9jZXNzMikge1xuICBjb25zdCBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICBjb25zdCBzZW5kTWVzc2FnZSA9IChtZXNzYWdlKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydChcImFzc2lzdGFudF9tZXNzYWdlXCIsIG1lc3NhZ2UpKVxuICAgICAgICApO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHNlbmREYXRhTWVzc2FnZSA9IChtZXNzYWdlKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydChcImRhdGFfbWVzc2FnZVwiLCBtZXNzYWdlKSlcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBzZW5kRXJyb3IgPSAoZXJyb3JNZXNzYWdlKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydChcImVycm9yXCIsIGVycm9yTWVzc2FnZSkpXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZm9yd2FyZFN0cmVhbSA9IGFzeW5jIChzdHJlYW0yKSA9PiB7XG4gICAgICAgIHZhciBfYTIsIF9iO1xuICAgICAgICBsZXQgcmVzdWx0ID0gdm9pZCAwO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIHN0cmVhbTIpIHtcbiAgICAgICAgICBzd2l0Y2ggKHZhbHVlLmV2ZW50KSB7XG4gICAgICAgICAgICBjYXNlIFwidGhyZWFkLm1lc3NhZ2UuY3JlYXRlZFwiOiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0KFwiYXNzaXN0YW50X21lc3NhZ2VcIiwge1xuICAgICAgICAgICAgICAgICAgICBpZDogdmFsdWUuZGF0YS5pZCxcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogW3sgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IHsgdmFsdWU6IFwiXCIgfSB9XVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRocmVhZC5tZXNzYWdlLmRlbHRhXCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IChfYTIgPSB2YWx1ZS5kYXRhLmRlbHRhLmNvbnRlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYTJbMF07XG4gICAgICAgICAgICAgIGlmICgoY29udGVudCA9PSBudWxsID8gdm9pZCAwIDogY29udGVudC50eXBlKSA9PT0gXCJ0ZXh0XCIgJiYgKChfYiA9IGNvbnRlbnQudGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnZhbHVlKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0KFwidGV4dFwiLCBjb250ZW50LnRleHQudmFsdWUpXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0aHJlYWQucnVuLmNvbXBsZXRlZFwiOlxuICAgICAgICAgICAgY2FzZSBcInRocmVhZC5ydW4ucmVxdWlyZXNfYWN0aW9uXCI6IHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWUuZGF0YTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgZm9ybWF0U3RyZWFtUGFydChcImFzc2lzdGFudF9jb250cm9sX2RhdGFcIiwge1xuICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICBtZXNzYWdlSWRcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgcHJvY2VzczIoe1xuICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgIG1lc3NhZ2VJZCxcbiAgICAgICAgICBzZW5kTWVzc2FnZSxcbiAgICAgICAgICBzZW5kRGF0YU1lc3NhZ2UsXG4gICAgICAgICAgZm9yd2FyZFN0cmVhbVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHNlbmRFcnJvcigoX2EgPSBlcnJvci5tZXNzYWdlKSAhPSBudWxsID8gX2EgOiBgJHtlcnJvcn1gKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHB1bGwoY29udHJvbGxlcikge1xuICAgIH0sXG4gICAgY2FuY2VsKCkge1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBuZXcgUmVzcG9uc2Uoc3RyZWFtLCB7XG4gICAgc3RhdHVzOiAyMDAsXG4gICAgaGVhZGVyczoge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCJcbiAgICB9XG4gIH0pO1xufVxudmFyIGV4cGVyaW1lbnRhbF9Bc3Npc3RhbnRSZXNwb25zZSA9IEFzc2lzdGFudFJlc3BvbnNlO1xuXG4vLyBzdHJlYW1zL2F3cy1iZWRyb2NrLXN0cmVhbS50c1xuYXN5bmMgZnVuY3Rpb24qIGFzRGVsdGFJdGVyYWJsZShyZXNwb25zZSwgZXh0cmFjdFRleHREZWx0YUZyb21DaHVuaykge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgKF9hID0gcmVzcG9uc2UuYm9keSkgIT0gbnVsbCA/IF9hIDogW10pIHtcbiAgICBjb25zdCBieXRlcyA9IChfYiA9IGNodW5rLmNodW5rKSA9PSBudWxsID8gdm9pZCAwIDogX2IuYnl0ZXM7XG4gICAgaWYgKGJ5dGVzICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGNodW5rVGV4dCA9IGRlY29kZXIuZGVjb2RlKGJ5dGVzKTtcbiAgICAgIGNvbnN0IGNodW5rSlNPTiA9IEpTT04ucGFyc2UoY2h1bmtUZXh0KTtcbiAgICAgIGNvbnN0IGRlbHRhID0gZXh0cmFjdFRleHREZWx0YUZyb21DaHVuayhjaHVua0pTT04pO1xuICAgICAgaWYgKGRlbHRhICE9IG51bGwpIHtcbiAgICAgICAgeWllbGQgZGVsdGE7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBBV1NCZWRyb2NrQW50aHJvcGljTWVzc2FnZXNTdHJlYW0ocmVzcG9uc2UsIGNhbGxiYWNrcykge1xuICByZXR1cm4gQVdTQmVkcm9ja1N0cmVhbShyZXNwb25zZSwgY2FsbGJhY2tzLCAoY2h1bmspID0+IHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IGNodW5rLmRlbHRhKSA9PSBudWxsID8gdm9pZCAwIDogX2EudGV4dDtcbiAgfSk7XG59XG5mdW5jdGlvbiBBV1NCZWRyb2NrQW50aHJvcGljU3RyZWFtKHJlc3BvbnNlLCBjYWxsYmFja3MpIHtcbiAgcmV0dXJuIEFXU0JlZHJvY2tTdHJlYW0ocmVzcG9uc2UsIGNhbGxiYWNrcywgKGNodW5rKSA9PiBjaHVuay5jb21wbGV0aW9uKTtcbn1cbmZ1bmN0aW9uIEFXU0JlZHJvY2tDb2hlcmVTdHJlYW0ocmVzcG9uc2UsIGNhbGxiYWNrcykge1xuICByZXR1cm4gQVdTQmVkcm9ja1N0cmVhbShyZXNwb25zZSwgY2FsbGJhY2tzLCAoY2h1bmspID0+IGNodW5rID09IG51bGwgPyB2b2lkIDAgOiBjaHVuay50ZXh0KTtcbn1cbmZ1bmN0aW9uIEFXU0JlZHJvY2tMbGFtYTJTdHJlYW0ocmVzcG9uc2UsIGNhbGxiYWNrcykge1xuICByZXR1cm4gQVdTQmVkcm9ja1N0cmVhbShyZXNwb25zZSwgY2FsbGJhY2tzLCAoY2h1bmspID0+IGNodW5rLmdlbmVyYXRpb24pO1xufVxuZnVuY3Rpb24gQVdTQmVkcm9ja1N0cmVhbShyZXNwb25zZSwgY2FsbGJhY2tzLCBleHRyYWN0VGV4dERlbHRhRnJvbUNodW5rKSB7XG4gIHJldHVybiByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlKFxuICAgIGFzRGVsdGFJdGVyYWJsZShyZXNwb25zZSwgZXh0cmFjdFRleHREZWx0YUZyb21DaHVuaylcbiAgKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSk7XG59XG5cbi8vIHN0cmVhbXMvY29oZXJlLXN0cmVhbS50c1xudmFyIHV0ZjhEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKFwidXRmLThcIik7XG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzTGluZXMobGluZXMsIGNvbnRyb2xsZXIpIHtcbiAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgY29uc3QgeyB0ZXh0LCBpc19maW5pc2hlZCB9ID0gSlNPTi5wYXJzZShsaW5lKTtcbiAgICBpZiAoIWlzX2ZpbmlzaGVkKSB7XG4gICAgICBjb250cm9sbGVyLmVucXVldWUodGV4dCk7XG4gICAgfVxuICB9XG59XG5hc3luYyBmdW5jdGlvbiByZWFkQW5kUHJvY2Vzc0xpbmVzKHJlYWRlciwgY29udHJvbGxlcikge1xuICBsZXQgc2VnbWVudCA9IFwiXCI7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyB2YWx1ZTogY2h1bmssIGRvbmUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBzZWdtZW50ICs9IHV0ZjhEZWNvZGVyLmRlY29kZShjaHVuaywgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgY29uc3QgbGluZXNBcnJheSA9IHNlZ21lbnQuc3BsaXQoL1xcclxcbnxcXG58XFxyL2cpO1xuICAgIHNlZ21lbnQgPSBsaW5lc0FycmF5LnBvcCgpIHx8IFwiXCI7XG4gICAgYXdhaXQgcHJvY2Vzc0xpbmVzKGxpbmVzQXJyYXksIGNvbnRyb2xsZXIpO1xuICB9XG4gIGlmIChzZWdtZW50KSB7XG4gICAgY29uc3QgbGluZXNBcnJheSA9IFtzZWdtZW50XTtcbiAgICBhd2FpdCBwcm9jZXNzTGluZXMobGluZXNBcnJheSwgY29udHJvbGxlcik7XG4gIH1cbiAgY29udHJvbGxlci5jbG9zZSgpO1xufVxuZnVuY3Rpb24gY3JlYXRlUGFyc2VyMihyZXMpIHtcbiAgdmFyIF9hO1xuICBjb25zdCByZWFkZXIgPSAoX2EgPSByZXMuYm9keSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmdldFJlYWRlcigpO1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICBpZiAoIXJlYWRlcikge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHJlYWRBbmRQcm9jZXNzTGluZXMocmVhZGVyLCBjb250cm9sbGVyKTtcbiAgICB9XG4gIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24qIHN0cmVhbWFibGUyKHN0cmVhbSkge1xuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgIGlmIChjaHVuay5ldmVudFR5cGUgPT09IFwidGV4dC1nZW5lcmF0aW9uXCIpIHtcbiAgICAgIGNvbnN0IHRleHQgPSBjaHVuay50ZXh0O1xuICAgICAgaWYgKHRleHQpXG4gICAgICAgIHlpZWxkIHRleHQ7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBDb2hlcmVTdHJlYW0ocmVhZGVyLCBjYWxsYmFja3MpIHtcbiAgaWYgKFN5bWJvbC5hc3luY0l0ZXJhdG9yIGluIHJlYWRlcikge1xuICAgIHJldHVybiByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlKHN0cmVhbWFibGUyKHJlYWRlcikpLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcykpLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY3JlYXRlUGFyc2VyMihyZWFkZXIpLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcykpLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpKTtcbiAgfVxufVxuXG4vLyBzdHJlYW1zL2dvb2dsZS1nZW5lcmF0aXZlLWFpLXN0cmVhbS50c1xuYXN5bmMgZnVuY3Rpb24qIHN0cmVhbWFibGUzKHJlc3BvbnNlKSB7XG4gIHZhciBfYSwgX2IsIF9jO1xuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHJlc3BvbnNlLnN0cmVhbSkge1xuICAgIGNvbnN0IHBhcnRzID0gKF9jID0gKF9iID0gKF9hID0gY2h1bmsuY2FuZGlkYXRlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY29udGVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnBhcnRzO1xuICAgIGlmIChwYXJ0cyA9PT0gdm9pZCAwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgZmlyc3RQYXJ0ID0gcGFydHNbMF07XG4gICAgaWYgKHR5cGVvZiBmaXJzdFBhcnQudGV4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgeWllbGQgZmlyc3RQYXJ0LnRleHQ7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBHb29nbGVHZW5lcmF0aXZlQUlTdHJlYW0ocmVzcG9uc2UsIGNiKSB7XG4gIHJldHVybiByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlKHN0cmVhbWFibGUzKHJlc3BvbnNlKSkucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2IpKS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSk7XG59XG5cbi8vIHN0cmVhbXMvaHVnZ2luZ2ZhY2Utc3RyZWFtLnRzXG5mdW5jdGlvbiBjcmVhdGVQYXJzZXIzKHJlcykge1xuICBjb25zdCB0cmltU3RhcnRPZlN0cmVhbSA9IHRyaW1TdGFydE9mU3RyZWFtSGVscGVyKCk7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IHJlcy5uZXh0KCk7XG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRleHQgPSB0cmltU3RhcnRPZlN0cmVhbSgoX2IgPSAoX2EgPSB2YWx1ZS50b2tlbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnRleHQpICE9IG51bGwgPyBfYiA6IFwiXCIpO1xuICAgICAgaWYgKCF0ZXh0KVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAodmFsdWUuZ2VuZXJhdGVkX3RleHQgIT0gbnVsbCAmJiB2YWx1ZS5nZW5lcmF0ZWRfdGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0ZXh0ID09PSBcIjwvcz5cIiB8fCB0ZXh0ID09PSBcIjx8ZW5kb2Z0ZXh0fD5cIiB8fCB0ZXh0ID09PSBcIjx8ZW5kfD5cIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb250cm9sbGVyLmVucXVldWUodGV4dCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIEh1Z2dpbmdGYWNlU3RyZWFtKHJlcywgY2FsbGJhY2tzKSB7XG4gIHJldHVybiBjcmVhdGVQYXJzZXIzKHJlcykucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSkucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkpO1xufVxuXG4vLyBzdHJlYW1zL2lua2VlcC1zdHJlYW0udHNcbmZ1bmN0aW9uIElua2VlcFN0cmVhbShyZXMsIGNhbGxiYWNrcykge1xuICBpZiAoIXJlcy5ib2R5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUmVzcG9uc2UgYm9keSBpcyBudWxsXCIpO1xuICB9XG4gIGxldCBjaGF0X3Nlc3Npb25faWQgPSBcIlwiO1xuICBsZXQgcmVjb3Jkc19jaXRlZDtcbiAgY29uc3QgaW5rZWVwRXZlbnRQYXJzZXIgPSAoZGF0YSwgb3B0aW9ucykgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgeyBldmVudCB9ID0gb3B0aW9ucztcbiAgICBpZiAoZXZlbnQgPT09IFwicmVjb3Jkc19jaXRlZFwiKSB7XG4gICAgICByZWNvcmRzX2NpdGVkID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIChfYSA9IGNhbGxiYWNrcyA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uUmVjb3Jkc0NpdGVkKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChjYWxsYmFja3MsIHJlY29yZHNfY2l0ZWQpO1xuICAgIH1cbiAgICBpZiAoZXZlbnQgPT09IFwibWVzc2FnZV9jaHVua1wiKSB7XG4gICAgICBjb25zdCBpbmtlZXBNZXNzYWdlQ2h1bmsgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgY2hhdF9zZXNzaW9uX2lkID0gKF9iID0gaW5rZWVwTWVzc2FnZUNodW5rLmNoYXRfc2Vzc2lvbl9pZCkgIT0gbnVsbCA/IF9iIDogY2hhdF9zZXNzaW9uX2lkO1xuICAgICAgcmV0dXJuIGlua2VlcE1lc3NhZ2VDaHVuay5jb250ZW50X2NodW5rO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH07XG4gIGxldCB7IG9uUmVjb3Jkc0NpdGVkLCAuLi5wYXNzVGhyb3VnaENhbGxiYWNrcyB9ID0gY2FsbGJhY2tzIHx8IHt9O1xuICBwYXNzVGhyb3VnaENhbGxiYWNrcyA9IHtcbiAgICAuLi5wYXNzVGhyb3VnaENhbGxiYWNrcyxcbiAgICBvbkZpbmFsOiAoY29tcGxldGlvbikgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgaW5rZWVwT25GaW5hbE1ldGFkYXRhID0ge1xuICAgICAgICBjaGF0X3Nlc3Npb25faWQsXG4gICAgICAgIHJlY29yZHNfY2l0ZWRcbiAgICAgIH07XG4gICAgICAoX2EgPSBjYWxsYmFja3MgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vbkZpbmFsKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChjYWxsYmFja3MsIGNvbXBsZXRpb24sIGlua2VlcE9uRmluYWxNZXRhZGF0YSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gQUlTdHJlYW0ocmVzLCBpbmtlZXBFdmVudFBhcnNlciwgcGFzc1Rocm91Z2hDYWxsYmFja3MpLnBpcGVUaHJvdWdoKFxuICAgIGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpXG4gICk7XG59XG5cbi8vIHN0cmVhbXMvbGFuZ2NoYWluLXN0cmVhbS50c1xuZnVuY3Rpb24gTGFuZ0NoYWluU3RyZWFtKGNhbGxiYWNrcykge1xuICBjb25zdCBzdHJlYW0gPSBuZXcgVHJhbnNmb3JtU3RyZWFtKCk7XG4gIGNvbnN0IHdyaXRlciA9IHN0cmVhbS53cml0YWJsZS5nZXRXcml0ZXIoKTtcbiAgY29uc3QgcnVucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IGhhbmRsZUVycm9yID0gYXN5bmMgKGUsIHJ1bklkKSA9PiB7XG4gICAgcnVucy5kZWxldGUocnVuSWQpO1xuICAgIGF3YWl0IHdyaXRlci5yZWFkeTtcbiAgICBhd2FpdCB3cml0ZXIuYWJvcnQoZSk7XG4gIH07XG4gIGNvbnN0IGhhbmRsZVN0YXJ0ID0gYXN5bmMgKHJ1bklkKSA9PiB7XG4gICAgcnVucy5hZGQocnVuSWQpO1xuICB9O1xuICBjb25zdCBoYW5kbGVFbmQgPSBhc3luYyAocnVuSWQpID0+IHtcbiAgICBydW5zLmRlbGV0ZShydW5JZCk7XG4gICAgaWYgKHJ1bnMuc2l6ZSA9PT0gMCkge1xuICAgICAgYXdhaXQgd3JpdGVyLnJlYWR5O1xuICAgICAgYXdhaXQgd3JpdGVyLmNsb3NlKCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4ge1xuICAgIHN0cmVhbTogc3RyZWFtLnJlYWRhYmxlLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcykpLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpKSxcbiAgICB3cml0ZXIsXG4gICAgaGFuZGxlcnM6IHtcbiAgICAgIGhhbmRsZUxMTU5ld1Rva2VuOiBhc3luYyAodG9rZW4pID0+IHtcbiAgICAgICAgYXdhaXQgd3JpdGVyLnJlYWR5O1xuICAgICAgICBhd2FpdCB3cml0ZXIud3JpdGUodG9rZW4pO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZUxMTVN0YXJ0OiBhc3luYyAoX2xsbSwgX3Byb21wdHMsIHJ1bklkKSA9PiB7XG4gICAgICAgIGhhbmRsZVN0YXJ0KHJ1bklkKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVMTE1FbmQ6IGFzeW5jIChfb3V0cHV0LCBydW5JZCkgPT4ge1xuICAgICAgICBhd2FpdCBoYW5kbGVFbmQocnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZUxMTUVycm9yOiBhc3luYyAoZSwgcnVuSWQpID0+IHtcbiAgICAgICAgYXdhaXQgaGFuZGxlRXJyb3IoZSwgcnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZUNoYWluU3RhcnQ6IGFzeW5jIChfY2hhaW4sIF9pbnB1dHMsIHJ1bklkKSA9PiB7XG4gICAgICAgIGhhbmRsZVN0YXJ0KHJ1bklkKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVDaGFpbkVuZDogYXN5bmMgKF9vdXRwdXRzLCBydW5JZCkgPT4ge1xuICAgICAgICBhd2FpdCBoYW5kbGVFbmQocnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZUNoYWluRXJyb3I6IGFzeW5jIChlLCBydW5JZCkgPT4ge1xuICAgICAgICBhd2FpdCBoYW5kbGVFcnJvcihlLCBydW5JZCk7XG4gICAgICB9LFxuICAgICAgaGFuZGxlVG9vbFN0YXJ0OiBhc3luYyAoX3Rvb2wsIF9pbnB1dCwgcnVuSWQpID0+IHtcbiAgICAgICAgaGFuZGxlU3RhcnQocnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZVRvb2xFbmQ6IGFzeW5jIChfb3V0cHV0LCBydW5JZCkgPT4ge1xuICAgICAgICBhd2FpdCBoYW5kbGVFbmQocnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZVRvb2xFcnJvcjogYXN5bmMgKGUsIHJ1bklkKSA9PiB7XG4gICAgICAgIGF3YWl0IGhhbmRsZUVycm9yKGUsIHJ1bklkKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8vIHN0cmVhbXMvbWlzdHJhbC1zdHJlYW0udHNcbmFzeW5jIGZ1bmN0aW9uKiBzdHJlYW1hYmxlNChzdHJlYW0pIHtcbiAgdmFyIF9hLCBfYjtcbiAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICBjb25zdCBjb250ZW50ID0gKF9iID0gKF9hID0gY2h1bmsuY2hvaWNlc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmRlbHRhKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY29udGVudDtcbiAgICBpZiAoY29udGVudCA9PT0gdm9pZCAwIHx8IGNvbnRlbnQgPT09IFwiXCIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB5aWVsZCBjb250ZW50O1xuICB9XG59XG5mdW5jdGlvbiBNaXN0cmFsU3RyZWFtKHJlc3BvbnNlLCBjYWxsYmFja3MpIHtcbiAgY29uc3Qgc3RyZWFtID0gcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZShzdHJlYW1hYmxlNChyZXNwb25zZSkpO1xuICByZXR1cm4gc3RyZWFtLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcykpLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpKTtcbn1cblxuLy8gc3RyZWFtcy9vcGVuYWktc3RyZWFtLnRzXG5mdW5jdGlvbiBwYXJzZU9wZW5BSVN0cmVhbSgpIHtcbiAgY29uc3QgZXh0cmFjdCA9IGNodW5rVG9UZXh0KCk7XG4gIHJldHVybiAoZGF0YSkgPT4gZXh0cmFjdChKU09OLnBhcnNlKGRhdGEpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uKiBzdHJlYW1hYmxlNShzdHJlYW0pIHtcbiAgY29uc3QgZXh0cmFjdCA9IGNodW5rVG9UZXh0KCk7XG4gIGZvciBhd2FpdCAobGV0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgIGlmIChcInByb21wdEZpbHRlclJlc3VsdHNcIiBpbiBjaHVuaykge1xuICAgICAgY2h1bmsgPSB7XG4gICAgICAgIGlkOiBjaHVuay5pZCxcbiAgICAgICAgY3JlYXRlZDogY2h1bmsuY3JlYXRlZC5nZXREYXRlKCksXG4gICAgICAgIG9iamVjdDogY2h1bmsub2JqZWN0LFxuICAgICAgICAvLyBub3QgZXhwb3NlZCBieSBBenVyZSBBUElcbiAgICAgICAgbW9kZWw6IGNodW5rLm1vZGVsLFxuICAgICAgICAvLyBub3QgZXhwb3NlZCBieSBBenVyZSBBUElcbiAgICAgICAgY2hvaWNlczogY2h1bmsuY2hvaWNlcy5tYXAoKGNob2ljZSkgPT4ge1xuICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZztcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVsdGE6IHtcbiAgICAgICAgICAgICAgY29udGVudDogKF9hID0gY2hvaWNlLmRlbHRhKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY29udGVudCxcbiAgICAgICAgICAgICAgZnVuY3Rpb25fY2FsbDogKF9iID0gY2hvaWNlLmRlbHRhKSA9PSBudWxsID8gdm9pZCAwIDogX2IuZnVuY3Rpb25DYWxsLFxuICAgICAgICAgICAgICByb2xlOiAoX2MgPSBjaG9pY2UuZGVsdGEpID09IG51bGwgPyB2b2lkIDAgOiBfYy5yb2xlLFxuICAgICAgICAgICAgICB0b29sX2NhbGxzOiAoKF9lID0gKF9kID0gY2hvaWNlLmRlbHRhKSA9PSBudWxsID8gdm9pZCAwIDogX2QudG9vbENhbGxzKSA9PSBudWxsID8gdm9pZCAwIDogX2UubGVuZ3RoKSA/IChfZyA9IChfZiA9IGNob2ljZS5kZWx0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLnRvb2xDYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9nLm1hcCgodG9vbENhbGwsIGluZGV4KSA9PiAoe1xuICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgIGlkOiB0b29sQ2FsbC5pZCxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbjogdG9vbENhbGwuZnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgdHlwZTogdG9vbENhbGwudHlwZVxuICAgICAgICAgICAgICB9KSkgOiB2b2lkIDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaW5pc2hfcmVhc29uOiBjaG9pY2UuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgaW5kZXg6IGNob2ljZS5pbmRleFxuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB0ZXh0ID0gZXh0cmFjdChjaHVuayk7XG4gICAgaWYgKHRleHQpXG4gICAgICB5aWVsZCB0ZXh0O1xuICB9XG59XG5mdW5jdGlvbiBjaHVua1RvVGV4dCgpIHtcbiAgY29uc3QgdHJpbVN0YXJ0T2ZTdHJlYW0gPSB0cmltU3RhcnRPZlN0cmVhbUhlbHBlcigpO1xuICBsZXQgaXNGdW5jdGlvblN0cmVhbWluZ0luO1xuICByZXR1cm4gKGpzb24pID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaSwgX2osIF9rLCBfbCwgX20sIF9uLCBfbywgX3AsIF9xLCBfcjtcbiAgICBpZiAoaXNDaGF0Q29tcGxldGlvbkNodW5rKGpzb24pKSB7XG4gICAgICBjb25zdCBkZWx0YSA9IChfYSA9IGpzb24uY2hvaWNlc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmRlbHRhO1xuICAgICAgaWYgKChfYiA9IGRlbHRhLmZ1bmN0aW9uX2NhbGwpID09IG51bGwgPyB2b2lkIDAgOiBfYi5uYW1lKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IHRydWU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICBjb250ZW50OiBge1wiZnVuY3Rpb25fY2FsbFwiOiB7XCJuYW1lXCI6IFwiJHtkZWx0YS5mdW5jdGlvbl9jYWxsLm5hbWV9XCIsIFwiYXJndW1lbnRzXCI6IFwiYFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICgoX2UgPSAoX2QgPSAoX2MgPSBkZWx0YS50b29sX2NhbGxzKSA9PSBudWxsID8gdm9pZCAwIDogX2NbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfZC5mdW5jdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLm5hbWUpIHtcbiAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgdG9vbENhbGwgPSBkZWx0YS50b29sX2NhbGxzWzBdO1xuICAgICAgICBpZiAodG9vbENhbGwuaW5kZXggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IGB7XCJ0b29sX2NhbGxzXCI6WyB7XCJpZFwiOiBcIiR7dG9vbENhbGwuaWR9XCIsIFwidHlwZVwiOiBcImZ1bmN0aW9uXCIsIFwiZnVuY3Rpb25cIjoge1wibmFtZVwiOiBcIiR7KF9mID0gdG9vbENhbGwuZnVuY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfZi5uYW1lfVwiLCBcImFyZ3VtZW50c1wiOiBcImBcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgICAgY29udGVudDogYFwifX0sIHtcImlkXCI6IFwiJHt0b29sQ2FsbC5pZH1cIiwgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIiwgXCJmdW5jdGlvblwiOiB7XCJuYW1lXCI6IFwiJHsoX2cgPSB0b29sQ2FsbC5mdW5jdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9nLm5hbWV9XCIsIFwiYXJndW1lbnRzXCI6IFwiYFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoKF9oID0gZGVsdGEuZnVuY3Rpb25fY2FsbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9oLmFyZ3VtZW50cykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgY29udGVudDogY2xlYW51cEFyZ3VtZW50cygoX2kgPSBkZWx0YS5mdW5jdGlvbl9jYWxsKSA9PSBudWxsID8gdm9pZCAwIDogX2kuYXJndW1lbnRzKVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICgoX2wgPSAoX2sgPSAoX2ogPSBkZWx0YS50b29sX2NhbGxzKSA9PSBudWxsID8gdm9pZCAwIDogX2pbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfay5mdW5jdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9sLmFyZ3VtZW50cykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgY29udGVudDogY2xlYW51cEFyZ3VtZW50cygoX28gPSAoX24gPSAoX20gPSBkZWx0YS50b29sX2NhbGxzKSA9PSBudWxsID8gdm9pZCAwIDogX21bMF0pID09IG51bGwgPyB2b2lkIDAgOiBfbi5mdW5jdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9vLmFyZ3VtZW50cylcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvblN0cmVhbWluZ0luICYmICgoKF9wID0ganNvbi5jaG9pY2VzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3AuZmluaXNoX3JlYXNvbikgPT09IFwiZnVuY3Rpb25fY2FsbFwiIHx8ICgoX3EgPSBqc29uLmNob2ljZXNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfcS5maW5pc2hfcmVhc29uKSA9PT0gXCJzdG9wXCIpKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IGZhbHNlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgY29udGVudDogJ1wifX0nXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb25TdHJlYW1pbmdJbiAmJiAoKF9yID0ganNvbi5jaG9pY2VzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3IuZmluaXNoX3JlYXNvbikgPT09IFwidG9vbF9jYWxsc1wiKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IGZhbHNlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgY29udGVudDogJ1wifX1dfSdcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdGV4dCA9IHRyaW1TdGFydE9mU3RyZWFtKFxuICAgICAgaXNDaGF0Q29tcGxldGlvbkNodW5rKGpzb24pICYmIGpzb24uY2hvaWNlc1swXS5kZWx0YS5jb250ZW50ID8ganNvbi5jaG9pY2VzWzBdLmRlbHRhLmNvbnRlbnQgOiBpc0NvbXBsZXRpb24oanNvbikgPyBqc29uLmNob2ljZXNbMF0udGV4dCA6IFwiXCJcbiAgICApO1xuICAgIHJldHVybiB0ZXh0O1xuICB9O1xuICBmdW5jdGlvbiBjbGVhbnVwQXJndW1lbnRzKGFyZ3VtZW50Q2h1bmspIHtcbiAgICBsZXQgZXNjYXBlZFBhcnRpYWxKc29uID0gYXJndW1lbnRDaHVuay5yZXBsYWNlKC9cXFxcL2csIFwiXFxcXFxcXFxcIikucmVwbGFjZSgvXFwvL2csIFwiXFxcXC9cIikucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpLnJlcGxhY2UoL1xcbi9nLCBcIlxcXFxuXCIpLnJlcGxhY2UoL1xcci9nLCBcIlxcXFxyXCIpLnJlcGxhY2UoL1xcdC9nLCBcIlxcXFx0XCIpLnJlcGxhY2UoL1xcZi9nLCBcIlxcXFxmXCIpO1xuICAgIHJldHVybiBgJHtlc2NhcGVkUGFydGlhbEpzb259YDtcbiAgfVxufVxudmFyIF9faW50ZXJuYWxfX09wZW5BSUZuTWVzc2FnZXNTeW1ib2wgPSBTeW1ib2woXG4gIFwiaW50ZXJuYWxfb3BlbmFpX2ZuX21lc3NhZ2VzXCJcbik7XG5mdW5jdGlvbiBpc0NoYXRDb21wbGV0aW9uQ2h1bmsoZGF0YSkge1xuICByZXR1cm4gXCJjaG9pY2VzXCIgaW4gZGF0YSAmJiBkYXRhLmNob2ljZXMgJiYgZGF0YS5jaG9pY2VzWzBdICYmIFwiZGVsdGFcIiBpbiBkYXRhLmNob2ljZXNbMF07XG59XG5mdW5jdGlvbiBpc0NvbXBsZXRpb24oZGF0YSkge1xuICByZXR1cm4gXCJjaG9pY2VzXCIgaW4gZGF0YSAmJiBkYXRhLmNob2ljZXMgJiYgZGF0YS5jaG9pY2VzWzBdICYmIFwidGV4dFwiIGluIGRhdGEuY2hvaWNlc1swXTtcbn1cbmZ1bmN0aW9uIE9wZW5BSVN0cmVhbShyZXMsIGNhbGxiYWNrcykge1xuICBjb25zdCBjYiA9IGNhbGxiYWNrcztcbiAgbGV0IHN0cmVhbTtcbiAgaWYgKFN5bWJvbC5hc3luY0l0ZXJhdG9yIGluIHJlcykge1xuICAgIHN0cmVhbSA9IHJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGUoc3RyZWFtYWJsZTUocmVzKSkucGlwZVRocm91Z2goXG4gICAgICBjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihcbiAgICAgICAgKGNiID09IG51bGwgPyB2b2lkIDAgOiBjYi5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwpIHx8IChjYiA9PSBudWxsID8gdm9pZCAwIDogY2IuZXhwZXJpbWVudGFsX29uVG9vbENhbGwpID8ge1xuICAgICAgICAgIC4uLmNiLFxuICAgICAgICAgIG9uRmluYWw6IHZvaWQgMFxuICAgICAgICB9IDoge1xuICAgICAgICAgIC4uLmNiXG4gICAgICAgIH1cbiAgICAgIClcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHN0cmVhbSA9IEFJU3RyZWFtKFxuICAgICAgcmVzLFxuICAgICAgcGFyc2VPcGVuQUlTdHJlYW0oKSxcbiAgICAgIChjYiA9PSBudWxsID8gdm9pZCAwIDogY2IuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKSB8fCAoY2IgPT0gbnVsbCA/IHZvaWQgMCA6IGNiLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKSA/IHtcbiAgICAgICAgLi4uY2IsXG4gICAgICAgIG9uRmluYWw6IHZvaWQgMFxuICAgICAgfSA6IHtcbiAgICAgICAgLi4uY2JcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGlmIChjYiAmJiAoY2IuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHx8IGNiLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKSkge1xuICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbFRyYW5zZm9ybWVyID0gY3JlYXRlRnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIoY2IpO1xuICAgIHJldHVybiBzdHJlYW0ucGlwZVRocm91Z2goZnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHJlYW0ucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkpO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbkNhbGxUcmFuc2Zvcm1lcihjYWxsYmFja3MpIHtcbiAgY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgbGV0IGlzRmlyc3RDaHVuayA9IHRydWU7XG4gIGxldCBhZ2dyZWdhdGVkUmVzcG9uc2UgPSBcIlwiO1xuICBsZXQgYWdncmVnYXRlZEZpbmFsQ29tcGxldGlvblJlc3BvbnNlID0gXCJcIjtcbiAgbGV0IGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IGZhbHNlO1xuICBsZXQgZnVuY3Rpb25DYWxsTWVzc2FnZXMgPSBjYWxsYmFja3NbX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbF0gfHwgW107XG4gIGNvbnN0IGRlY29kZSA9IGNyZWF0ZUNodW5rRGVjb2RlcigpO1xuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gZGVjb2RlKGNodW5rKTtcbiAgICAgIGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSArPSBtZXNzYWdlO1xuICAgICAgY29uc3Qgc2hvdWxkSGFuZGxlQXNGdW5jdGlvbiA9IGlzRmlyc3RDaHVuayAmJiAobWVzc2FnZS5zdGFydHNXaXRoKCd7XCJmdW5jdGlvbl9jYWxsXCI6JykgfHwgbWVzc2FnZS5zdGFydHNXaXRoKCd7XCJ0b29sX2NhbGxzXCI6JykpO1xuICAgICAgaWYgKHNob3VsZEhhbmRsZUFzRnVuY3Rpb24pIHtcbiAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gdHJ1ZTtcbiAgICAgICAgYWdncmVnYXRlZFJlc3BvbnNlICs9IG1lc3NhZ2U7XG4gICAgICAgIGlzRmlyc3RDaHVuayA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWlzRnVuY3Rpb25TdHJlYW1pbmdJbikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKGZvcm1hdFN0cmVhbVBhcnQoXCJ0ZXh0XCIsIG1lc3NhZ2UpKVxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZ2dyZWdhdGVkUmVzcG9uc2UgKz0gbWVzc2FnZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFzeW5jIGZsdXNoKGNvbnRyb2xsZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghaXNGaXJzdENodW5rICYmIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiAmJiAoY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCB8fCBjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uVG9vbENhbGwpKSB7XG4gICAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gZmFsc2U7XG4gICAgICAgICAgY29uc3QgcGF5bG9hZCA9IEpTT04ucGFyc2UoYWdncmVnYXRlZFJlc3BvbnNlKTtcbiAgICAgICAgICBsZXQgbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXMgPSBbXG4gICAgICAgICAgICAuLi5mdW5jdGlvbkNhbGxNZXNzYWdlc1xuICAgICAgICAgIF07XG4gICAgICAgICAgbGV0IGZ1bmN0aW9uUmVzcG9uc2UgPSB2b2lkIDA7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwpIHtcbiAgICAgICAgICAgIGlmIChwYXlsb2FkLmZ1bmN0aW9uX2NhbGwgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgXCJleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgc2hvdWxkIG5vdCBiZSBkZWZpbmVkIHdoZW4gdXNpbmcgdG9vbHNcIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXJndW1lbnRzUGF5bG9hZCA9IEpTT04ucGFyc2UoXG4gICAgICAgICAgICAgIHBheWxvYWQuZnVuY3Rpb25fY2FsbC5hcmd1bWVudHNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmdW5jdGlvblJlc3BvbnNlID0gYXdhaXQgY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbChcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IHBheWxvYWQuZnVuY3Rpb25fY2FsbC5uYW1lLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50czogYXJndW1lbnRzUGF5bG9hZFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXMgPSBbXG4gICAgICAgICAgICAgICAgICAuLi5mdW5jdGlvbkNhbGxNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25fY2FsbDogcGF5bG9hZC5mdW5jdGlvbl9jYWxsXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByb2xlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHBheWxvYWQuZnVuY3Rpb25fY2FsbC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBKU09OLnN0cmluZ2lmeShyZXN1bHQpXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uVG9vbENhbGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvb2xDYWxscyA9IHtcbiAgICAgICAgICAgICAgdG9vbHM6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCB0b29sMiBvZiBwYXlsb2FkLnRvb2xfY2FsbHMpIHtcbiAgICAgICAgICAgICAgdG9vbENhbGxzLnRvb2xzLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkOiB0b29sMi5pZCxcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgZnVuYzoge1xuICAgICAgICAgICAgICAgICAgbmFtZTogdG9vbDIuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogSlNPTi5wYXJzZSh0b29sMi5mdW5jdGlvbi5hcmd1bWVudHMpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXNwb25zZUluZGV4ID0gMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2UgPSBhd2FpdCBjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uVG9vbENhbGwoXG4gICAgICAgICAgICAgICAgdG9vbENhbGxzLFxuICAgICAgICAgICAgICAgIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB0b29sX2NhbGxfaWQsIGZ1bmN0aW9uX25hbWUsIHRvb2xfY2FsbF9yZXN1bHQgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgLi4ubmV3RnVuY3Rpb25DYWxsTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBhcHBlbmQgdGhlIGFzc2lzdGFudCBtZXNzYWdlIGlmIGl0J3MgdGhlIGZpcnN0IHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgICAgLi4ucmVzcG9uc2VJbmRleCA9PT0gMCA/IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbF9jYWxsczogcGF5bG9hZC50b29sX2NhbGxzLm1hcChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGMpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogdGMuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0Yy5mdW5jdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBzZW5kIHRoZSBhcmd1bWVudHMgYW4gb2JqZWN0IHRvIHRoZSB1c2VyLCBidXQgYXMgdGhlIEFQSSBleHBlY3RzIGEgc3RyaW5nLCB3ZSBuZWVkIHRvIHN0cmluZ2lmeSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRjLmZ1bmN0aW9uLmFyZ3VtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIF0gOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIGZ1bmN0aW9uIGNhbGwgcmVzdWx0IG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb2xlOiBcInRvb2xcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xfY2FsbF9pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGZ1bmN0aW9uX25hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBKU09OLnN0cmluZ2lmeSh0b29sX2NhbGxfcmVzdWx0KVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNhbGxpbmcgZXhwZXJpbWVudGFsX29uVG9vbENhbGw6XCIsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWZ1bmN0aW9uUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKFxuICAgICAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQoXG4gICAgICAgICAgICAgICAgICBwYXlsb2FkLmZ1bmN0aW9uX2NhbGwgPyBcImZ1bmN0aW9uX2NhbGxcIiA6IFwidG9vbF9jYWxsc1wiLFxuICAgICAgICAgICAgICAgICAgLy8gcGFyc2UgdG8gcHJldmVudCBkb3VibGUtZW5jb2Rpbmc6XG4gICAgICAgICAgICAgICAgICBKU09OLnBhcnNlKGFnZ3JlZ2F0ZWRSZXNwb25zZSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZnVuY3Rpb25SZXNwb25zZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydChcInRleHRcIiwgZnVuY3Rpb25SZXNwb25zZSkpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYWdncmVnYXRlZEZpbmFsQ29tcGxldGlvblJlc3BvbnNlID0gZnVuY3Rpb25SZXNwb25zZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZmlsdGVyZWRDYWxsYmFja3MgPSB7XG4gICAgICAgICAgICAuLi5jYWxsYmFja3MsXG4gICAgICAgICAgICBvblN0YXJ0OiB2b2lkIDBcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNhbGxiYWNrcy5vbkZpbmFsID0gdm9pZCAwO1xuICAgICAgICAgIGNvbnN0IG9wZW5BSVN0cmVhbSA9IE9wZW5BSVN0cmVhbShmdW5jdGlvblJlc3BvbnNlLCB7XG4gICAgICAgICAgICAuLi5maWx0ZXJlZENhbGxiYWNrcyxcbiAgICAgICAgICAgIFtfX2ludGVybmFsX19PcGVuQUlGbk1lc3NhZ2VzU3ltYm9sXTogbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCByZWFkZXIgPSBvcGVuQUlTdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoY2FsbGJhY2tzLm9uRmluYWwgJiYgYWdncmVnYXRlZEZpbmFsQ29tcGxldGlvblJlc3BvbnNlKSB7XG4gICAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uRmluYWwoYWdncmVnYXRlZEZpbmFsQ29tcGxldGlvblJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbi8vIHN0cmVhbXMvcmVwbGljYXRlLXN0cmVhbS50c1xuYXN5bmMgZnVuY3Rpb24gUmVwbGljYXRlU3RyZWFtKHJlcywgY2IsIG9wdGlvbnMpIHtcbiAgdmFyIF9hO1xuICBjb25zdCB1cmwgPSAoX2EgPSByZXMudXJscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnN0cmVhbTtcbiAgaWYgKCF1cmwpIHtcbiAgICBpZiAocmVzLmVycm9yKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKHJlcy5lcnJvcik7XG4gICAgZWxzZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBzdHJlYW0gVVJMIGluIFJlcGxpY2F0ZSByZXNwb25zZVwiKTtcbiAgfVxuICBjb25zdCBldmVudFN0cmVhbSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICBoZWFkZXJzOiB7XG4gICAgICBBY2NlcHQ6IFwidGV4dC9ldmVudC1zdHJlYW1cIixcbiAgICAgIC4uLm9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBBSVN0cmVhbShldmVudFN0cmVhbSwgdm9pZCAwLCBjYikucGlwZVRocm91Z2goXG4gICAgY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKClcbiAgKTtcbn1cblxuLy8gc2hhcmVkL3BhcnNlLWNvbXBsZXgtcmVzcG9uc2UudHNcbmZ1bmN0aW9uIGFzc2lnbkFubm90YXRpb25zVG9NZXNzYWdlKG1lc3NhZ2UsIGFubm90YXRpb25zKSB7XG4gIGlmICghbWVzc2FnZSB8fCAhYW5ub3RhdGlvbnMgfHwgIWFubm90YXRpb25zLmxlbmd0aClcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgcmV0dXJuIHsgLi4ubWVzc2FnZSwgYW5ub3RhdGlvbnM6IFsuLi5hbm5vdGF0aW9uc10gfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHBhcnNlQ29tcGxleFJlc3BvbnNlKHtcbiAgcmVhZGVyLFxuICBhYm9ydENvbnRyb2xsZXJSZWYsXG4gIHVwZGF0ZSxcbiAgb25GaW5pc2gsXG4gIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQyID0gZ2VuZXJhdGVJZCxcbiAgZ2V0Q3VycmVudERhdGUgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKVxufSkge1xuICBjb25zdCBjcmVhdGVkQXQgPSBnZXRDdXJyZW50RGF0ZSgpO1xuICBjb25zdCBwcmVmaXhNYXAgPSB7XG4gICAgZGF0YTogW11cbiAgfTtcbiAgbGV0IG1lc3NhZ2VfYW5ub3RhdGlvbnMgPSB2b2lkIDA7XG4gIGZvciBhd2FpdCAoY29uc3QgeyB0eXBlLCB2YWx1ZSB9IG9mIHJlYWREYXRhU3RyZWFtKHJlYWRlciwge1xuICAgIGlzQWJvcnRlZDogKCkgPT4gKGFib3J0Q29udHJvbGxlclJlZiA9PSBudWxsID8gdm9pZCAwIDogYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQpID09PSBudWxsXG4gIH0pKSB7XG4gICAgaWYgKHR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICBpZiAocHJlZml4TWFwW1widGV4dFwiXSkge1xuICAgICAgICBwcmVmaXhNYXBbXCJ0ZXh0XCJdID0ge1xuICAgICAgICAgIC4uLnByZWZpeE1hcFtcInRleHRcIl0sXG4gICAgICAgICAgY29udGVudDogKHByZWZpeE1hcFtcInRleHRcIl0uY29udGVudCB8fCBcIlwiKSArIHZhbHVlXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmVmaXhNYXBbXCJ0ZXh0XCJdID0ge1xuICAgICAgICAgIGlkOiBnZW5lcmF0ZUlkMigpLFxuICAgICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgICAgY29udGVudDogdmFsdWUsXG4gICAgICAgICAgY3JlYXRlZEF0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBmdW5jdGlvbkNhbGxNZXNzYWdlID0gbnVsbDtcbiAgICBpZiAodHlwZSA9PT0gXCJmdW5jdGlvbl9jYWxsXCIpIHtcbiAgICAgIHByZWZpeE1hcFtcImZ1bmN0aW9uX2NhbGxcIl0gPSB7XG4gICAgICAgIGlkOiBnZW5lcmF0ZUlkMigpLFxuICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgICBmdW5jdGlvbl9jYWxsOiB2YWx1ZS5mdW5jdGlvbl9jYWxsLFxuICAgICAgICBuYW1lOiB2YWx1ZS5mdW5jdGlvbl9jYWxsLm5hbWUsXG4gICAgICAgIGNyZWF0ZWRBdFxuICAgICAgfTtcbiAgICAgIGZ1bmN0aW9uQ2FsbE1lc3NhZ2UgPSBwcmVmaXhNYXBbXCJmdW5jdGlvbl9jYWxsXCJdO1xuICAgIH1cbiAgICBsZXQgdG9vbENhbGxNZXNzYWdlID0gbnVsbDtcbiAgICBpZiAodHlwZSA9PT0gXCJ0b29sX2NhbGxzXCIpIHtcbiAgICAgIHByZWZpeE1hcFtcInRvb2xfY2FsbHNcIl0gPSB7XG4gICAgICAgIGlkOiBnZW5lcmF0ZUlkMigpLFxuICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgICB0b29sX2NhbGxzOiB2YWx1ZS50b29sX2NhbGxzLFxuICAgICAgICBjcmVhdGVkQXRcbiAgICAgIH07XG4gICAgICB0b29sQ2FsbE1lc3NhZ2UgPSBwcmVmaXhNYXBbXCJ0b29sX2NhbGxzXCJdO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJkYXRhXCIpIHtcbiAgICAgIHByZWZpeE1hcFtcImRhdGFcIl0ucHVzaCguLi52YWx1ZSk7XG4gICAgfVxuICAgIGxldCByZXNwb25zZU1lc3NhZ2UgPSBwcmVmaXhNYXBbXCJ0ZXh0XCJdO1xuICAgIGlmICh0eXBlID09PSBcIm1lc3NhZ2VfYW5ub3RhdGlvbnNcIikge1xuICAgICAgaWYgKCFtZXNzYWdlX2Fubm90YXRpb25zKSB7XG4gICAgICAgIG1lc3NhZ2VfYW5ub3RhdGlvbnMgPSBbLi4udmFsdWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVzc2FnZV9hbm5vdGF0aW9ucy5wdXNoKC4uLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uQ2FsbE1lc3NhZ2UgPSBhc3NpZ25Bbm5vdGF0aW9uc1RvTWVzc2FnZShcbiAgICAgICAgcHJlZml4TWFwW1wiZnVuY3Rpb25fY2FsbFwiXSxcbiAgICAgICAgbWVzc2FnZV9hbm5vdGF0aW9uc1xuICAgICAgKTtcbiAgICAgIHRvb2xDYWxsTWVzc2FnZSA9IGFzc2lnbkFubm90YXRpb25zVG9NZXNzYWdlKFxuICAgICAgICBwcmVmaXhNYXBbXCJ0b29sX2NhbGxzXCJdLFxuICAgICAgICBtZXNzYWdlX2Fubm90YXRpb25zXG4gICAgICApO1xuICAgICAgcmVzcG9uc2VNZXNzYWdlID0gYXNzaWduQW5ub3RhdGlvbnNUb01lc3NhZ2UoXG4gICAgICAgIHByZWZpeE1hcFtcInRleHRcIl0sXG4gICAgICAgIG1lc3NhZ2VfYW5ub3RhdGlvbnNcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlX2Fubm90YXRpb25zID09IG51bGwgPyB2b2lkIDAgOiBtZXNzYWdlX2Fubm90YXRpb25zLmxlbmd0aCkge1xuICAgICAgY29uc3QgbWVzc2FnZVByZWZpeEtleXMgPSBbXG4gICAgICAgIFwidGV4dFwiLFxuICAgICAgICBcImZ1bmN0aW9uX2NhbGxcIixcbiAgICAgICAgXCJ0b29sX2NhbGxzXCJcbiAgICAgIF07XG4gICAgICBtZXNzYWdlUHJlZml4S2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgaWYgKHByZWZpeE1hcFtrZXldKSB7XG4gICAgICAgICAgcHJlZml4TWFwW2tleV0uYW5ub3RhdGlvbnMgPSBbLi4ubWVzc2FnZV9hbm5vdGF0aW9uc107XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBtZXJnZWQgPSBbZnVuY3Rpb25DYWxsTWVzc2FnZSwgdG9vbENhbGxNZXNzYWdlLCByZXNwb25zZU1lc3NhZ2VdLmZpbHRlcihCb29sZWFuKS5tYXAoKG1lc3NhZ2UpID0+ICh7XG4gICAgICAuLi5hc3NpZ25Bbm5vdGF0aW9uc1RvTWVzc2FnZShtZXNzYWdlLCBtZXNzYWdlX2Fubm90YXRpb25zKVxuICAgIH0pKTtcbiAgICB1cGRhdGUobWVyZ2VkLCBbLi4ucHJlZml4TWFwW1wiZGF0YVwiXV0pO1xuICB9XG4gIG9uRmluaXNoID09IG51bGwgPyB2b2lkIDAgOiBvbkZpbmlzaChwcmVmaXhNYXApO1xuICByZXR1cm4ge1xuICAgIG1lc3NhZ2VzOiBbXG4gICAgICBwcmVmaXhNYXAudGV4dCxcbiAgICAgIHByZWZpeE1hcC5mdW5jdGlvbl9jYWxsLFxuICAgICAgcHJlZml4TWFwLnRvb2xfY2FsbHNcbiAgICBdLmZpbHRlcihCb29sZWFuKSxcbiAgICBkYXRhOiBwcmVmaXhNYXAuZGF0YVxuICB9O1xufVxuXG4vLyBzdHJlYW1zL3N0cmVhbWluZy1yZWFjdC1yZXNwb25zZS50c1xudmFyIGV4cGVyaW1lbnRhbF9TdHJlYW1pbmdSZWFjdFJlc3BvbnNlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihyZXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGxldCByZXNvbHZlRnVuYyA9ICgpID0+IHtcbiAgICB9O1xuICAgIGxldCBuZXh0ID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHJlc29sdmVGdW5jID0gcmVzb2x2ZTtcbiAgICB9KTtcbiAgICBjb25zdCBwcm9jZXNzZWRTdHJlYW0gPSAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5kYXRhKSAhPSBudWxsID8gcmVzLnBpcGVUaHJvdWdoKChfYSA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnN0cmVhbSkgOiByZXM7XG4gICAgbGV0IGxhc3RQYXlsb2FkID0gdm9pZCAwO1xuICAgIHBhcnNlQ29tcGxleFJlc3BvbnNlKHtcbiAgICAgIHJlYWRlcjogcHJvY2Vzc2VkU3RyZWFtLmdldFJlYWRlcigpLFxuICAgICAgdXBkYXRlOiAobWVyZ2VkLCBkYXRhKSA9PiB7XG4gICAgICAgIHZhciBfYTIsIF9iMiwgX2M7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSAoX2IyID0gKF9hMiA9IG1lcmdlZFswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5jb250ZW50KSAhPSBudWxsID8gX2IyIDogXCJcIjtcbiAgICAgICAgY29uc3QgdWkgPSAoKF9jID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy51aSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmNhbGwob3B0aW9ucywgeyBjb250ZW50LCBkYXRhIH0pKSB8fCBjb250ZW50O1xuICAgICAgICBjb25zdCBwYXlsb2FkID0geyB1aSwgY29udGVudCB9O1xuICAgICAgICBjb25zdCByZXNvbHZlUHJldmlvdXMgPSByZXNvbHZlRnVuYztcbiAgICAgICAgY29uc3QgbmV4dFJvdyA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZUZ1bmMgPSByZXNvbHZlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVzb2x2ZVByZXZpb3VzKHtcbiAgICAgICAgICBuZXh0OiBuZXh0Um93LFxuICAgICAgICAgIC4uLnBheWxvYWRcbiAgICAgICAgfSk7XG4gICAgICAgIGxhc3RQYXlsb2FkID0gcGF5bG9hZDtcbiAgICAgIH0sXG4gICAgICBnZW5lcmF0ZUlkOiAoX2IgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmdlbmVyYXRlSWQpICE9IG51bGwgPyBfYiA6IGdlbmVyYXRlSWQsXG4gICAgICBvbkZpbmlzaDogKCkgPT4ge1xuICAgICAgICBpZiAobGFzdFBheWxvYWQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJlc29sdmVGdW5jKHtcbiAgICAgICAgICAgIG5leHQ6IG51bGwsXG4gICAgICAgICAgICAuLi5sYXN0UGF5bG9hZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbn07XG5cbi8vIHN0cmVhbXMvc3RyZWFtaW5nLXRleHQtcmVzcG9uc2UudHNcbnZhciBTdHJlYW1pbmdUZXh0UmVzcG9uc2UgPSBjbGFzcyBleHRlbmRzIFJlc3BvbnNlIHtcbiAgY29uc3RydWN0b3IocmVzLCBpbml0LCBkYXRhKSB7XG4gICAgbGV0IHByb2Nlc3NlZFN0cmVhbSA9IHJlcztcbiAgICBpZiAoZGF0YSkge1xuICAgICAgcHJvY2Vzc2VkU3RyZWFtID0gcmVzLnBpcGVUaHJvdWdoKGRhdGEuc3RyZWFtKTtcbiAgICB9XG4gICAgc3VwZXIocHJvY2Vzc2VkU3RyZWFtLCB7XG4gICAgICAuLi5pbml0LFxuICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiLFxuICAgICAgICAuLi5pbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LmhlYWRlcnNcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIHN0cmVhbVRvUmVzcG9uc2UocmVzLCByZXNwb25zZSwgaW5pdCkge1xuICByZXNwb25zZS53cml0ZUhlYWQoKGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzKSB8fCAyMDAsIHtcbiAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIixcbiAgICAuLi5pbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LmhlYWRlcnNcbiAgfSk7XG4gIGNvbnN0IHJlYWRlciA9IHJlcy5nZXRSZWFkZXIoKTtcbiAgZnVuY3Rpb24gcmVhZCgpIHtcbiAgICByZWFkZXIucmVhZCgpLnRoZW4oKHsgZG9uZSwgdmFsdWUgfSkgPT4ge1xuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgcmVzcG9uc2UuZW5kKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlc3BvbnNlLndyaXRlKHZhbHVlKTtcbiAgICAgIHJlYWQoKTtcbiAgICB9KTtcbiAgfVxuICByZWFkKCk7XG59XG5leHBvcnQge1xuICBBSVN0cmVhbSxcbiAgQVBJQ2FsbEVycm9yMiBhcyBBUElDYWxsRXJyb3IsXG4gIEFXU0JlZHJvY2tBbnRocm9waWNNZXNzYWdlc1N0cmVhbSxcbiAgQVdTQmVkcm9ja0FudGhyb3BpY1N0cmVhbSxcbiAgQVdTQmVkcm9ja0NvaGVyZVN0cmVhbSxcbiAgQVdTQmVkcm9ja0xsYW1hMlN0cmVhbSxcbiAgQVdTQmVkcm9ja1N0cmVhbSxcbiAgQW50aHJvcGljU3RyZWFtLFxuICBBc3Npc3RhbnRSZXNwb25zZSxcbiAgQ29oZXJlU3RyZWFtLFxuICBFbXB0eVJlc3BvbnNlQm9keUVycm9yLFxuICBHZW5lcmF0ZU9iamVjdFJlc3VsdCxcbiAgR2VuZXJhdGVUZXh0UmVzdWx0LFxuICBHb29nbGVHZW5lcmF0aXZlQUlTdHJlYW0sXG4gIEh1Z2dpbmdGYWNlU3RyZWFtLFxuICBJbmtlZXBTdHJlYW0sXG4gIEludmFsaWRBcmd1bWVudEVycm9yMiBhcyBJbnZhbGlkQXJndW1lbnRFcnJvcixcbiAgSW52YWxpZERhdGFDb250ZW50RXJyb3IyIGFzIEludmFsaWREYXRhQ29udGVudEVycm9yLFxuICBJbnZhbGlkUHJvbXB0RXJyb3IyIGFzIEludmFsaWRQcm9tcHRFcnJvcixcbiAgSW52YWxpZFJlc3BvbnNlRGF0YUVycm9yLFxuICBJbnZhbGlkVG9vbEFyZ3VtZW50c0Vycm9yMiBhcyBJbnZhbGlkVG9vbEFyZ3VtZW50c0Vycm9yLFxuICBKU09OUGFyc2VFcnJvcixcbiAgTGFuZ0NoYWluU3RyZWFtLFxuICBMb2FkQVBJS2V5RXJyb3IsXG4gIE1pc3RyYWxTdHJlYW0sXG4gIE5vT2JqZWN0R2VuZXJhdGVkRXJyb3IyIGFzIE5vT2JqZWN0R2VuZXJhdGVkRXJyb3IsXG4gIE5vU3VjaFRvb2xFcnJvcjMgYXMgTm9TdWNoVG9vbEVycm9yLFxuICBPcGVuQUlTdHJlYW0sXG4gIFJlcGxpY2F0ZVN0cmVhbSxcbiAgUmV0cnlFcnJvcjIgYXMgUmV0cnlFcnJvcixcbiAgU3RyZWFtRGF0YSxcbiAgU3RyZWFtT2JqZWN0UmVzdWx0LFxuICBTdHJlYW1UZXh0UmVzdWx0LFxuICBTdHJlYW1pbmdUZXh0UmVzcG9uc2UsXG4gIFRvb2xDYWxsUGFyc2VFcnJvcixcbiAgVHlwZVZhbGlkYXRpb25FcnJvcixcbiAgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IsXG4gIFVuc3VwcG9ydGVkSlNPTlNjaGVtYUVycm9yLFxuICBjb252ZXJ0RGF0YUNvbnRlbnRUb0Jhc2U2NFN0cmluZyxcbiAgY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5LFxuICBjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcixcbiAgY3JlYXRlQ2h1bmtEZWNvZGVyLFxuICBjcmVhdGVFdmVudFN0cmVhbVRyYW5zZm9ybWVyLFxuICBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIsXG4gIGV4cGVyaW1lbnRhbF9Bc3Npc3RhbnRSZXNwb25zZSxcbiAgZXhwZXJpbWVudGFsX1N0cmVhbURhdGEsXG4gIGV4cGVyaW1lbnRhbF9TdHJlYW1pbmdSZWFjdFJlc3BvbnNlLFxuICBleHBlcmltZW50YWxfZ2VuZXJhdGVPYmplY3QsXG4gIGV4cGVyaW1lbnRhbF9nZW5lcmF0ZVRleHQsXG4gIGV4cGVyaW1lbnRhbF9zdHJlYW1PYmplY3QsXG4gIGV4cGVyaW1lbnRhbF9zdHJlYW1UZXh0LFxuICBmb3JtYXRTdHJlYW1QYXJ0LFxuICBnZW5lcmF0ZUlkLFxuICBpc1N0cmVhbVN0cmluZ0VxdWFsVG9UeXBlLFxuICBnZW5lcmF0ZUlkIGFzIG5hbm9pZCxcbiAgcGFyc2VTdHJlYW1QYXJ0LFxuICByZWFkRGF0YVN0cmVhbSxcbiAgcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZSxcbiAgc3RyZWFtVG9SZXNwb25zZSxcbiAgdG9vbCxcbiAgdHJpbVN0YXJ0T2ZTdHJlYW1IZWxwZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ai/dist/index.mjs\n");

/***/ })

};
;