/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/page"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fgabriellemia%2FWeb%20Dev%2Fprojects%2Fmy-chatbot%2Fmy-chatbot%2Fmy-ai-bot%2Fsrc%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!****************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fgabriellemia%2FWeb%20Dev%2Fprojects%2Fmy-chatbot%2Fmy-chatbot%2Fmy-ai-bot%2Fsrc%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \****************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/page.tsx */ \"(app-pages-browser)/./src/app/page.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGVXNlcnMlMkZnYWJyaWVsbGVtaWElMkZXZWIlMjBEZXYlMkZwcm9qZWN0cyUyRm15LWNoYXRib3QlMkZteS1jaGF0Ym90JTJGbXktYWktYm90JTJGc3JjJTJGYXBwJTJGcGFnZS50c3glMjIlMkMlMjJpZHMlMjIlM0ElNUIlNUQlN0Qmc2VydmVyPWZhbHNlISIsIm1hcHBpbmdzIjoiQUFBQSw4SkFBMEgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLz80YmRjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL2dhYnJpZWxsZW1pYS9XZWIgRGV2L3Byb2plY3RzL215LWNoYXRib3QvbXktY2hhdGJvdC9teS1haS1ib3Qvc3JjL2FwcC9wYWdlLnRzeFwiKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fgabriellemia%2FWeb%20Dev%2Fprojects%2Fmy-chatbot%2Fmy-chatbot%2Fmy-ai-bot%2Fsrc%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js ***!
  \**********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * use-sync-external-store-shim.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n\n          'use strict';\n\n/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n}\n          var React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x, y) {\n  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n  ;\n}\n\nvar objectIs = typeof Object.is === 'function' ? Object.is : is;\n\n// dispatch for CommonJS interop named imports.\n\nvar useState = React.useState,\n    useEffect = React.useEffect,\n    useLayoutEffect = React.useLayoutEffect,\n    useDebugValue = React.useDebugValue;\nvar didWarnOld18Alpha = false;\nvar didWarnUncachedGetSnapshot = false; // Disclaimer: This shim breaks many of the rules of React, and only works\n// because of a very particular set of implementation details and assumptions\n// -- change any one of them and it will break. The most important assumption\n// is that updates are always synchronous, because concurrent rendering is\n// only available in versions of React that also have a built-in\n// useSyncExternalStore API. And we only use this shim when the built-in API\n// does not exist.\n//\n// Do not assume that the clever hacks used by this hook also work in general.\n// The point of this shim is to replace the need for hacks by other libraries.\n\nfunction useSyncExternalStore(subscribe, getSnapshot, // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n// React do not expose a way to check if we're hydrating. So users of the shim\n// will need to track that themselves and return the correct value\n// from `getSnapshot`.\ngetServerSnapshot) {\n  {\n    if (!didWarnOld18Alpha) {\n      if (React.startTransition !== undefined) {\n        didWarnOld18Alpha = true;\n\n        error('You are using an outdated, pre-release alpha of React 18 that ' + 'does not support useSyncExternalStore. The ' + 'use-sync-external-store shim will not work correctly. Upgrade ' + 'to a newer pre-release.');\n      }\n    }\n  } // Read the current snapshot from the store on every render. Again, this\n  // breaks the rules of React, and only works here because of specific\n  // implementation details, most importantly that updates are\n  // always synchronous.\n\n\n  var value = getSnapshot();\n\n  {\n    if (!didWarnUncachedGetSnapshot) {\n      var cachedValue = getSnapshot();\n\n      if (!objectIs(value, cachedValue)) {\n        error('The result of getSnapshot should be cached to avoid an infinite loop');\n\n        didWarnUncachedGetSnapshot = true;\n      }\n    }\n  } // Because updates are synchronous, we don't queue them. Instead we force a\n  // re-render whenever the subscribed state changes by updating an some\n  // arbitrary useState hook. Then, during render, we call getSnapshot to read\n  // the current value.\n  //\n  // Because we don't actually use the state returned by the useState hook, we\n  // can save a bit of memory by storing other stuff in that slot.\n  //\n  // To implement the early bailout, we need to track some things on a mutable\n  // object. Usually, we would put that in a useRef hook, but we can stash it in\n  // our useState hook instead.\n  //\n  // To force a re-render, we call forceUpdate({inst}). That works because the\n  // new object always fails an equality check.\n\n\n  var _useState = useState({\n    inst: {\n      value: value,\n      getSnapshot: getSnapshot\n    }\n  }),\n      inst = _useState[0].inst,\n      forceUpdate = _useState[1]; // Track the latest getSnapshot function with a ref. This needs to be updated\n  // in the layout phase so we can access it during the tearing check that\n  // happens on subscribe.\n\n\n  useLayoutEffect(function () {\n    inst.value = value;\n    inst.getSnapshot = getSnapshot; // Whenever getSnapshot or subscribe changes, we need to check in the\n    // commit phase if there was an interleaved mutation. In concurrent mode\n    // this can happen all the time, but even in synchronous mode, an earlier\n    // effect may have mutated the store.\n\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceUpdate({\n        inst: inst\n      });\n    }\n  }, [subscribe, value, getSnapshot]);\n  useEffect(function () {\n    // Check for changes right before subscribing. Subsequent changes will be\n    // detected in the subscription handler.\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceUpdate({\n        inst: inst\n      });\n    }\n\n    var handleStoreChange = function () {\n      // TODO: Because there is no cross-renderer API for batching updates, it's\n      // up to the consumer of this library to wrap their subscription event\n      // with unstable_batchedUpdates. Should we try to detect when this isn't\n      // the case and print a warning in development?\n      // The store changed. Check if the snapshot changed since the last time we\n      // read from the store.\n      if (checkIfSnapshotChanged(inst)) {\n        // Force a re-render.\n        forceUpdate({\n          inst: inst\n        });\n      }\n    }; // Subscribe to the store and return a clean-up function.\n\n\n    return subscribe(handleStoreChange);\n  }, [subscribe]);\n  useDebugValue(value);\n  return value;\n}\n\nfunction checkIfSnapshotChanged(inst) {\n  var latestGetSnapshot = inst.getSnapshot;\n  var prevValue = inst.value;\n\n  try {\n    var nextValue = latestGetSnapshot();\n    return !objectIs(prevValue, nextValue);\n  } catch (error) {\n    return true;\n  }\n}\n\nfunction useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {\n  // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n  // React do not expose a way to check if we're hydrating. So users of the shim\n  // will need to track that themselves and return the correct value\n  // from `getSnapshot`.\n  return getSnapshot();\n}\n\nvar canUseDOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');\n\nvar isServerEnvironment = !canUseDOM;\n\nvar shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;\nvar useSyncExternalStore$2 = React.useSyncExternalStore !== undefined ? React.useSyncExternalStore : shim;\n\nexports.useSyncExternalStore = useSyncExternalStore$2;\n          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n}\n        \n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsbUZBQU87O0FBRXJDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEtBQUs7QUFDckQ7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87OztBQUdQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL2Nqcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltLmRldmVsb3BtZW50LmpzPzQxNzciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbi8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbmlmIChcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQgPT09XG4gICAgJ2Z1bmN0aW9uJ1xuKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQobmV3IEVycm9yKCkpO1xufVxuICAgICAgICAgIHZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgcmV0dXJuIHggPT09IHkgJiYgKHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5KSB8fCB4ICE9PSB4ICYmIHkgIT09IHkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgO1xufVxuXG52YXIgb2JqZWN0SXMgPSB0eXBlb2YgT2JqZWN0LmlzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmlzIDogaXM7XG5cbi8vIGRpc3BhdGNoIGZvciBDb21tb25KUyBpbnRlcm9wIG5hbWVkIGltcG9ydHMuXG5cbnZhciB1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlLFxuICAgIHVzZUVmZmVjdCA9IFJlYWN0LnVzZUVmZmVjdCxcbiAgICB1c2VMYXlvdXRFZmZlY3QgPSBSZWFjdC51c2VMYXlvdXRFZmZlY3QsXG4gICAgdXNlRGVidWdWYWx1ZSA9IFJlYWN0LnVzZURlYnVnVmFsdWU7XG52YXIgZGlkV2Fybk9sZDE4QWxwaGEgPSBmYWxzZTtcbnZhciBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCA9IGZhbHNlOyAvLyBEaXNjbGFpbWVyOiBUaGlzIHNoaW0gYnJlYWtzIG1hbnkgb2YgdGhlIHJ1bGVzIG9mIFJlYWN0LCBhbmQgb25seSB3b3Jrc1xuLy8gYmVjYXVzZSBvZiBhIHZlcnkgcGFydGljdWxhciBzZXQgb2YgaW1wbGVtZW50YXRpb24gZGV0YWlscyBhbmQgYXNzdW1wdGlvbnNcbi8vIC0tIGNoYW5nZSBhbnkgb25lIG9mIHRoZW0gYW5kIGl0IHdpbGwgYnJlYWsuIFRoZSBtb3N0IGltcG9ydGFudCBhc3N1bXB0aW9uXG4vLyBpcyB0aGF0IHVwZGF0ZXMgYXJlIGFsd2F5cyBzeW5jaHJvbm91cywgYmVjYXVzZSBjb25jdXJyZW50IHJlbmRlcmluZyBpc1xuLy8gb25seSBhdmFpbGFibGUgaW4gdmVyc2lvbnMgb2YgUmVhY3QgdGhhdCBhbHNvIGhhdmUgYSBidWlsdC1pblxuLy8gdXNlU3luY0V4dGVybmFsU3RvcmUgQVBJLiBBbmQgd2Ugb25seSB1c2UgdGhpcyBzaGltIHdoZW4gdGhlIGJ1aWx0LWluIEFQSVxuLy8gZG9lcyBub3QgZXhpc3QuXG4vL1xuLy8gRG8gbm90IGFzc3VtZSB0aGF0IHRoZSBjbGV2ZXIgaGFja3MgdXNlZCBieSB0aGlzIGhvb2sgYWxzbyB3b3JrIGluIGdlbmVyYWwuXG4vLyBUaGUgcG9pbnQgb2YgdGhpcyBzaGltIGlzIHRvIHJlcGxhY2UgdGhlIG5lZWQgZm9yIGhhY2tzIGJ5IG90aGVyIGxpYnJhcmllcy5cblxuZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgLy8gTm90ZTogVGhlIHNoaW0gZG9lcyBub3QgdXNlIGdldFNlcnZlclNuYXBzaG90LCBiZWNhdXNlIHByZS0xOCB2ZXJzaW9ucyBvZlxuLy8gUmVhY3QgZG8gbm90IGV4cG9zZSBhIHdheSB0byBjaGVjayBpZiB3ZSdyZSBoeWRyYXRpbmcuIFNvIHVzZXJzIG9mIHRoZSBzaGltXG4vLyB3aWxsIG5lZWQgdG8gdHJhY2sgdGhhdCB0aGVtc2VsdmVzIGFuZCByZXR1cm4gdGhlIGNvcnJlY3QgdmFsdWVcbi8vIGZyb20gYGdldFNuYXBzaG90YC5cbmdldFNlcnZlclNuYXBzaG90KSB7XG4gIHtcbiAgICBpZiAoIWRpZFdhcm5PbGQxOEFscGhhKSB7XG4gICAgICBpZiAoUmVhY3Quc3RhcnRUcmFuc2l0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGlkV2Fybk9sZDE4QWxwaGEgPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCdZb3UgYXJlIHVzaW5nIGFuIG91dGRhdGVkLCBwcmUtcmVsZWFzZSBhbHBoYSBvZiBSZWFjdCAxOCB0aGF0ICcgKyAnZG9lcyBub3Qgc3VwcG9ydCB1c2VTeW5jRXh0ZXJuYWxTdG9yZS4gVGhlICcgKyAndXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUgc2hpbSB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseS4gVXBncmFkZSAnICsgJ3RvIGEgbmV3ZXIgcHJlLXJlbGVhc2UuJyk7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFJlYWQgdGhlIGN1cnJlbnQgc25hcHNob3QgZnJvbSB0aGUgc3RvcmUgb24gZXZlcnkgcmVuZGVyLiBBZ2FpbiwgdGhpc1xuICAvLyBicmVha3MgdGhlIHJ1bGVzIG9mIFJlYWN0LCBhbmQgb25seSB3b3JrcyBoZXJlIGJlY2F1c2Ugb2Ygc3BlY2lmaWNcbiAgLy8gaW1wbGVtZW50YXRpb24gZGV0YWlscywgbW9zdCBpbXBvcnRhbnRseSB0aGF0IHVwZGF0ZXMgYXJlXG4gIC8vIGFsd2F5cyBzeW5jaHJvbm91cy5cblxuXG4gIHZhciB2YWx1ZSA9IGdldFNuYXBzaG90KCk7XG5cbiAge1xuICAgIGlmICghZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QpIHtcbiAgICAgIHZhciBjYWNoZWRWYWx1ZSA9IGdldFNuYXBzaG90KCk7XG5cbiAgICAgIGlmICghb2JqZWN0SXModmFsdWUsIGNhY2hlZFZhbHVlKSkge1xuICAgICAgICBlcnJvcignVGhlIHJlc3VsdCBvZiBnZXRTbmFwc2hvdCBzaG91bGQgYmUgY2FjaGVkIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3AnKTtcblxuICAgICAgICBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIEJlY2F1c2UgdXBkYXRlcyBhcmUgc3luY2hyb25vdXMsIHdlIGRvbid0IHF1ZXVlIHRoZW0uIEluc3RlYWQgd2UgZm9yY2UgYVxuICAvLyByZS1yZW5kZXIgd2hlbmV2ZXIgdGhlIHN1YnNjcmliZWQgc3RhdGUgY2hhbmdlcyBieSB1cGRhdGluZyBhbiBzb21lXG4gIC8vIGFyYml0cmFyeSB1c2VTdGF0ZSBob29rLiBUaGVuLCBkdXJpbmcgcmVuZGVyLCB3ZSBjYWxsIGdldFNuYXBzaG90IHRvIHJlYWRcbiAgLy8gdGhlIGN1cnJlbnQgdmFsdWUuXG4gIC8vXG4gIC8vIEJlY2F1c2Ugd2UgZG9uJ3QgYWN0dWFsbHkgdXNlIHRoZSBzdGF0ZSByZXR1cm5lZCBieSB0aGUgdXNlU3RhdGUgaG9vaywgd2VcbiAgLy8gY2FuIHNhdmUgYSBiaXQgb2YgbWVtb3J5IGJ5IHN0b3Jpbmcgb3RoZXIgc3R1ZmYgaW4gdGhhdCBzbG90LlxuICAvL1xuICAvLyBUbyBpbXBsZW1lbnQgdGhlIGVhcmx5IGJhaWxvdXQsIHdlIG5lZWQgdG8gdHJhY2sgc29tZSB0aGluZ3Mgb24gYSBtdXRhYmxlXG4gIC8vIG9iamVjdC4gVXN1YWxseSwgd2Ugd291bGQgcHV0IHRoYXQgaW4gYSB1c2VSZWYgaG9vaywgYnV0IHdlIGNhbiBzdGFzaCBpdCBpblxuICAvLyBvdXIgdXNlU3RhdGUgaG9vayBpbnN0ZWFkLlxuICAvL1xuICAvLyBUbyBmb3JjZSBhIHJlLXJlbmRlciwgd2UgY2FsbCBmb3JjZVVwZGF0ZSh7aW5zdH0pLiBUaGF0IHdvcmtzIGJlY2F1c2UgdGhlXG4gIC8vIG5ldyBvYmplY3QgYWx3YXlzIGZhaWxzIGFuIGVxdWFsaXR5IGNoZWNrLlxuXG5cbiAgdmFyIF91c2VTdGF0ZSA9IHVzZVN0YXRlKHtcbiAgICBpbnN0OiB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBnZXRTbmFwc2hvdDogZ2V0U25hcHNob3RcbiAgICB9XG4gIH0pLFxuICAgICAgaW5zdCA9IF91c2VTdGF0ZVswXS5pbnN0LFxuICAgICAgZm9yY2VVcGRhdGUgPSBfdXNlU3RhdGVbMV07IC8vIFRyYWNrIHRoZSBsYXRlc3QgZ2V0U25hcHNob3QgZnVuY3Rpb24gd2l0aCBhIHJlZi4gVGhpcyBuZWVkcyB0byBiZSB1cGRhdGVkXG4gIC8vIGluIHRoZSBsYXlvdXQgcGhhc2Ugc28gd2UgY2FuIGFjY2VzcyBpdCBkdXJpbmcgdGhlIHRlYXJpbmcgY2hlY2sgdGhhdFxuICAvLyBoYXBwZW5zIG9uIHN1YnNjcmliZS5cblxuXG4gIHVzZUxheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaW5zdC52YWx1ZSA9IHZhbHVlO1xuICAgIGluc3QuZ2V0U25hcHNob3QgPSBnZXRTbmFwc2hvdDsgLy8gV2hlbmV2ZXIgZ2V0U25hcHNob3Qgb3Igc3Vic2NyaWJlIGNoYW5nZXMsIHdlIG5lZWQgdG8gY2hlY2sgaW4gdGhlXG4gICAgLy8gY29tbWl0IHBoYXNlIGlmIHRoZXJlIHdhcyBhbiBpbnRlcmxlYXZlZCBtdXRhdGlvbi4gSW4gY29uY3VycmVudCBtb2RlXG4gICAgLy8gdGhpcyBjYW4gaGFwcGVuIGFsbCB0aGUgdGltZSwgYnV0IGV2ZW4gaW4gc3luY2hyb25vdXMgbW9kZSwgYW4gZWFybGllclxuICAgIC8vIGVmZmVjdCBtYXkgaGF2ZSBtdXRhdGVkIHRoZSBzdG9yZS5cblxuICAgIGlmIChjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpKSB7XG4gICAgICAvLyBGb3JjZSBhIHJlLXJlbmRlci5cbiAgICAgIGZvcmNlVXBkYXRlKHtcbiAgICAgICAgaW5zdDogaW5zdFxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbc3Vic2NyaWJlLCB2YWx1ZSwgZ2V0U25hcHNob3RdKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAvLyBDaGVjayBmb3IgY2hhbmdlcyByaWdodCBiZWZvcmUgc3Vic2NyaWJpbmcuIFN1YnNlcXVlbnQgY2hhbmdlcyB3aWxsIGJlXG4gICAgLy8gZGV0ZWN0ZWQgaW4gdGhlIHN1YnNjcmlwdGlvbiBoYW5kbGVyLlxuICAgIGlmIChjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpKSB7XG4gICAgICAvLyBGb3JjZSBhIHJlLXJlbmRlci5cbiAgICAgIGZvcmNlVXBkYXRlKHtcbiAgICAgICAgaW5zdDogaW5zdFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGhhbmRsZVN0b3JlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVE9ETzogQmVjYXVzZSB0aGVyZSBpcyBubyBjcm9zcy1yZW5kZXJlciBBUEkgZm9yIGJhdGNoaW5nIHVwZGF0ZXMsIGl0J3NcbiAgICAgIC8vIHVwIHRvIHRoZSBjb25zdW1lciBvZiB0aGlzIGxpYnJhcnkgdG8gd3JhcCB0aGVpciBzdWJzY3JpcHRpb24gZXZlbnRcbiAgICAgIC8vIHdpdGggdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMuIFNob3VsZCB3ZSB0cnkgdG8gZGV0ZWN0IHdoZW4gdGhpcyBpc24ndFxuICAgICAgLy8gdGhlIGNhc2UgYW5kIHByaW50IGEgd2FybmluZyBpbiBkZXZlbG9wbWVudD9cbiAgICAgIC8vIFRoZSBzdG9yZSBjaGFuZ2VkLiBDaGVjayBpZiB0aGUgc25hcHNob3QgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHdlXG4gICAgICAvLyByZWFkIGZyb20gdGhlIHN0b3JlLlxuICAgICAgaWYgKGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkpIHtcbiAgICAgICAgLy8gRm9yY2UgYSByZS1yZW5kZXIuXG4gICAgICAgIGZvcmNlVXBkYXRlKHtcbiAgICAgICAgICBpbnN0OiBpbnN0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07IC8vIFN1YnNjcmliZSB0byB0aGUgc3RvcmUgYW5kIHJldHVybiBhIGNsZWFuLXVwIGZ1bmN0aW9uLlxuXG5cbiAgICByZXR1cm4gc3Vic2NyaWJlKGhhbmRsZVN0b3JlQ2hhbmdlKTtcbiAgfSwgW3N1YnNjcmliZV0pO1xuICB1c2VEZWJ1Z1ZhbHVlKHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpIHtcbiAgdmFyIGxhdGVzdEdldFNuYXBzaG90ID0gaW5zdC5nZXRTbmFwc2hvdDtcbiAgdmFyIHByZXZWYWx1ZSA9IGluc3QudmFsdWU7XG5cbiAgdHJ5IHtcbiAgICB2YXIgbmV4dFZhbHVlID0gbGF0ZXN0R2V0U25hcHNob3QoKTtcbiAgICByZXR1cm4gIW9iamVjdElzKHByZXZWYWx1ZSwgbmV4dFZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VTeW5jRXh0ZXJuYWxTdG9yZSQxKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gIC8vIE5vdGU6IFRoZSBzaGltIGRvZXMgbm90IHVzZSBnZXRTZXJ2ZXJTbmFwc2hvdCwgYmVjYXVzZSBwcmUtMTggdmVyc2lvbnMgb2ZcbiAgLy8gUmVhY3QgZG8gbm90IGV4cG9zZSBhIHdheSB0byBjaGVjayBpZiB3ZSdyZSBoeWRyYXRpbmcuIFNvIHVzZXJzIG9mIHRoZSBzaGltXG4gIC8vIHdpbGwgbmVlZCB0byB0cmFjayB0aGF0IHRoZW1zZWx2ZXMgYW5kIHJldHVybiB0aGUgY29ycmVjdCB2YWx1ZVxuICAvLyBmcm9tIGBnZXRTbmFwc2hvdGAuXG4gIHJldHVybiBnZXRTbmFwc2hvdCgpO1xufVxuXG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJyk7XG5cbnZhciBpc1NlcnZlckVudmlyb25tZW50ID0gIWNhblVzZURPTTtcblxudmFyIHNoaW0gPSBpc1NlcnZlckVudmlyb25tZW50ID8gdXNlU3luY0V4dGVybmFsU3RvcmUkMSA6IHVzZVN5bmNFeHRlcm5hbFN0b3JlO1xudmFyIHVzZVN5bmNFeHRlcm5hbFN0b3JlJDIgPSBSZWFjdC51c2VTeW5jRXh0ZXJuYWxTdG9yZSAhPT0gdW5kZWZpbmVkID8gUmVhY3QudXNlU3luY0V4dGVybmFsU3RvcmUgOiBzaGltO1xuXG5leHBvcnRzLnVzZVN5bmNFeHRlcm5hbFN0b3JlID0gdXNlU3luY0V4dGVybmFsU3RvcmUkMjtcbiAgICAgICAgICAvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG5pZiAoXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AgPT09XG4gICAgJ2Z1bmN0aW9uJ1xuKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcChuZXcgRXJyb3IoKSk7XG59XG4gICAgICAgIFxuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/use-sync-external-store/shim/index.js":
/*!************************************************************!*\
  !*** ./node_modules/use-sync-external-store/shim/index.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ../cjs/use-sync-external-store-shim.development.js */ \"(app-pages-browser)/./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw0TUFBOEU7QUFDaEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0vaW5kZXguanM/ODE4NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vY2pzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0ucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vY2pzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0uZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/use-sync-external-store/shim/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/page.tsx":
/*!**************************!*\
  !*** ./src/app/page.tsx ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Chat; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var ai_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ai/react */ \"(app-pages-browser)/./node_modules/ai/react/dist/index.mjs\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nfunction Chat() {\n    _s();\n    const { messages, input, handleInputChange, handleSubmit } = (0,ai_react__WEBPACK_IMPORTED_MODULE_1__.useChat)();\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"main-container\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                className: \"title\",\n                children: \"GabyGPT\"\n            }, void 0, false, {\n                fileName: \"/Users/gabriellemia/Web Dev/projects/my-chatbot/my-chatbot/my-ai-bot/src/app/page.tsx\",\n                lineNumber: 9,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"chatbot\",\n                children: [\n                    messages.map((message)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"chatHistory \".concat(message.role === \"user\" ? \"userMessage\" : \"aiMessage\"),\n                            children: message.content\n                        }, message.id, false, {\n                            fileName: \"/Users/gabriellemia/Web Dev/projects/my-chatbot/my-chatbot/my-ai-bot/src/app/page.tsx\",\n                            lineNumber: 12,\n                            columnNumber: 11\n                        }, this)),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"form\", {\n                        onSubmit: handleSubmit,\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                className: \"inputField\",\n                                value: input,\n                                placeholder: \"Ask me anything...\",\n                                onChange: handleInputChange\n                            }, void 0, false, {\n                                fileName: \"/Users/gabriellemia/Web Dev/projects/my-chatbot/my-chatbot/my-ai-bot/src/app/page.tsx\",\n                                lineNumber: 19,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                className: \"button\",\n                                type: \"submit\",\n                                children: \"Go\"\n                            }, void 0, false, {\n                                fileName: \"/Users/gabriellemia/Web Dev/projects/my-chatbot/my-chatbot/my-ai-bot/src/app/page.tsx\",\n                                lineNumber: 20,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/gabriellemia/Web Dev/projects/my-chatbot/my-chatbot/my-ai-bot/src/app/page.tsx\",\n                        lineNumber: 18,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/gabriellemia/Web Dev/projects/my-chatbot/my-chatbot/my-ai-bot/src/app/page.tsx\",\n                lineNumber: 10,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/gabriellemia/Web Dev/projects/my-chatbot/my-chatbot/my-ai-bot/src/app/page.tsx\",\n        lineNumber: 8,\n        columnNumber: 5\n    }, this);\n}\n_s(Chat, \"huPK7I7CsQMAUkxk7W0gSV/2cq0=\", false, function() {\n    return [\n        ai_react__WEBPACK_IMPORTED_MODULE_1__.useChat\n    ];\n});\n_c = Chat;\nvar _c;\n$RefreshReg$(_c, \"Chat\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvcGFnZS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFFbUM7QUFFcEIsU0FBU0M7O0lBQ3RCLE1BQU0sRUFBRUMsUUFBUSxFQUFFQyxLQUFLLEVBQUVDLGlCQUFpQixFQUFFQyxZQUFZLEVBQUUsR0FBR0wsaURBQU9BO0lBQ3BFLHFCQUNFLDhEQUFDTTtRQUFJQyxXQUFVOzswQkFDYiw4REFBQ0M7Z0JBQUdELFdBQVU7MEJBQVE7Ozs7OzswQkFDdEIsOERBQUNEO2dCQUFJQyxXQUFVOztvQkFDWkwsU0FBU08sR0FBRyxDQUFDLENBQUNDLHdCQUNiLDhEQUFDSjs0QkFBcUJDLFdBQVcsZUFBcUUsT0FBdERHLFFBQVFDLElBQUksS0FBSyxTQUFTLGdCQUFnQjtzQ0FFdkZELFFBQVFFLE9BQU87MkJBRlJGLFFBQVFHLEVBQUU7Ozs7O2tDQU10Qiw4REFBQ0M7d0JBQUtDLFVBQVVWOzswQ0FDZCw4REFBQ0Y7Z0NBQU1JLFdBQVU7Z0NBQWFTLE9BQU9iO2dDQUFPYyxhQUFZO2dDQUFxQkMsVUFBVWQ7Ozs7OzswQ0FDdkYsOERBQUNlO2dDQUFPWixXQUFVO2dDQUFTYSxNQUFLOzBDQUFTOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFPbkQ7R0F0QndCbkI7O1FBQ3VDRCw2Q0FBT0E7OztLQUQ5Q0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2FwcC9wYWdlLnRzeD9mNjhhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgeyB1c2VDaGF0IH0gZnJvbSBcImFpL3JlYWN0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENoYXQoKSB7XG4gIGNvbnN0IHsgbWVzc2FnZXMsIGlucHV0LCBoYW5kbGVJbnB1dENoYW5nZSwgaGFuZGxlU3VibWl0IH0gPSB1c2VDaGF0KCk7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJtYWluLWNvbnRhaW5lclwiPlxuICAgICAgPGgxIGNsYXNzTmFtZT1cInRpdGxlXCI+R2FieUdQVDwvaDE+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImNoYXRib3RcIj5cbiAgICAgICAge21lc3NhZ2VzLm1hcCgobWVzc2FnZSkgPT4gKFxuICAgICAgICAgIDxkaXYga2V5PXttZXNzYWdlLmlkfSBjbGFzc05hbWU9e2BjaGF0SGlzdG9yeSAke21lc3NhZ2Uucm9sZSA9PT0gXCJ1c2VyXCIgPyBcInVzZXJNZXNzYWdlXCIgOiBcImFpTWVzc2FnZVwifWB9PlxuICAgICAgICAgICAgey8qIHttZXNzYWdlLnJvbGUgPT09IFwidXNlclwiID8gXCJVc2VyOiBcIiA6IFwiQUk6IFwifSAqL31cbiAgICAgICAgICAgIHttZXNzYWdlLmNvbnRlbnR9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICkpfVxuXG4gICAgICAgIDxmb3JtIG9uU3VibWl0PXtoYW5kbGVTdWJtaXR9PlxuICAgICAgICAgIDxpbnB1dCBjbGFzc05hbWU9XCJpbnB1dEZpZWxkXCIgdmFsdWU9e2lucHV0fSBwbGFjZWhvbGRlcj1cIkFzayBtZSBhbnl0aGluZy4uLlwiIG9uQ2hhbmdlPXtoYW5kbGVJbnB1dENoYW5nZX0gLz5cbiAgICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT1cImJ1dHRvblwiIHR5cGU9XCJzdWJtaXRcIj5cbiAgICAgICAgICAgIEdvXG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDwvZm9ybT5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufVxuIl0sIm5hbWVzIjpbInVzZUNoYXQiLCJDaGF0IiwibWVzc2FnZXMiLCJpbnB1dCIsImhhbmRsZUlucHV0Q2hhbmdlIiwiaGFuZGxlU3VibWl0IiwiZGl2IiwiY2xhc3NOYW1lIiwiaDEiLCJtYXAiLCJtZXNzYWdlIiwicm9sZSIsImNvbnRlbnQiLCJpZCIsImZvcm0iLCJvblN1Ym1pdCIsInZhbHVlIiwicGxhY2Vob2xkZXIiLCJvbkNoYW5nZSIsImJ1dHRvbiIsInR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider'); // TODO: Delete with enableRenderableContext\n\nvar REACT_CONSUMER_TYPE = Symbol.for('react.consumer');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\nvar enableRenderableContext = false;\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false;\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n}\n\nvar REACT_CLIENT_REFERENCE$2 = Symbol.for('react.client.reference'); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  if (typeof type === 'function') {\n    if (type.$$typeof === REACT_CLIENT_REFERENCE$2) {\n      // TODO: Create a convention for naming client references with debug info.\n      return null;\n    }\n\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    {\n      if (typeof type.tag === 'number') {\n        error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n      }\n    }\n\n    switch (type.$$typeof) {\n      case REACT_PROVIDER_TYPE:\n        {\n          var provider = type;\n          return getContextName(provider._context) + '.Provider';\n        }\n\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n\n        {\n          return getContextName(context) + '.Consumer';\n        }\n\n      case REACT_CONSUMER_TYPE:\n        {\n          return null;\n        }\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n    }\n  }\n\n  return null;\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar assign = Object.assign;\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || enableRenderableContext  || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n/**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */\n\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n  /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */\n\n\n  var RunInRootFrame = {\n    DetermineComponentFrameRoot: function () {\n      var control;\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe[prop-missing]\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          } // TODO(luna): This will currently only throw if the function component\n          // tries to access React/ReactDOM/props. We should probably make this throw\n          // in simple components too\n\n\n          var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n          // component, which we don't yet support. Attach a noop catch handler to\n          // silence the error.\n          // TODO: Implement component stacks for async client components?\n\n          if (maybePromise && typeof maybePromise.catch === 'function') {\n            maybePromise.catch(function () {});\n          }\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          return [sample.stack, control.stack];\n        }\n      }\n\n      return [null, null];\n    }\n  }; // $FlowFixMe[prop-missing]\n\n  RunInRootFrame.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot';\n  var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, 'name'); // Before ES6, the `name` property was not configurable.\n\n  if (namePropDescriptor && namePropDescriptor.configurable) {\n    // V8 utilizes a function's `name` property when generating a stack trace.\n    Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // Configurable properties can be updated even if its writable descriptor\n    // is set to `false`.\n    // $FlowFixMe[cannot-write]\n    'name', {\n      value: 'DetermineComponentFrameRoot'\n    });\n  }\n\n  try {\n    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),\n        sampleStack = _RunInRootFrame$Deter[0],\n        controlStack = _RunInRootFrame$Deter[1];\n\n    if (sampleStack && controlStack) {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sampleStack.split('\\n');\n      var controlLines = controlStack.split('\\n');\n      var s = 0;\n      var c = 0;\n\n      while (s < sampleLines.length && !sampleLines[s].includes('DetermineComponentFrameRoot')) {\n        s++;\n      }\n\n      while (c < controlLines.length && !controlLines[c].includes('DetermineComponentFrameRoot')) {\n        c++;\n      } // We couldn't find our intentionally injected common root frame, attempt\n      // to find another common root frame by search from the bottom of the\n      // control stack...\n\n\n      if (s === sampleLines.length || c === controlLines.length) {\n        s = sampleLines.length - 1;\n        c = controlLines.length - 1;\n\n        while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n          // We expect at least one stack frame to be shared.\n          // Typically this will be the root most one. However, stack frames may be\n          // cut off due to maximum stack limits. In this case, one maybe cut off\n          // earlier than the other. We assume that the sample is longer or the same\n          // and there for cut off earlier. So we should find the root most frame in\n          // the sample somewhere in the control.\n          c--;\n        }\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                if (true) {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    {\n      var warnAboutAccessingRef = function () {\n        if (!specialPropRefWarningShown) {\n          specialPropRefWarningShown = true;\n\n          error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n        }\n      };\n\n      warnAboutAccessingRef.isReactWarning = true;\n      Object.defineProperty(props, 'ref', {\n        get: warnAboutAccessingRef,\n        configurable: true\n      });\n    }\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, _ref, self, source, owner, props) {\n  var ref;\n\n  {\n    ref = _ref;\n  }\n\n  var element;\n\n  {\n    // In prod, `ref` is a regular property. It will be removed in a\n    // future release.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n      // Built-in properties that belong on the element\n      type: type,\n      key: key,\n      ref: ref,\n      props: props,\n      // Record the component responsible for creating this element.\n      _owner: owner\n    };\n  }\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // debugInfo contains Server Component debug information.\n\n    Object.defineProperty(element, '_debugInfo', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: null\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\nvar didWarnAboutKeySpread = {};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV$1(type, config, maybeKey, isStaticChildren, source, self) {\n  {\n    if (!isValidElementType(type)) {\n      // This is an invalid element type.\n      //\n      // We warn in this case but don't throw. We expect the element creation to\n      // succeed and there will likely be errors in render.\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    } else {\n      // This is a valid element type.\n      // Skip key warning if the type isn't valid since our key validation logic\n      // doesn't expect a non-string/function type and can throw confusing\n      // errors. We don't want exception behavior to differ between dev and\n      // prod. (Rendering will throw with a helpful message and as soon as the\n      // type is fixed, the key warnings will appear.)\n      var children = config.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    } // Warn about key spread regardless of whether the type is valid.\n\n\n    if (hasOwnProperty.call(config, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(config).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      {\n        ref = config.ref;\n      }\n\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && // Skip over reserved prop names\n      propName !== 'key' && (propName !== 'ref')) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    var element = ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    }\n\n    return element;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nvar ownerHasKeyUseWarning = {};\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = getComponentNameFromType(parentType);\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  // TODO: Move this to render phase instead of at element creation.\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar jsxDEV = jsxDEV$1 ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxzR0FBMEI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBLHFDQUFxQzs7QUFFckMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBLHFFQUFxRTs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHOztBQUVsRztBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLGVBQWU7QUFDMUIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QUFXLGNBQWM7QUFDekI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcz9iNGE3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTsgLy8gVE9ETzogRGVsZXRlIHdpdGggZW5hYmxlUmVuZGVyYWJsZUNvbnRleHRcblxudmFyIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb25zdW1lcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0NBQ0hFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jYWNoZScpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG52YXIgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgPSBmYWxzZTtcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMikge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcblxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cbi8qKlxuICogTGV2ZXJhZ2VzIG5hdGl2ZSBicm93c2VyL1ZNIHN0YWNrIGZyYW1lcyB0byBnZXQgcHJvcGVyIGRldGFpbHMgKGUuZy5cbiAqIGZpbGVuYW1lLCBsaW5lICsgY29sIG51bWJlcikgZm9yIGEgc2luZ2xlIGNvbXBvbmVudCBpbiBhIGNvbXBvbmVudCBzdGFjay4gV2VcbiAqIGRvIHRoaXMgYnk6XG4gKiAgICgxKSB0aHJvd2luZyBhbmQgY2F0Y2hpbmcgYW4gZXJyb3IgaW4gdGhlIGZ1bmN0aW9uIC0gdGhpcyB3aWxsIGJlIG91clxuICogICAgICAgY29udHJvbCBlcnJvci5cbiAqICAgKDIpIGNhbGxpbmcgdGhlIGNvbXBvbmVudCB3aGljaCB3aWxsIGV2ZW50dWFsbHkgdGhyb3cgYW4gZXJyb3IgdGhhdCB3ZSdsbFxuICogICAgICAgY2F0Y2ggLSB0aGlzIHdpbGwgYmUgb3VyIHNhbXBsZSBlcnJvci5cbiAqICAgKDMpIGRpZmZpbmcgdGhlIGNvbnRyb2wgYW5kIHNhbXBsZSBlcnJvciBzdGFja3MgdG8gZmluZCB0aGUgc3RhY2sgZnJhbWVcbiAqICAgICAgIHdoaWNoIHJlcHJlc2VudHMgb3VyIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmRpbmcgYSBjb21tb24gc3RhY2sgZnJhbWUgYmV0d2VlbiBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGNhbiBiZVxuICAgKiB0cmlja3kgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcyBhbmQgbGV2ZWxzIG9mIHN0YWNrIHRyYWNlIHRydW5jYXRpb24gZnJvbVxuICAgKiBkaWZmZXJlbnQgSlMgVk1zLiBTbyBpbnN0ZWFkIHdlJ2xsIGF0dGVtcHQgdG8gY29udHJvbCB3aGF0IHRoYXQgY29tbW9uXG4gICAqIGZyYW1lIHNob3VsZCBiZSB0aHJvdWdoIHRoaXMgb2JqZWN0IG1ldGhvZDpcbiAgICogSGF2aW5nIGJvdGggdGhlIHNhbXBsZSBhbmQgY29udHJvbCBlcnJvcnMgYmUgaW4gdGhlIGZ1bmN0aW9uIHVuZGVyIHRoZVxuICAgKiBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIHByb3BlcnR5LCArIHNldHRpbmcgdGhlIGBuYW1lYCBhbmRcbiAgICogYGRpc3BsYXlOYW1lYCBwcm9wZXJ0aWVzIG9mIHRoZSBmdW5jdGlvbiBlbnN1cmVzIHRoYXQgYSBzdGFja1xuICAgKiBmcmFtZSBleGlzdHMgdGhhdCBoYXMgdGhlIG1ldGhvZCBuYW1lIGBEZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lUm9vdGAgaW5cbiAgICogaXQgZm9yIGJvdGggY29udHJvbCBhbmQgc2FtcGxlIHN0YWNrcy5cbiAgICovXG5cblxuICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29udHJvbDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgfSAvLyBUT0RPKGx1bmEpOiBUaGlzIHdpbGwgY3VycmVudGx5IG9ubHkgdGhyb3cgaWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgICAgICAgIC8vIHRyaWVzIHRvIGFjY2VzcyBSZWFjdC9SZWFjdERPTS9wcm9wcy4gV2Ugc2hvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyB0aHJvd1xuICAgICAgICAgIC8vIGluIHNpbXBsZSBjb21wb25lbnRzIHRvb1xuXG5cbiAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gZm4oKTsgLy8gSWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCByZXR1cm5zIGEgcHJvbWlzZSwgaXQncyBsaWtlbHkgYW4gYXN5bmNcbiAgICAgICAgICAvLyBjb21wb25lbnQsIHdoaWNoIHdlIGRvbid0IHlldCBzdXBwb3J0LiBBdHRhY2ggYSBub29wIGNhdGNoIGhhbmRsZXIgdG9cbiAgICAgICAgICAvLyBzaWxlbmNlIHRoZSBlcnJvci5cbiAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgY29tcG9uZW50IHN0YWNrcyBmb3IgYXN5bmMgY2xpZW50IGNvbXBvbmVudHM/XG5cbiAgICAgICAgICBpZiAobWF5YmVQcm9taXNlICYmIHR5cGVvZiBtYXliZVByb21pc2UuY2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICAgICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIFtzYW1wbGUuc3RhY2ssIGNvbnRyb2wuc3RhY2tdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgfVxuICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPSAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JztcbiAgdmFyIG5hbWVQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LCAnbmFtZScpOyAvLyBCZWZvcmUgRVM2LCB0aGUgYG5hbWVgIHByb3BlcnR5IHdhcyBub3QgY29uZmlndXJhYmxlLlxuXG4gIGlmIChuYW1lUHJvcERlc2NyaXB0b3IgJiYgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgIC8vIFY4IHV0aWxpemVzIGEgZnVuY3Rpb24ncyBgbmFtZWAgcHJvcGVydHkgd2hlbiBnZW5lcmF0aW5nIGEgc3RhY2sgdHJhY2UuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgLy8gQ29uZmlndXJhYmxlIHByb3BlcnRpZXMgY2FuIGJlIHVwZGF0ZWQgZXZlbiBpZiBpdHMgd3JpdGFibGUgZGVzY3JpcHRvclxuICAgIC8vIGlzIHNldCB0byBgZmFsc2VgLlxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuICAgICduYW1lJywge1xuICAgICAgdmFsdWU6ICdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnXG4gICAgfSk7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgc2FtcGxlU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMF0sXG4gICAgICAgIGNvbnRyb2xTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclsxXTtcblxuICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSAwO1xuICAgICAgdmFyIGMgPSAwO1xuXG4gICAgICB3aGlsZSAocyA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJiAhc2FtcGxlTGluZXNbc10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIHMrKztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGMgPCBjb250cm9sTGluZXMubGVuZ3RoICYmICFjb250cm9sTGluZXNbY10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIGMrKztcbiAgICAgIH0gLy8gV2UgY291bGRuJ3QgZmluZCBvdXIgaW50ZW50aW9uYWxseSBpbmplY3RlZCBjb21tb24gcm9vdCBmcmFtZSwgYXR0ZW1wdFxuICAgICAgLy8gdG8gZmluZCBhbm90aGVyIGNvbW1vbiByb290IGZyYW1lIGJ5IHNlYXJjaCBmcm9tIHRoZSBib3R0b20gb2YgdGhlXG4gICAgICAvLyBjb250cm9sIHN0YWNrLi4uXG5cblxuICAgICAgaWYgKHMgPT09IHNhbXBsZUxpbmVzLmxlbmd0aCB8fCBjID09PSBjb250cm9sTGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgICBjLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB7XG4gICAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxuZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgX3JlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIHJlZjtcblxuICB7XG4gICAgcmVmID0gX3JlZjtcbiAgfVxuXG4gIHZhciBlbGVtZW50O1xuXG4gIHtcbiAgICAvLyBJbiBwcm9kLCBgcmVmYCBpcyBhIHJlZ3VsYXIgcHJvcGVydHkuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiBhXG4gICAgLy8gZnV0dXJlIHJlbGVhc2UuXG4gICAgZWxlbWVudCA9IHtcbiAgICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBrZXk6IGtleSxcbiAgICAgIHJlZjogcmVmLFxuICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICAgIF9vd25lcjogb3duZXJcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBkZWJ1Z0luZm8gY29udGFpbnMgU2VydmVyIENvbXBvbmVudCBkZWJ1ZyBpbmZvcm1hdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX2RlYnVnSW5mbycsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpKSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIGludmFsaWQgZWxlbWVudCB0eXBlLlxuICAgICAgLy9cbiAgICAgIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB2YWxpZCBlbGVtZW50IHR5cGUuXG4gICAgICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmdcbiAgICAgIC8vIGVycm9ycy4gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZFxuICAgICAgLy8gcHJvZC4gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlXG4gICAgICAvLyB0eXBlIGlzIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gV2FybiBhYm91dCBrZXkgc3ByZWFkIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgdHlwZSBpcyB2YWxpZC5cblxuXG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb25maWcpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gayAhPT0gJ2tleSc7XG4gICAgICB9KTtcbiAgICAgIHZhciBiZWZvcmVFeGFtcGxlID0ga2V5cy5sZW5ndGggPiAwID8gJ3trZXk6IHNvbWVLZXksICcgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3trZXk6IHNvbWVLZXl9JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdKSB7XG4gICAgICAgIHZhciBhZnRlckV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAneycgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3t9JztcblxuICAgICAgICBlcnJvcignQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMgey4uLnByb3BzfSAvPlxcbicgKyAnUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JywgYmVmb3JlRXhhbXBsZSwgY29tcG9uZW50TmFtZSwgYWZ0ZXJFeGFtcGxlLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAge1xuICAgICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgfVxuXG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmIC8vIFNraXAgb3ZlciByZXNlcnZlZCBwcm9wIG5hbWVzXG4gICAgICBwcm9wTmFtZSAhPT0gJ2tleScgJiYgKHByb3BOYW1lICE9PSAncmVmJykpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xuXG4gICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnIHx8ICFub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UpIDsgZWxzZSBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHBhcmVudFR5cGUpO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gcmVuZGVyIHBoYXNlIGluc3RlYWQgb2YgYXQgZWxlbWVudCBjcmVhdGlvbi5cbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIganN4REVWID0ganN4REVWJDEgO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanM/MTE1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ai/react/dist/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/ai/react/dist/index.mjs ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   experimental_useAssistant: function() { return /* binding */ experimental_useAssistant; },\n/* harmony export */   useAssistant: function() { return /* binding */ useAssistant; },\n/* harmony export */   useChat: function() { return /* binding */ useChat; },\n/* harmony export */   useCompletion: function() { return /* binding */ useCompletion; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! swr */ \"(app-pages-browser)/./node_modules/swr/core/dist/index.mjs\");\n/* harmony import */ var nanoid_non_secure__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! nanoid/non-secure */ \"(app-pages-browser)/./node_modules/nanoid/non-secure/index.js\");\n/* __next_internal_client_entry_do_not_use__ experimental_useAssistant,useAssistant,useChat,useCompletion auto */ var _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$();\n// react/use-chat.ts\n\n\n// shared/stream-parts.ts\nvar textStreamPart = {\n    code: \"0\",\n    name: \"text\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"text\" parts expect a string value.');\n        }\n        return {\n            type: \"text\",\n            value\n        };\n    }\n};\nvar functionCallStreamPart = {\n    code: \"1\",\n    name: \"function_call\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"function_call\" in value) || typeof value.function_call !== \"object\" || value.function_call == null || !(\"name\" in value.function_call) || !(\"arguments\" in value.function_call) || typeof value.function_call.name !== \"string\" || typeof value.function_call.arguments !== \"string\") {\n            throw new Error('\"function_call\" parts expect an object with a \"function_call\" property.');\n        }\n        return {\n            type: \"function_call\",\n            value\n        };\n    }\n};\nvar dataStreamPart = {\n    code: \"2\",\n    name: \"data\",\n    parse: (value)=>{\n        if (!Array.isArray(value)) {\n            throw new Error('\"data\" parts expect an array value.');\n        }\n        return {\n            type: \"data\",\n            value\n        };\n    }\n};\nvar errorStreamPart = {\n    code: \"3\",\n    name: \"error\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"error\" parts expect a string value.');\n        }\n        return {\n            type: \"error\",\n            value\n        };\n    }\n};\nvar assistantMessageStreamPart = {\n    code: \"4\",\n    name: \"assistant_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"id\" in value) || !(\"role\" in value) || !(\"content\" in value) || typeof value.id !== \"string\" || typeof value.role !== \"string\" || value.role !== \"assistant\" || !Array.isArray(value.content) || !value.content.every((item)=>item != null && typeof item === \"object\" && \"type\" in item && item.type === \"text\" && \"text\" in item && item.text != null && typeof item.text === \"object\" && \"value\" in item.text && typeof item.text.value === \"string\")) {\n            throw new Error('\"assistant_message\" parts expect an object with an \"id\", \"role\", and \"content\" property.');\n        }\n        return {\n            type: \"assistant_message\",\n            value\n        };\n    }\n};\nvar assistantControlDataStreamPart = {\n    code: \"5\",\n    name: \"assistant_control_data\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"threadId\" in value) || !(\"messageId\" in value) || typeof value.threadId !== \"string\" || typeof value.messageId !== \"string\") {\n            throw new Error('\"assistant_control_data\" parts expect an object with a \"threadId\" and \"messageId\" property.');\n        }\n        return {\n            type: \"assistant_control_data\",\n            value: {\n                threadId: value.threadId,\n                messageId: value.messageId\n            }\n        };\n    }\n};\nvar dataMessageStreamPart = {\n    code: \"6\",\n    name: \"data_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"role\" in value) || !(\"data\" in value) || typeof value.role !== \"string\" || value.role !== \"data\") {\n            throw new Error('\"data_message\" parts expect an object with a \"role\" and \"data\" property.');\n        }\n        return {\n            type: \"data_message\",\n            value\n        };\n    }\n};\nvar toolCallStreamPart = {\n    code: \"7\",\n    name: \"tool_calls\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"tool_calls\" in value) || typeof value.tool_calls !== \"object\" || value.tool_calls == null || !Array.isArray(value.tool_calls) || value.tool_calls.some((tc)=>tc == null || typeof tc !== \"object\" || !(\"id\" in tc) || typeof tc.id !== \"string\" || !(\"type\" in tc) || typeof tc.type !== \"string\" || !(\"function\" in tc) || tc.function == null || typeof tc.function !== \"object\" || !(\"arguments\" in tc.function) || typeof tc.function.name !== \"string\" || typeof tc.function.arguments !== \"string\")) {\n            throw new Error('\"tool_calls\" parts expect an object with a ToolCallPayload.');\n        }\n        return {\n            type: \"tool_calls\",\n            value\n        };\n    }\n};\nvar messageAnnotationsStreamPart = {\n    code: \"8\",\n    name: \"message_annotations\",\n    parse: (value)=>{\n        if (!Array.isArray(value)) {\n            throw new Error('\"message_annotations\" parts expect an array value.');\n        }\n        return {\n            type: \"message_annotations\",\n            value\n        };\n    }\n};\nvar streamParts = [\n    textStreamPart,\n    functionCallStreamPart,\n    dataStreamPart,\n    errorStreamPart,\n    assistantMessageStreamPart,\n    assistantControlDataStreamPart,\n    dataMessageStreamPart,\n    toolCallStreamPart,\n    messageAnnotationsStreamPart\n];\nvar streamPartsByCode = {\n    [textStreamPart.code]: textStreamPart,\n    [functionCallStreamPart.code]: functionCallStreamPart,\n    [dataStreamPart.code]: dataStreamPart,\n    [errorStreamPart.code]: errorStreamPart,\n    [assistantMessageStreamPart.code]: assistantMessageStreamPart,\n    [assistantControlDataStreamPart.code]: assistantControlDataStreamPart,\n    [dataMessageStreamPart.code]: dataMessageStreamPart,\n    [toolCallStreamPart.code]: toolCallStreamPart,\n    [messageAnnotationsStreamPart.code]: messageAnnotationsStreamPart\n};\nvar StreamStringPrefixes = {\n    [textStreamPart.name]: textStreamPart.code,\n    [functionCallStreamPart.name]: functionCallStreamPart.code,\n    [dataStreamPart.name]: dataStreamPart.code,\n    [errorStreamPart.name]: errorStreamPart.code,\n    [assistantMessageStreamPart.name]: assistantMessageStreamPart.code,\n    [assistantControlDataStreamPart.name]: assistantControlDataStreamPart.code,\n    [dataMessageStreamPart.name]: dataMessageStreamPart.code,\n    [toolCallStreamPart.name]: toolCallStreamPart.code,\n    [messageAnnotationsStreamPart.name]: messageAnnotationsStreamPart.code\n};\nvar validCodes = streamParts.map((part)=>part.code);\nvar parseStreamPart = (line)=>{\n    const firstSeparatorIndex = line.indexOf(\":\");\n    if (firstSeparatorIndex === -1) {\n        throw new Error(\"Failed to parse stream string. No separator found.\");\n    }\n    const prefix = line.slice(0, firstSeparatorIndex);\n    if (!validCodes.includes(prefix)) {\n        throw new Error(\"Failed to parse stream string. Invalid code \".concat(prefix, \".\"));\n    }\n    const code = prefix;\n    const textValue = line.slice(firstSeparatorIndex + 1);\n    const jsonValue = JSON.parse(textValue);\n    return streamPartsByCode[code].parse(jsonValue);\n};\n// shared/read-data-stream.ts\nvar NEWLINE = \"\\n\".charCodeAt(0);\nfunction concatChunks(chunks, totalLength) {\n    const concatenatedChunks = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const chunk of chunks){\n        concatenatedChunks.set(chunk, offset);\n        offset += chunk.length;\n    }\n    chunks.length = 0;\n    return concatenatedChunks;\n}\nasync function* readDataStream(reader) {\n    let { isAborted } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const decoder = new TextDecoder();\n    const chunks = [];\n    let totalLength = 0;\n    while(true){\n        const { value } = await reader.read();\n        if (value) {\n            chunks.push(value);\n            totalLength += value.length;\n            if (value[value.length - 1] !== NEWLINE) {\n                continue;\n            }\n        }\n        if (chunks.length === 0) {\n            break;\n        }\n        const concatenatedChunks = concatChunks(chunks, totalLength);\n        totalLength = 0;\n        const streamParts2 = decoder.decode(concatenatedChunks, {\n            stream: true\n        }).split(\"\\n\").filter((line)=>line !== \"\").map(parseStreamPart);\n        for (const streamPart of streamParts2){\n            yield streamPart;\n        }\n        if (isAborted == null ? void 0 : isAborted()) {\n            reader.cancel();\n            break;\n        }\n    }\n}\n// shared/generate-id.ts\n\nvar generateId = (0,nanoid_non_secure__WEBPACK_IMPORTED_MODULE_2__.customAlphabet)(\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\", 7);\n// shared/parse-complex-response.ts\nfunction assignAnnotationsToMessage(message, annotations) {\n    if (!message || !annotations || !annotations.length) return message;\n    return {\n        ...message,\n        annotations: [\n            ...annotations\n        ]\n    };\n}\nasync function parseComplexResponse(param) {\n    let { reader, abortControllerRef, update, onFinish, generateId: generateId2 = generateId, getCurrentDate = ()=>/* @__PURE__ */ new Date() } = param;\n    const createdAt = getCurrentDate();\n    const prefixMap = {\n        data: []\n    };\n    let message_annotations = void 0;\n    for await (const { type, value } of readDataStream(reader, {\n        isAborted: ()=>(abortControllerRef == null ? void 0 : abortControllerRef.current) === null\n    })){\n        if (type === \"text\") {\n            if (prefixMap[\"text\"]) {\n                prefixMap[\"text\"] = {\n                    ...prefixMap[\"text\"],\n                    content: (prefixMap[\"text\"].content || \"\") + value\n                };\n            } else {\n                prefixMap[\"text\"] = {\n                    id: generateId2(),\n                    role: \"assistant\",\n                    content: value,\n                    createdAt\n                };\n            }\n        }\n        let functionCallMessage = null;\n        if (type === \"function_call\") {\n            prefixMap[\"function_call\"] = {\n                id: generateId2(),\n                role: \"assistant\",\n                content: \"\",\n                function_call: value.function_call,\n                name: value.function_call.name,\n                createdAt\n            };\n            functionCallMessage = prefixMap[\"function_call\"];\n        }\n        let toolCallMessage = null;\n        if (type === \"tool_calls\") {\n            prefixMap[\"tool_calls\"] = {\n                id: generateId2(),\n                role: \"assistant\",\n                content: \"\",\n                tool_calls: value.tool_calls,\n                createdAt\n            };\n            toolCallMessage = prefixMap[\"tool_calls\"];\n        }\n        if (type === \"data\") {\n            prefixMap[\"data\"].push(...value);\n        }\n        let responseMessage = prefixMap[\"text\"];\n        if (type === \"message_annotations\") {\n            if (!message_annotations) {\n                message_annotations = [\n                    ...value\n                ];\n            } else {\n                message_annotations.push(...value);\n            }\n            functionCallMessage = assignAnnotationsToMessage(prefixMap[\"function_call\"], message_annotations);\n            toolCallMessage = assignAnnotationsToMessage(prefixMap[\"tool_calls\"], message_annotations);\n            responseMessage = assignAnnotationsToMessage(prefixMap[\"text\"], message_annotations);\n        }\n        if (message_annotations == null ? void 0 : message_annotations.length) {\n            const messagePrefixKeys = [\n                \"text\",\n                \"function_call\",\n                \"tool_calls\"\n            ];\n            messagePrefixKeys.forEach((key)=>{\n                if (prefixMap[key]) {\n                    prefixMap[key].annotations = [\n                        ...message_annotations\n                    ];\n                }\n            });\n        }\n        const merged = [\n            functionCallMessage,\n            toolCallMessage,\n            responseMessage\n        ].filter(Boolean).map((message)=>({\n                ...assignAnnotationsToMessage(message, message_annotations)\n            }));\n        update(merged, [\n            ...prefixMap[\"data\"]\n        ]);\n    }\n    onFinish == null ? void 0 : onFinish(prefixMap);\n    return {\n        messages: [\n            prefixMap.text,\n            prefixMap.function_call,\n            prefixMap.tool_calls\n        ].filter(Boolean),\n        data: prefixMap.data\n    };\n}\n// shared/utils.ts\nfunction createChunkDecoder(complex) {\n    const decoder = new TextDecoder();\n    if (!complex) {\n        return function(chunk) {\n            if (!chunk) return \"\";\n            return decoder.decode(chunk, {\n                stream: true\n            });\n        };\n    }\n    return function(chunk) {\n        const decoded = decoder.decode(chunk, {\n            stream: true\n        }).split(\"\\n\").filter((line)=>line !== \"\");\n        return decoded.map(parseStreamPart).filter(Boolean);\n    };\n}\n// shared/call-chat-api.ts\nasync function callChatApi(param) {\n    let { api, messages, body, streamMode = \"stream-data\", credentials, headers, abortController, restoreMessagesOnFailure, onResponse, onUpdate, onFinish, generateId: generateId2 } = param;\n    var _a;\n    const response = await fetch(api, {\n        method: \"POST\",\n        body: JSON.stringify({\n            messages,\n            ...body\n        }),\n        headers: {\n            \"Content-Type\": \"application/json\",\n            ...headers\n        },\n        signal: (_a = abortController == null ? void 0 : abortController()) == null ? void 0 : _a.signal,\n        credentials\n    }).catch((err)=>{\n        restoreMessagesOnFailure();\n        throw err;\n    });\n    if (onResponse) {\n        try {\n            await onResponse(response);\n        } catch (err) {\n            throw err;\n        }\n    }\n    if (!response.ok) {\n        restoreMessagesOnFailure();\n        throw new Error(await response.text() || \"Failed to fetch the chat response.\");\n    }\n    if (!response.body) {\n        throw new Error(\"The response body is empty.\");\n    }\n    const reader = response.body.getReader();\n    switch(streamMode){\n        case \"text\":\n            {\n                const decoder = createChunkDecoder();\n                const resultMessage = {\n                    id: generateId2(),\n                    createdAt: /* @__PURE__ */ new Date(),\n                    role: \"assistant\",\n                    content: \"\"\n                };\n                while(true){\n                    const { done, value } = await reader.read();\n                    if (done) {\n                        break;\n                    }\n                    resultMessage.content += decoder(value);\n                    resultMessage.id = generateId2();\n                    onUpdate([\n                        {\n                            ...resultMessage\n                        }\n                    ], []);\n                    if ((abortController == null ? void 0 : abortController()) === null) {\n                        reader.cancel();\n                        break;\n                    }\n                }\n                onFinish == null ? void 0 : onFinish(resultMessage);\n                return {\n                    messages: [\n                        resultMessage\n                    ],\n                    data: []\n                };\n            }\n        case \"stream-data\":\n            {\n                return await parseComplexResponse({\n                    reader,\n                    abortControllerRef: abortController != null ? {\n                        current: abortController()\n                    } : void 0,\n                    update: onUpdate,\n                    onFinish (prefixMap) {\n                        if (onFinish && prefixMap.text != null) {\n                            onFinish(prefixMap.text);\n                        }\n                    },\n                    generateId: generateId2\n                });\n            }\n        default:\n            {\n                const exhaustiveCheck = streamMode;\n                throw new Error(\"Unknown stream mode: \".concat(exhaustiveCheck));\n            }\n    }\n}\n// shared/process-chat-stream.ts\nasync function processChatStream(param) {\n    let { getStreamedResponse: getStreamedResponse2, experimental_onFunctionCall, experimental_onToolCall, updateChatRequest, getCurrentMessages } = param;\n    while(true){\n        const messagesAndDataOrJustMessage = await getStreamedResponse2();\n        if (\"messages\" in messagesAndDataOrJustMessage) {\n            let hasFollowingResponse = false;\n            for (const message of messagesAndDataOrJustMessage.messages){\n                if ((message.function_call === void 0 || typeof message.function_call === \"string\") && (message.tool_calls === void 0 || typeof message.tool_calls === \"string\")) {\n                    continue;\n                }\n                hasFollowingResponse = true;\n                if (experimental_onFunctionCall) {\n                    const functionCall = message.function_call;\n                    if (typeof functionCall !== \"object\") {\n                        console.warn(\"experimental_onFunctionCall should not be defined when using tools\");\n                        continue;\n                    }\n                    const functionCallResponse = await experimental_onFunctionCall(getCurrentMessages(), functionCall);\n                    if (functionCallResponse === void 0) {\n                        hasFollowingResponse = false;\n                        break;\n                    }\n                    updateChatRequest(functionCallResponse);\n                }\n                if (experimental_onToolCall) {\n                    const toolCalls = message.tool_calls;\n                    if (!Array.isArray(toolCalls) || toolCalls.some((toolCall)=>typeof toolCall !== \"object\")) {\n                        console.warn(\"experimental_onToolCall should not be defined when using tools\");\n                        continue;\n                    }\n                    const toolCallResponse = await experimental_onToolCall(getCurrentMessages(), toolCalls);\n                    if (toolCallResponse === void 0) {\n                        hasFollowingResponse = false;\n                        break;\n                    }\n                    updateChatRequest(toolCallResponse);\n                }\n            }\n            if (!hasFollowingResponse) {\n                break;\n            }\n        } else {\n            let fixFunctionCallArguments2 = function(response) {\n                for (const message of response.messages){\n                    if (message.tool_calls !== void 0) {\n                        for (const toolCall of message.tool_calls){\n                            if (typeof toolCall === \"object\") {\n                                if (toolCall.function.arguments && typeof toolCall.function.arguments !== \"string\") {\n                                    toolCall.function.arguments = JSON.stringify(toolCall.function.arguments);\n                                }\n                            }\n                        }\n                    }\n                    if (message.function_call !== void 0) {\n                        if (typeof message.function_call === \"object\") {\n                            if (message.function_call.arguments && typeof message.function_call.arguments !== \"string\") {\n                                message.function_call.arguments = JSON.stringify(message.function_call.arguments);\n                            }\n                        }\n                    }\n                }\n            };\n            var fixFunctionCallArguments = fixFunctionCallArguments2;\n            const streamedResponseMessage = messagesAndDataOrJustMessage;\n            if ((streamedResponseMessage.function_call === void 0 || typeof streamedResponseMessage.function_call === \"string\") && (streamedResponseMessage.tool_calls === void 0 || typeof streamedResponseMessage.tool_calls === \"string\")) {\n                break;\n            }\n            if (experimental_onFunctionCall) {\n                const functionCall = streamedResponseMessage.function_call;\n                if (!(typeof functionCall === \"object\")) {\n                    console.warn(\"experimental_onFunctionCall should not be defined when using tools\");\n                    continue;\n                }\n                const functionCallResponse = await experimental_onFunctionCall(getCurrentMessages(), functionCall);\n                if (functionCallResponse === void 0) break;\n                fixFunctionCallArguments2(functionCallResponse);\n                updateChatRequest(functionCallResponse);\n            }\n            if (experimental_onToolCall) {\n                const toolCalls = streamedResponseMessage.tool_calls;\n                if (!(typeof toolCalls === \"object\")) {\n                    console.warn(\"experimental_onToolCall should not be defined when using functions\");\n                    continue;\n                }\n                const toolCallResponse = await experimental_onToolCall(getCurrentMessages(), toolCalls);\n                if (toolCallResponse === void 0) break;\n                fixFunctionCallArguments2(toolCallResponse);\n                updateChatRequest(toolCallResponse);\n            }\n        }\n    }\n}\n// react/use-chat.ts\nvar getStreamedResponse = async (api, chatRequest, mutate, mutateStreamData, existingData, extraMetadataRef, messagesRef, abortControllerRef, generateId2, streamMode, onFinish, onResponse, sendExtraMessageFields)=>{\n    var _a, _b;\n    const previousMessages = messagesRef.current;\n    mutate(chatRequest.messages, false);\n    const constructedMessagesPayload = sendExtraMessageFields ? chatRequest.messages : chatRequest.messages.map((param)=>{\n        let { role, content, name, function_call, tool_calls, tool_call_id } = param;\n        return {\n            role,\n            content,\n            tool_call_id,\n            ...name !== void 0 && {\n                name\n            },\n            ...function_call !== void 0 && {\n                function_call\n            },\n            ...tool_calls !== void 0 && {\n                tool_calls\n            }\n        };\n    });\n    if (typeof api !== \"string\") {\n        const replyId = generateId2();\n        const createdAt = /* @__PURE__ */ new Date();\n        let responseMessage = {\n            id: replyId,\n            createdAt,\n            content: \"\",\n            role: \"assistant\"\n        };\n        async function readRow(promise) {\n            const { content, ui, next } = await promise;\n            responseMessage[\"content\"] = content;\n            responseMessage[\"ui\"] = await ui;\n            mutate([\n                ...chatRequest.messages,\n                {\n                    ...responseMessage\n                }\n            ], false);\n            if (next) {\n                await readRow(next);\n            }\n        }\n        try {\n            const promise = api({\n                messages: constructedMessagesPayload,\n                data: chatRequest.data\n            });\n            await readRow(promise);\n        } catch (e) {\n            mutate(previousMessages, false);\n            throw e;\n        }\n        if (onFinish) {\n            onFinish(responseMessage);\n        }\n        return responseMessage;\n    }\n    return await callChatApi({\n        api,\n        messages: constructedMessagesPayload,\n        body: {\n            data: chatRequest.data,\n            ...extraMetadataRef.current.body,\n            ...(_a = chatRequest.options) == null ? void 0 : _a.body,\n            ...chatRequest.functions !== void 0 && {\n                functions: chatRequest.functions\n            },\n            ...chatRequest.function_call !== void 0 && {\n                function_call: chatRequest.function_call\n            },\n            ...chatRequest.tools !== void 0 && {\n                tools: chatRequest.tools\n            },\n            ...chatRequest.tool_choice !== void 0 && {\n                tool_choice: chatRequest.tool_choice\n            }\n        },\n        streamMode,\n        credentials: extraMetadataRef.current.credentials,\n        headers: {\n            ...extraMetadataRef.current.headers,\n            ...(_b = chatRequest.options) == null ? void 0 : _b.headers\n        },\n        abortController: ()=>abortControllerRef.current,\n        restoreMessagesOnFailure () {\n            mutate(previousMessages, false);\n        },\n        onResponse,\n        onUpdate (merged, data) {\n            mutate([\n                ...chatRequest.messages,\n                ...merged\n            ], false);\n            mutateStreamData([\n                ...existingData || [],\n                ...data || []\n            ], false);\n        },\n        onFinish,\n        generateId: generateId2\n    });\n};\nfunction useChat() {\n    let { api = \"/api/chat\", id, initialMessages, initialInput = \"\", sendExtraMessageFields, experimental_onFunctionCall, experimental_onToolCall, streamMode, onResponse, onFinish, onError, credentials, headers, body, generateId: generateId2 = generateId } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    _s();\n    const hookId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n    const idKey = id != null ? id : hookId;\n    const chatKey = typeof api === \"string\" ? [\n        api,\n        idKey\n    ] : idKey;\n    const [initialMessagesFallback] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const { data: messages, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"messages\"\n    ], null, {\n        fallbackData: initialMessages != null ? initialMessages : initialMessagesFallback\n    });\n    const { data: isLoading = false, mutate: mutateLoading } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"loading\"\n    ], null);\n    const { data: streamData, mutate: mutateStreamData } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"streamData\"\n    ], null);\n    const { data: error = void 0, mutate: setError } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"error\"\n    ], null);\n    const messagesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(messages || []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        messagesRef.current = messages || [];\n    }, [\n        messages\n    ]);\n    const abortControllerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const extraMetadataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        credentials,\n        headers,\n        body\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        extraMetadataRef.current = {\n            credentials,\n            headers,\n            body\n        };\n    }, [\n        credentials,\n        headers,\n        body\n    ]);\n    const triggerRequest = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (chatRequest)=>{\n        try {\n            mutateLoading(true);\n            setError(void 0);\n            const abortController = new AbortController();\n            abortControllerRef.current = abortController;\n            await processChatStream({\n                getStreamedResponse: ()=>getStreamedResponse(api, chatRequest, mutate, mutateStreamData, streamData, extraMetadataRef, messagesRef, abortControllerRef, generateId2, streamMode, onFinish, onResponse, sendExtraMessageFields),\n                experimental_onFunctionCall,\n                experimental_onToolCall,\n                updateChatRequest: (chatRequestParam)=>{\n                    chatRequest = chatRequestParam;\n                },\n                getCurrentMessages: ()=>messagesRef.current\n            });\n            abortControllerRef.current = null;\n        } catch (err) {\n            if (err.name === \"AbortError\") {\n                abortControllerRef.current = null;\n                return null;\n            }\n            if (onError && err instanceof Error) {\n                onError(err);\n            }\n            setError(err);\n        } finally{\n            mutateLoading(false);\n        }\n    }, [\n        mutate,\n        mutateLoading,\n        api,\n        extraMetadataRef,\n        onResponse,\n        onFinish,\n        onError,\n        setError,\n        mutateStreamData,\n        streamData,\n        sendExtraMessageFields,\n        experimental_onFunctionCall,\n        experimental_onToolCall,\n        messagesRef,\n        abortControllerRef,\n        generateId2\n    ]);\n    const append = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async function(message) {\n        let { options, functions, function_call, tools, tool_choice, data } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        if (!message.id) {\n            message.id = generateId2();\n        }\n        const chatRequest = {\n            messages: messagesRef.current.concat(message),\n            options,\n            data,\n            ...functions !== void 0 && {\n                functions\n            },\n            ...function_call !== void 0 && {\n                function_call\n            },\n            ...tools !== void 0 && {\n                tools\n            },\n            ...tool_choice !== void 0 && {\n                tool_choice\n            }\n        };\n        return triggerRequest(chatRequest);\n    }, [\n        triggerRequest,\n        generateId2\n    ]);\n    const reload = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async function() {\n        let { options, functions, function_call, tools, tool_choice } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        if (messagesRef.current.length === 0) return null;\n        const lastMessage = messagesRef.current[messagesRef.current.length - 1];\n        if (lastMessage.role === \"assistant\") {\n            const chatRequest2 = {\n                messages: messagesRef.current.slice(0, -1),\n                options,\n                ...functions !== void 0 && {\n                    functions\n                },\n                ...function_call !== void 0 && {\n                    function_call\n                },\n                ...tools !== void 0 && {\n                    tools\n                },\n                ...tool_choice !== void 0 && {\n                    tool_choice\n                }\n            };\n            return triggerRequest(chatRequest2);\n        }\n        const chatRequest = {\n            messages: messagesRef.current,\n            options,\n            ...functions !== void 0 && {\n                functions\n            },\n            ...function_call !== void 0 && {\n                function_call\n            },\n            ...tools !== void 0 && {\n                tools\n            },\n            ...tool_choice !== void 0 && {\n                tool_choice\n            }\n        };\n        return triggerRequest(chatRequest);\n    }, [\n        triggerRequest\n    ]);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (abortControllerRef.current) {\n            abortControllerRef.current.abort();\n            abortControllerRef.current = null;\n        }\n    }, []);\n    const setMessages = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((messages2)=>{\n        mutate(messages2, false);\n        messagesRef.current = messages2;\n    }, [\n        mutate\n    ]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialInput);\n    const handleSubmit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(e) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, metadata = arguments.length > 2 ? arguments[2] : void 0;\n        if (metadata) {\n            extraMetadataRef.current = {\n                ...extraMetadataRef.current,\n                ...metadata\n            };\n        }\n        e.preventDefault();\n        if (!input) return;\n        append({\n            content: input,\n            role: \"user\",\n            createdAt: /* @__PURE__ */ new Date()\n        }, options);\n        setInput(\"\");\n    }, [\n        input,\n        append\n    ]);\n    const handleInputChange = (e)=>{\n        setInput(e.target.value);\n    };\n    return {\n        messages: messages || [],\n        error,\n        append,\n        reload,\n        stop,\n        setMessages,\n        input,\n        setInput,\n        handleInputChange,\n        handleSubmit,\n        isLoading,\n        data: streamData\n    };\n}\n_s(useChat, \"WCa1eRCHtdW5oqkuwJYhvpneWnU=\", false, function() {\n    return [\n        react__WEBPACK_IMPORTED_MODULE_0__.useId,\n        swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n        swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n        swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n        swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\n    ];\n});\n// react/use-completion.ts\n\n\n// shared/call-completion-api.ts\nasync function callCompletionApi(param) {\n    let { api, prompt, credentials, headers, body, streamMode = \"stream-data\", setCompletion, setLoading, setError, setAbortController, onResponse, onFinish, onError, onData } = param;\n    try {\n        setLoading(true);\n        setError(void 0);\n        const abortController = new AbortController();\n        setAbortController(abortController);\n        setCompletion(\"\");\n        const res = await fetch(api, {\n            method: \"POST\",\n            body: JSON.stringify({\n                prompt,\n                ...body\n            }),\n            credentials,\n            headers: {\n                \"Content-Type\": \"application/json\",\n                ...headers\n            },\n            signal: abortController.signal\n        }).catch((err)=>{\n            throw err;\n        });\n        if (onResponse) {\n            try {\n                await onResponse(res);\n            } catch (err) {\n                throw err;\n            }\n        }\n        if (!res.ok) {\n            throw new Error(await res.text() || \"Failed to fetch the chat response.\");\n        }\n        if (!res.body) {\n            throw new Error(\"The response body is empty.\");\n        }\n        let result = \"\";\n        const reader = res.body.getReader();\n        switch(streamMode){\n            case \"text\":\n                {\n                    const decoder = createChunkDecoder();\n                    while(true){\n                        const { done, value } = await reader.read();\n                        if (done) {\n                            break;\n                        }\n                        result += decoder(value);\n                        setCompletion(result);\n                        if (abortController === null) {\n                            reader.cancel();\n                            break;\n                        }\n                    }\n                    break;\n                }\n            case \"stream-data\":\n                {\n                    for await (const { type, value } of readDataStream(reader, {\n                        isAborted: ()=>abortController === null\n                    })){\n                        switch(type){\n                            case \"text\":\n                                {\n                                    result += value;\n                                    setCompletion(result);\n                                    break;\n                                }\n                            case \"data\":\n                                {\n                                    onData == null ? void 0 : onData(value);\n                                    break;\n                                }\n                        }\n                    }\n                    break;\n                }\n            default:\n                {\n                    const exhaustiveCheck = streamMode;\n                    throw new Error(\"Unknown stream mode: \".concat(exhaustiveCheck));\n                }\n        }\n        if (onFinish) {\n            onFinish(prompt, result);\n        }\n        setAbortController(null);\n        return result;\n    } catch (err) {\n        if (err.name === \"AbortError\") {\n            setAbortController(null);\n            return null;\n        }\n        if (err instanceof Error) {\n            if (onError) {\n                onError(err);\n            }\n        }\n        setError(err);\n    } finally{\n        setLoading(false);\n    }\n}\n// react/use-completion.ts\nfunction useCompletion() {\n    let { api = \"/api/completion\", id, initialCompletion = \"\", initialInput = \"\", credentials, headers, body, streamMode, onResponse, onFinish, onError } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    _s1();\n    const hookId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n    const completionId = id || hookId;\n    const { data, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        api,\n        completionId\n    ], null, {\n        fallbackData: initialCompletion\n    });\n    const { data: isLoading = false, mutate: mutateLoading } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        completionId,\n        \"loading\"\n    ], null);\n    const { data: streamData, mutate: mutateStreamData } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        completionId,\n        \"streamData\"\n    ], null);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const completion = data;\n    const [abortController, setAbortController] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const extraMetadataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        credentials,\n        headers,\n        body\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        extraMetadataRef.current = {\n            credentials,\n            headers,\n            body\n        };\n    }, [\n        credentials,\n        headers,\n        body\n    ]);\n    const triggerRequest = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (prompt, options)=>callCompletionApi({\n            api,\n            prompt,\n            credentials: extraMetadataRef.current.credentials,\n            headers: {\n                ...extraMetadataRef.current.headers,\n                ...options == null ? void 0 : options.headers\n            },\n            body: {\n                ...extraMetadataRef.current.body,\n                ...options == null ? void 0 : options.body\n            },\n            streamMode,\n            setCompletion: (completion2)=>mutate(completion2, false),\n            setLoading: mutateLoading,\n            setError,\n            setAbortController,\n            onResponse,\n            onFinish,\n            onError,\n            onData: (data2)=>{\n                mutateStreamData([\n                    ...streamData || [],\n                    ...data2 || []\n                ], false);\n            }\n        }), [\n        mutate,\n        mutateLoading,\n        api,\n        extraMetadataRef,\n        setAbortController,\n        onResponse,\n        onFinish,\n        onError,\n        setError,\n        streamData,\n        mutateStreamData\n    ]);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (abortController) {\n            abortController.abort();\n            setAbortController(null);\n        }\n    }, [\n        abortController\n    ]);\n    const setCompletion = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((completion2)=>{\n        mutate(completion2, false);\n    }, [\n        mutate\n    ]);\n    const complete = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (prompt, options)=>{\n        return triggerRequest(prompt, options);\n    }, [\n        triggerRequest\n    ]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialInput);\n    const handleSubmit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        e.preventDefault();\n        if (!input) return;\n        return complete(input);\n    }, [\n        input,\n        complete\n    ]);\n    const handleInputChange = (e)=>{\n        setInput(e.target.value);\n    };\n    return {\n        completion,\n        complete,\n        error,\n        setCompletion,\n        stop,\n        input,\n        setInput,\n        handleInputChange,\n        handleSubmit,\n        isLoading,\n        data: streamData\n    };\n}\n_s1(useCompletion, \"mtFpQ9LrMnpulu2POjQOK48YF6Q=\", false, function() {\n    return [\n        react__WEBPACK_IMPORTED_MODULE_0__.useId,\n        swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n        swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n        swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n        react__WEBPACK_IMPORTED_MODULE_0__.useState,\n        react__WEBPACK_IMPORTED_MODULE_0__.useState,\n        react__WEBPACK_IMPORTED_MODULE_0__.useRef,\n        react__WEBPACK_IMPORTED_MODULE_0__.useEffect,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n        react__WEBPACK_IMPORTED_MODULE_0__.useState,\n        react__WEBPACK_IMPORTED_MODULE_0__.useCallback\n    ];\n});\n// react/use-assistant.ts\n\nfunction useAssistant(param) {\n    let { api, threadId: threadIdParam, credentials, headers, body, onError } = param;\n    _s2();\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const [threadId, setThreadId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"awaiting_message\");\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const handleInputChange = (event)=>{\n        setInput(event.target.value);\n    };\n    const append = async (message, requestOptions)=>{\n        var _a;\n        setStatus(\"in_progress\");\n        setMessages((messages2)=>{\n            var _a2;\n            return [\n                ...messages2,\n                {\n                    ...message,\n                    id: (_a2 = message.id) != null ? _a2 : generateId()\n                }\n            ];\n        });\n        setInput(\"\");\n        try {\n            const result = await fetch(api, {\n                method: \"POST\",\n                credentials,\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...headers\n                },\n                body: JSON.stringify({\n                    ...body,\n                    // always use user-provided threadId when available:\n                    threadId: (_a = threadIdParam != null ? threadIdParam : threadId) != null ? _a : null,\n                    message: message.content,\n                    // optional request data:\n                    data: requestOptions == null ? void 0 : requestOptions.data\n                })\n            });\n            if (result.body == null) {\n                throw new Error(\"The response body is empty.\");\n            }\n            for await (const { type, value } of readDataStream(result.body.getReader())){\n                switch(type){\n                    case \"assistant_message\":\n                        {\n                            setMessages((messages2)=>[\n                                    ...messages2,\n                                    {\n                                        id: value.id,\n                                        role: value.role,\n                                        content: value.content[0].text.value\n                                    }\n                                ]);\n                            break;\n                        }\n                    case \"text\":\n                        {\n                            setMessages((messages2)=>{\n                                const lastMessage = messages2[messages2.length - 1];\n                                return [\n                                    ...messages2.slice(0, messages2.length - 1),\n                                    {\n                                        id: lastMessage.id,\n                                        role: lastMessage.role,\n                                        content: lastMessage.content + value\n                                    }\n                                ];\n                            });\n                            break;\n                        }\n                    case \"data_message\":\n                        {\n                            setMessages((messages2)=>{\n                                var _a2;\n                                return [\n                                    ...messages2,\n                                    {\n                                        id: (_a2 = value.id) != null ? _a2 : generateId(),\n                                        role: \"data\",\n                                        content: \"\",\n                                        data: value.data\n                                    }\n                                ];\n                            });\n                            break;\n                        }\n                    case \"assistant_control_data\":\n                        {\n                            setThreadId(value.threadId);\n                            setMessages((messages2)=>{\n                                const lastMessage = messages2[messages2.length - 1];\n                                lastMessage.id = value.messageId;\n                                return [\n                                    ...messages2.slice(0, messages2.length - 1),\n                                    lastMessage\n                                ];\n                            });\n                            break;\n                        }\n                    case \"error\":\n                        {\n                            const errorObj = new Error(value);\n                            setError(errorObj);\n                            break;\n                        }\n                }\n            }\n        } catch (error2) {\n            if (onError && error2 instanceof Error) {\n                onError(error2);\n            }\n            setError(error2);\n        }\n        setStatus(\"awaiting_message\");\n    };\n    const submitMessage = async (event, requestOptions)=>{\n        var _a;\n        (_a = event == null ? void 0 : event.preventDefault) == null ? void 0 : _a.call(event);\n        if (input === \"\") {\n            return;\n        }\n        append({\n            role: \"user\",\n            content: input\n        }, requestOptions);\n    };\n    return {\n        append,\n        messages,\n        setMessages,\n        threadId,\n        input,\n        setInput,\n        handleInputChange,\n        submitMessage,\n        status,\n        error\n    };\n}\n_s2(useAssistant, \"kZ9okHBK3FrYsfjnFMTYtAuMqQI=\", false, function() {\n    return [\n        react__WEBPACK_IMPORTED_MODULE_0__.useState,\n        react__WEBPACK_IMPORTED_MODULE_0__.useState,\n        react__WEBPACK_IMPORTED_MODULE_0__.useState,\n        react__WEBPACK_IMPORTED_MODULE_0__.useState,\n        react__WEBPACK_IMPORTED_MODULE_0__.useState\n    ];\n});\nvar experimental_useAssistant = useAssistant;\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9haS9yZWFjdC9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBZ0U7QUFDM0I7O0FDY3JDLElBQU1NLGlCQUFrRDtJQUN0REMsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE9BQU8sQ0FBQ0M7UUFDTixJQUFJLE9BQU9BLFVBQVUsVUFBVTtZQUM3QixNQUFNLElBQUlDLE1BQU07UUFDbEI7UUFDQSxPQUFPO1lBQUVDLE1BQU07WUFBUUY7UUFBTTtJQUMvQjtBQUNGO0FBRUEsSUFBTUcseUJBSUY7SUFDRk4sTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE9BQU8sQ0FBQ0M7UUFDTixJQUNFQSxTQUFTLFFBQ1QsT0FBT0EsVUFBVSxZQUNqQixDQUFFLG9CQUFtQkEsS0FBQSxLQUNyQixPQUFPQSxNQUFNSSxhQUFBLEtBQWtCLFlBQy9CSixNQUFNSSxhQUFBLElBQWlCLFFBQ3ZCLENBQUUsV0FBVUosTUFBTUksYUFBQSxLQUNsQixDQUFFLGdCQUFlSixNQUFNSSxhQUFBLEtBQ3ZCLE9BQU9KLE1BQU1JLGFBQUEsQ0FBY04sSUFBQSxLQUFTLFlBQ3BDLE9BQU9FLE1BQU1JLGFBQUEsQ0FBY0MsU0FBQSxLQUFjLFVBQ3pDO1lBQ0EsTUFBTSxJQUFJSixNQUNSO1FBRUo7UUFFQSxPQUFPO1lBQ0xDLE1BQU07WUFDTkY7UUFDRjtJQUNGO0FBQ0Y7QUFFQSxJQUFNTSxpQkFBNEQ7SUFDaEVULE1BQU07SUFDTkMsTUFBTTtJQUNOQyxPQUFPLENBQUNDO1FBQ04sSUFBSSxDQUFDTyxNQUFNQyxPQUFBLENBQVFSLFFBQVE7WUFDekIsTUFBTSxJQUFJQyxNQUFNO1FBQ2xCO1FBRUEsT0FBTztZQUFFQyxNQUFNO1lBQVFGO1FBQU07SUFDL0I7QUFDRjtBQUVBLElBQU1TLGtCQUFvRDtJQUN4RFosTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE9BQU8sQ0FBQ0M7UUFDTixJQUFJLE9BQU9BLFVBQVUsVUFBVTtZ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QUFTdEMsTUFBQSxHQUFTO29DQUFJMkg7aUNBQVc7NEJBQ2hFOzRCQUVBO3dCQUNGO29CQUVBLEtBQUs7d0JBQVM7NEJBQ1osTUFBTStCLFdBQVcsSUFBSTlNLE1BQU1EOzRCQUMzQnlLLFNBQVNzQzs0QkFDVDt3QkFDRjtnQkFDRjtZQUNGO1FBQ0YsU0FBU3ZDLFFBQU87WUFDZCxJQUFJVCxXQUFXUyxrQkFBaUJ2SyxPQUFPO2dCQUNyQzhKLFFBQVFTO1lBQ1Y7WUFFQUMsU0FBU0Q7UUFDWDtRQUVBb0MsVUFBVTtJQUNaO0lBRUEsTUFBTUksZ0JBQWdCLE9BQ3BCSCxPQUNBQztRQTlQSixJQUFBckc7UUFrUUlBLENBQUFBLEtBQUFvRyxTQUFBLGdCQUFBQSxNQUFPckIsY0FBQSxLQUFQLGdCQUFBL0UsR0FBQXdHLElBQUEsQ0FBQUo7UUFFQSxJQUFJekIsVUFBVSxJQUFJO1lBQ2hCO1FBQ0Y7UUFFQVAsT0FBTztZQUFFakssTUFBTTtZQUFRQyxTQUFTdUs7UUFBTSxHQUFHMEI7SUFDM0M7SUFFQSxPQUFPO1FBQ0xqQztRQUNBbEY7UUFDQXdGO1FBQ0FqSztRQUNBa0s7UUFDQUM7UUFDQUk7UUFDQXVCO1FBQ0FMO1FBQ0FuQztJQUNGO0FBQ0Y7SUFwS2dCZ0M7O1FBUWtCOU0sMkNBQUFBO1FBQ05BLDJDQUFBQTtRQUNNQSwyQ0FBQUE7UUFDSkEsMkNBQUFBO1FBQ0ZBLDJDQUFBQTs7O0FBNkpyQixJQUFNd04sNEJBQTRCViIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vdXNlLWNoYXQudHM/ODgyOCIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3NoYXJlZC9zdHJlYW0tcGFydHMudHM/YzRhOCIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3NoYXJlZC9yZWFkLWRhdGEtc3RyZWFtLnRzPzE4ZjEiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9zaGFyZWQvZ2VuZXJhdGUtaWQudHM/MGQ1ZiIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3NoYXJlZC9wYXJzZS1jb21wbGV4LXJlc3BvbnNlLnRzPzY1ZTAiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9zaGFyZWQvdXRpbHMudHM/ZjhjZiIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3NoYXJlZC9jYWxsLWNoYXQtYXBpLnRzP2I1NWIiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9zaGFyZWQvcHJvY2Vzcy1jaGF0LXN0cmVhbS50cz84ZDdmIiwid2VicGFjazovL19OX0UvLi4vdXNlLWNvbXBsZXRpb24udHM/YWU3ZiIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3NoYXJlZC9jYWxsLWNvbXBsZXRpb24tYXBpLnRzPzg1MjUiLCJ3ZWJwYWNrOi8vX05fRS8uLi91c2UtYXNzaXN0YW50LnRzPzI4MTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlSWQsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlU1dSLCB7IEtleWVkTXV0YXRvciB9IGZyb20gJ3N3cic7XG5pbXBvcnQgeyBjYWxsQ2hhdEFwaSB9IGZyb20gJy4uL3NoYXJlZC9jYWxsLWNoYXQtYXBpJztcbmltcG9ydCB7IGdlbmVyYXRlSWQgYXMgZ2VuZXJhdGVJZEZ1bmMgfSBmcm9tICcuLi9zaGFyZWQvZ2VuZXJhdGUtaWQnO1xuaW1wb3J0IHsgcHJvY2Vzc0NoYXRTdHJlYW0gfSBmcm9tICcuLi9zaGFyZWQvcHJvY2Vzcy1jaGF0LXN0cmVhbSc7XG5pbXBvcnQgdHlwZSB7XG4gIENoYXRSZXF1ZXN0LFxuICBDaGF0UmVxdWVzdE9wdGlvbnMsXG4gIENyZWF0ZU1lc3NhZ2UsXG4gIElkR2VuZXJhdG9yLFxuICBKU09OVmFsdWUsXG4gIE1lc3NhZ2UsXG4gIFVzZUNoYXRPcHRpb25zLFxufSBmcm9tICcuLi9zaGFyZWQvdHlwZXMnO1xuaW1wb3J0IHR5cGUge1xuICBSZWFjdFJlc3BvbnNlUm93LFxuICBleHBlcmltZW50YWxfU3RyZWFtaW5nUmVhY3RSZXNwb25zZSxcbn0gZnJvbSAnLi4vc3RyZWFtcy9zdHJlYW1pbmctcmVhY3QtcmVzcG9uc2UnO1xuZXhwb3J0IHR5cGUgeyBDcmVhdGVNZXNzYWdlLCBNZXNzYWdlLCBVc2VDaGF0T3B0aW9ucyB9O1xuXG5leHBvcnQgdHlwZSBVc2VDaGF0SGVscGVycyA9IHtcbiAgLyoqIEN1cnJlbnQgbWVzc2FnZXMgaW4gdGhlIGNoYXQgKi9cbiAgbWVzc2FnZXM6IE1lc3NhZ2VbXTtcbiAgLyoqIFRoZSBlcnJvciBvYmplY3Qgb2YgdGhlIEFQSSByZXF1ZXN0ICovXG4gIGVycm9yOiB1bmRlZmluZWQgfCBFcnJvcjtcbiAgLyoqXG4gICAqIEFwcGVuZCBhIHVzZXIgbWVzc2FnZSB0byB0aGUgY2hhdCBsaXN0LiBUaGlzIHRyaWdnZXJzIHRoZSBBUEkgY2FsbCB0byBmZXRjaFxuICAgKiB0aGUgYXNzaXN0YW50J3MgcmVzcG9uc2UuXG4gICAqIEBwYXJhbSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGFwcGVuZFxuICAgKiBAcGFyYW0gb3B0aW9ucyBBZGRpdGlvbmFsIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgQVBJIGNhbGxcbiAgICovXG4gIGFwcGVuZDogKFxuICAgIG1lc3NhZ2U6IE1lc3NhZ2UgfCBDcmVhdGVNZXNzYWdlLFxuICAgIGNoYXRSZXF1ZXN0T3B0aW9ucz86IENoYXRSZXF1ZXN0T3B0aW9ucyxcbiAgKSA9PiBQcm9taXNlPHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ+O1xuICAvKipcbiAgICogUmVsb2FkIHRoZSBsYXN0IEFJIGNoYXQgcmVzcG9uc2UgZm9yIHRoZSBnaXZlbiBjaGF0IGhpc3RvcnkuIElmIHRoZSBsYXN0XG4gICAqIG1lc3NhZ2UgaXNuJ3QgZnJvbSB0aGUgYXNzaXN0YW50LCBpdCB3aWxsIHJlcXVlc3QgdGhlIEFQSSB0byBnZW5lcmF0ZSBhXG4gICAqIG5ldyByZXNwb25zZS5cbiAgICovXG4gIHJlbG9hZDogKFxuICAgIGNoYXRSZXF1ZXN0T3B0aW9ucz86IENoYXRSZXF1ZXN0T3B0aW9ucyxcbiAgKSA9PiBQcm9taXNlPHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ+O1xuICAvKipcbiAgICogQWJvcnQgdGhlIGN1cnJlbnQgcmVxdWVzdCBpbW1lZGlhdGVseSwga2VlcCB0aGUgZ2VuZXJhdGVkIHRva2VucyBpZiBhbnkuXG4gICAqL1xuICBzdG9wOiAoKSA9PiB2b2lkO1xuICAvKipcbiAgICogVXBkYXRlIHRoZSBgbWVzc2FnZXNgIHN0YXRlIGxvY2FsbHkuIFRoaXMgaXMgdXNlZnVsIHdoZW4geW91IHdhbnQgdG9cbiAgICogZWRpdCB0aGUgbWVzc2FnZXMgb24gdGhlIGNsaWVudCwgYW5kIHRoZW4gdHJpZ2dlciB0aGUgYHJlbG9hZGAgbWV0aG9kXG4gICAqIG1hbnVhbGx5IHRvIHJlZ2VuZXJhdGUgdGhlIEFJIHJlc3BvbnNlLlxuICAgKi9cbiAgc2V0TWVzc2FnZXM6IChtZXNzYWdlczogTWVzc2FnZVtdKSA9PiB2b2lkO1xuICAvKiogVGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGlucHV0ICovXG4gIGlucHV0OiBzdHJpbmc7XG4gIC8qKiBzZXRTdGF0ZS1wb3dlcmVkIG1ldGhvZCB0byB1cGRhdGUgdGhlIGlucHV0IHZhbHVlICovXG4gIHNldElucHV0OiBSZWFjdC5EaXNwYXRjaDxSZWFjdC5TZXRTdGF0ZUFjdGlvbjxzdHJpbmc+PjtcbiAgLyoqIEFuIGlucHV0L3RleHRhcmVhLXJlYWR5IG9uQ2hhbmdlIGhhbmRsZXIgdG8gY29udHJvbCB0aGUgdmFsdWUgb2YgdGhlIGlucHV0ICovXG4gIGhhbmRsZUlucHV0Q2hhbmdlOiAoXG4gICAgZTpcbiAgICAgIHwgUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD5cbiAgICAgIHwgUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTFRleHRBcmVhRWxlbWVudD4sXG4gICkgPT4gdm9pZDtcbiAgLyoqIEZvcm0gc3VibWlzc2lvbiBoYW5kbGVyIHRvIGF1dG9tYXRpY2FsbHkgcmVzZXQgaW5wdXQgYW5kIGFwcGVuZCBhIHVzZXIgbWVzc2FnZSAqL1xuICBoYW5kbGVTdWJtaXQ6IChcbiAgICBlOiBSZWFjdC5Gb3JtRXZlbnQ8SFRNTEZvcm1FbGVtZW50PixcbiAgICBjaGF0UmVxdWVzdE9wdGlvbnM/OiBDaGF0UmVxdWVzdE9wdGlvbnMsXG4gICkgPT4gdm9pZDtcbiAgbWV0YWRhdGE/OiBPYmplY3Q7XG4gIC8qKiBXaGV0aGVyIHRoZSBBUEkgcmVxdWVzdCBpcyBpbiBwcm9ncmVzcyAqL1xuICBpc0xvYWRpbmc6IGJvb2xlYW47XG4gIC8qKiBBZGRpdGlvbmFsIGRhdGEgYWRkZWQgb24gdGhlIHNlcnZlciB2aWEgU3RyZWFtRGF0YSAqL1xuICBkYXRhPzogSlNPTlZhbHVlW107XG59O1xuXG50eXBlIFN0cmVhbWluZ1JlYWN0UmVzcG9uc2VBY3Rpb24gPSAocGF5bG9hZDoge1xuICBtZXNzYWdlczogTWVzc2FnZVtdO1xuICBkYXRhPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbn0pID0+IFByb21pc2U8ZXhwZXJpbWVudGFsX1N0cmVhbWluZ1JlYWN0UmVzcG9uc2U+O1xuXG5jb25zdCBnZXRTdHJlYW1lZFJlc3BvbnNlID0gYXN5bmMgKFxuICBhcGk6IHN0cmluZyB8IFN0cmVhbWluZ1JlYWN0UmVzcG9uc2VBY3Rpb24sXG4gIGNoYXRSZXF1ZXN0OiBDaGF0UmVxdWVzdCxcbiAgbXV0YXRlOiBLZXllZE11dGF0b3I8TWVzc2FnZVtdPixcbiAgbXV0YXRlU3RyZWFtRGF0YTogS2V5ZWRNdXRhdG9yPEpTT05WYWx1ZVtdIHwgdW5kZWZpbmVkPixcbiAgZXhpc3RpbmdEYXRhOiBKU09OVmFsdWVbXSB8IHVuZGVmaW5lZCxcbiAgZXh0cmFNZXRhZGF0YVJlZjogUmVhY3QuTXV0YWJsZVJlZk9iamVjdDxhbnk+LFxuICBtZXNzYWdlc1JlZjogUmVhY3QuTXV0YWJsZVJlZk9iamVjdDxNZXNzYWdlW10+LFxuICBhYm9ydENvbnRyb2xsZXJSZWY6IFJlYWN0Lk11dGFibGVSZWZPYmplY3Q8QWJvcnRDb250cm9sbGVyIHwgbnVsbD4sXG4gIGdlbmVyYXRlSWQ6IElkR2VuZXJhdG9yLFxuICBzdHJlYW1Nb2RlPzogJ3N0cmVhbS1kYXRhJyB8ICd0ZXh0JyxcbiAgb25GaW5pc2g/OiAobWVzc2FnZTogTWVzc2FnZSkgPT4gdm9pZCxcbiAgb25SZXNwb25zZT86IChyZXNwb25zZTogUmVzcG9uc2UpID0+IHZvaWQgfCBQcm9taXNlPHZvaWQ+LFxuICBzZW5kRXh0cmFNZXNzYWdlRmllbGRzPzogYm9vbGVhbixcbikgPT4ge1xuICAvLyBEbyBhbiBvcHRpbWlzdGljIHVwZGF0ZSB0byB0aGUgY2hhdCBzdGF0ZSB0byBzaG93IHRoZSB1cGRhdGVkIG1lc3NhZ2VzXG4gIC8vIGltbWVkaWF0ZWx5LlxuICBjb25zdCBwcmV2aW91c01lc3NhZ2VzID0gbWVzc2FnZXNSZWYuY3VycmVudDtcbiAgbXV0YXRlKGNoYXRSZXF1ZXN0Lm1lc3NhZ2VzLCBmYWxzZSk7XG5cbiAgY29uc3QgY29uc3RydWN0ZWRNZXNzYWdlc1BheWxvYWQgPSBzZW5kRXh0cmFNZXNzYWdlRmllbGRzXG4gICAgPyBjaGF0UmVxdWVzdC5tZXNzYWdlc1xuICAgIDogY2hhdFJlcXVlc3QubWVzc2FnZXMubWFwKFxuICAgICAgICAoeyByb2xlLCBjb250ZW50LCBuYW1lLCBmdW5jdGlvbl9jYWxsLCB0b29sX2NhbGxzLCB0b29sX2NhbGxfaWQgfSkgPT4gKHtcbiAgICAgICAgICByb2xlLFxuICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgdG9vbF9jYWxsX2lkLFxuICAgICAgICAgIC4uLihuYW1lICE9PSB1bmRlZmluZWQgJiYgeyBuYW1lIH0pLFxuICAgICAgICAgIC4uLihmdW5jdGlvbl9jYWxsICE9PSB1bmRlZmluZWQgJiYge1xuICAgICAgICAgICAgZnVuY3Rpb25fY2FsbDogZnVuY3Rpb25fY2FsbCxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAuLi4odG9vbF9jYWxscyAhPT0gdW5kZWZpbmVkICYmIHtcbiAgICAgICAgICAgIHRvb2xfY2FsbHM6IHRvb2xfY2FsbHMsXG4gICAgICAgICAgfSksXG4gICAgICAgIH0pLFxuICAgICAgKTtcblxuICBpZiAodHlwZW9mIGFwaSAhPT0gJ3N0cmluZycpIHtcbiAgICAvLyBJbiB0aGlzIGNhc2UsIHdlIGFyZSBoYW5kbGluZyBhIFNlcnZlciBBY3Rpb24uIE5vIGNvbXBsZXggbW9kZSBoYW5kbGluZyBuZWVkZWQuXG5cbiAgICBjb25zdCByZXBseUlkID0gZ2VuZXJhdGVJZCgpO1xuICAgIGNvbnN0IGNyZWF0ZWRBdCA9IG5ldyBEYXRlKCk7XG4gICAgbGV0IHJlc3BvbnNlTWVzc2FnZTogTWVzc2FnZSA9IHtcbiAgICAgIGlkOiByZXBseUlkLFxuICAgICAgY3JlYXRlZEF0LFxuICAgICAgY29udGVudDogJycsXG4gICAgICByb2xlOiAnYXNzaXN0YW50JyxcbiAgICB9O1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gcmVhZFJvdyhwcm9taXNlOiBQcm9taXNlPFJlYWN0UmVzcG9uc2VSb3c+KSB7XG4gICAgICBjb25zdCB7IGNvbnRlbnQsIHVpLCBuZXh0IH0gPSBhd2FpdCBwcm9taXNlO1xuXG4gICAgICAvLyBUT0RPOiBIYW5kbGUgZnVuY3Rpb24gY2FsbHMuXG4gICAgICByZXNwb25zZU1lc3NhZ2VbJ2NvbnRlbnQnXSA9IGNvbnRlbnQ7XG4gICAgICByZXNwb25zZU1lc3NhZ2VbJ3VpJ10gPSBhd2FpdCB1aTtcblxuICAgICAgbXV0YXRlKFsuLi5jaGF0UmVxdWVzdC5tZXNzYWdlcywgeyAuLi5yZXNwb25zZU1lc3NhZ2UgfV0sIGZhbHNlKTtcblxuICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgYXdhaXQgcmVhZFJvdyhuZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcHJvbWlzZSA9IGFwaSh7XG4gICAgICAgIG1lc3NhZ2VzOiBjb25zdHJ1Y3RlZE1lc3NhZ2VzUGF5bG9hZCBhcyBNZXNzYWdlW10sXG4gICAgICAgIGRhdGE6IGNoYXRSZXF1ZXN0LmRhdGEsXG4gICAgICB9KSBhcyBQcm9taXNlPFJlYWN0UmVzcG9uc2VSb3c+O1xuICAgICAgYXdhaXQgcmVhZFJvdyhwcm9taXNlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBSZXN0b3JlIHRoZSBwcmV2aW91cyBtZXNzYWdlcyBpZiB0aGUgcmVxdWVzdCBmYWlscy5cbiAgICAgIG11dGF0ZShwcmV2aW91c01lc3NhZ2VzLCBmYWxzZSk7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIGlmIChvbkZpbmlzaCkge1xuICAgICAgb25GaW5pc2gocmVzcG9uc2VNZXNzYWdlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzcG9uc2VNZXNzYWdlO1xuICB9XG5cbiAgcmV0dXJuIGF3YWl0IGNhbGxDaGF0QXBpKHtcbiAgICBhcGksXG4gICAgbWVzc2FnZXM6IGNvbnN0cnVjdGVkTWVzc2FnZXNQYXlsb2FkLFxuICAgIGJvZHk6IHtcbiAgICAgIGRhdGE6IGNoYXRSZXF1ZXN0LmRhdGEsXG4gICAgICAuLi5leHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQuYm9keSxcbiAgICAgIC4uLmNoYXRSZXF1ZXN0Lm9wdGlvbnM/LmJvZHksXG4gICAgICAuLi4oY2hhdFJlcXVlc3QuZnVuY3Rpb25zICE9PSB1bmRlZmluZWQgJiYge1xuICAgICAgICBmdW5jdGlvbnM6IGNoYXRSZXF1ZXN0LmZ1bmN0aW9ucyxcbiAgICAgIH0pLFxuICAgICAgLi4uKGNoYXRSZXF1ZXN0LmZ1bmN0aW9uX2NhbGwgIT09IHVuZGVmaW5lZCAmJiB7XG4gICAgICAgIGZ1bmN0aW9uX2NhbGw6IGNoYXRSZXF1ZXN0LmZ1bmN0aW9uX2NhbGwsXG4gICAgICB9KSxcbiAgICAgIC4uLihjaGF0UmVxdWVzdC50b29scyAhPT0gdW5kZWZpbmVkICYmIHtcbiAgICAgICAgdG9vbHM6IGNoYXRSZXF1ZXN0LnRvb2xzLFxuICAgICAgfSksXG4gICAgICAuLi4oY2hhdFJlcXVlc3QudG9vbF9jaG9pY2UgIT09IHVuZGVmaW5lZCAmJiB7XG4gICAgICAgIHRvb2xfY2hvaWNlOiBjaGF0UmVxdWVzdC50b29sX2Nob2ljZSxcbiAgICAgIH0pLFxuICAgIH0sXG4gICAgc3RyZWFtTW9kZSxcbiAgICBjcmVkZW50aWFsczogZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LmNyZWRlbnRpYWxzLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIC4uLmV4dHJhTWV0YWRhdGFSZWYuY3VycmVudC5oZWFkZXJzLFxuICAgICAgLi4uY2hhdFJlcXVlc3Qub3B0aW9ucz8uaGVhZGVycyxcbiAgICB9LFxuICAgIGFib3J0Q29udHJvbGxlcjogKCkgPT4gYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQsXG4gICAgcmVzdG9yZU1lc3NhZ2VzT25GYWlsdXJlKCkge1xuICAgICAgbXV0YXRlKHByZXZpb3VzTWVzc2FnZXMsIGZhbHNlKTtcbiAgICB9LFxuICAgIG9uUmVzcG9uc2UsXG4gICAgb25VcGRhdGUobWVyZ2VkLCBkYXRhKSB7XG4gICAgICBtdXRhdGUoWy4uLmNoYXRSZXF1ZXN0Lm1lc3NhZ2VzLCAuLi5tZXJnZWRdLCBmYWxzZSk7XG4gICAgICBtdXRhdGVTdHJlYW1EYXRhKFsuLi4oZXhpc3RpbmdEYXRhIHx8IFtdKSwgLi4uKGRhdGEgfHwgW10pXSwgZmFsc2UpO1xuICAgIH0sXG4gICAgb25GaW5pc2gsXG4gICAgZ2VuZXJhdGVJZCxcbiAgfSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlQ2hhdCh7XG4gIGFwaSA9ICcvYXBpL2NoYXQnLFxuICBpZCxcbiAgaW5pdGlhbE1lc3NhZ2VzLFxuICBpbml0aWFsSW5wdXQgPSAnJyxcbiAgc2VuZEV4dHJhTWVzc2FnZUZpZWxkcyxcbiAgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsLFxuICBleHBlcmltZW50YWxfb25Ub29sQ2FsbCxcbiAgc3RyZWFtTW9kZSxcbiAgb25SZXNwb25zZSxcbiAgb25GaW5pc2gsXG4gIG9uRXJyb3IsXG4gIGNyZWRlbnRpYWxzLFxuICBoZWFkZXJzLFxuICBib2R5LFxuICBnZW5lcmF0ZUlkID0gZ2VuZXJhdGVJZEZ1bmMsXG59OiBPbWl0PFVzZUNoYXRPcHRpb25zLCAnYXBpJz4gJiB7XG4gIGFwaT86IHN0cmluZyB8IFN0cmVhbWluZ1JlYWN0UmVzcG9uc2VBY3Rpb247XG4gIGtleT86IHN0cmluZztcbn0gPSB7fSk6IFVzZUNoYXRIZWxwZXJzIHtcbiAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgaWQgZm9yIHRoZSBjaGF0IGlmIG5vdCBwcm92aWRlZC5cbiAgY29uc3QgaG9va0lkID0gdXNlSWQoKTtcbiAgY29uc3QgaWRLZXkgPSBpZCA/PyBob29rSWQ7XG4gIGNvbnN0IGNoYXRLZXkgPSB0eXBlb2YgYXBpID09PSAnc3RyaW5nJyA/IFthcGksIGlkS2V5XSA6IGlkS2V5O1xuXG4gIC8vIFN0b3JlIGEgZW1wdHkgYXJyYXkgYXMgdGhlIGluaXRpYWwgbWVzc2FnZXNcbiAgLy8gKGluc3RlYWQgb2YgdXNpbmcgYSBkZWZhdWx0IHBhcmFtZXRlciB2YWx1ZSB0aGF0IGdldHMgcmUtY3JlYXRlZCBlYWNoIHRpbWUpXG4gIC8vIHRvIGF2b2lkIHJlLXJlbmRlcnM6XG4gIGNvbnN0IFtpbml0aWFsTWVzc2FnZXNGYWxsYmFja10gPSB1c2VTdGF0ZShbXSk7XG5cbiAgLy8gU3RvcmUgdGhlIGNoYXQgc3RhdGUgaW4gU1dSLCB1c2luZyB0aGUgY2hhdElkIGFzIHRoZSBrZXkgdG8gc2hhcmUgc3RhdGVzLlxuICBjb25zdCB7IGRhdGE6IG1lc3NhZ2VzLCBtdXRhdGUgfSA9IHVzZVNXUjxNZXNzYWdlW10+KFxuICAgIFtjaGF0S2V5LCAnbWVzc2FnZXMnXSxcbiAgICBudWxsLFxuICAgIHsgZmFsbGJhY2tEYXRhOiBpbml0aWFsTWVzc2FnZXMgPz8gaW5pdGlhbE1lc3NhZ2VzRmFsbGJhY2sgfSxcbiAgKTtcblxuICAvLyBXZSBzdG9yZSBsb2FkaW5nIHN0YXRlIGluIGFub3RoZXIgaG9vayB0byBzeW5jIGxvYWRpbmcgc3RhdGVzIGFjcm9zcyBob29rIGludm9jYXRpb25zXG4gIGNvbnN0IHsgZGF0YTogaXNMb2FkaW5nID0gZmFsc2UsIG11dGF0ZTogbXV0YXRlTG9hZGluZyB9ID0gdXNlU1dSPGJvb2xlYW4+KFxuICAgIFtjaGF0S2V5LCAnbG9hZGluZyddLFxuICAgIG51bGwsXG4gICk7XG5cbiAgY29uc3QgeyBkYXRhOiBzdHJlYW1EYXRhLCBtdXRhdGU6IG11dGF0ZVN0cmVhbURhdGEgfSA9IHVzZVNXUjxcbiAgICBKU09OVmFsdWVbXSB8IHVuZGVmaW5lZFxuICA+KFtjaGF0S2V5LCAnc3RyZWFtRGF0YSddLCBudWxsKTtcblxuICBjb25zdCB7IGRhdGE6IGVycm9yID0gdW5kZWZpbmVkLCBtdXRhdGU6IHNldEVycm9yIH0gPSB1c2VTV1I8XG4gICAgdW5kZWZpbmVkIHwgRXJyb3JcbiAgPihbY2hhdEtleSwgJ2Vycm9yJ10sIG51bGwpO1xuXG4gIC8vIEtlZXAgdGhlIGxhdGVzdCBtZXNzYWdlcyBpbiBhIHJlZi5cbiAgY29uc3QgbWVzc2FnZXNSZWYgPSB1c2VSZWY8TWVzc2FnZVtdPihtZXNzYWdlcyB8fCBbXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbWVzc2FnZXNSZWYuY3VycmVudCA9IG1lc3NhZ2VzIHx8IFtdO1xuICB9LCBbbWVzc2FnZXNdKTtcblxuICAvLyBBYm9ydCBjb250cm9sbGVyIHRvIGNhbmNlbCB0aGUgY3VycmVudCBBUEkgY2FsbC5cbiAgY29uc3QgYWJvcnRDb250cm9sbGVyUmVmID0gdXNlUmVmPEFib3J0Q29udHJvbGxlciB8IG51bGw+KG51bGwpO1xuXG4gIGNvbnN0IGV4dHJhTWV0YWRhdGFSZWYgPSB1c2VSZWYoe1xuICAgIGNyZWRlbnRpYWxzLFxuICAgIGhlYWRlcnMsXG4gICAgYm9keSxcbiAgfSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBleHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQgPSB7XG4gICAgICBjcmVkZW50aWFscyxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBib2R5LFxuICAgIH07XG4gIH0sIFtjcmVkZW50aWFscywgaGVhZGVycywgYm9keV0pO1xuXG4gIGNvbnN0IHRyaWdnZXJSZXF1ZXN0ID0gdXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKGNoYXRSZXF1ZXN0OiBDaGF0UmVxdWVzdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbXV0YXRlTG9hZGluZyh0cnVlKTtcbiAgICAgICAgc2V0RXJyb3IodW5kZWZpbmVkKTtcblxuICAgICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50ID0gYWJvcnRDb250cm9sbGVyO1xuXG4gICAgICAgIGF3YWl0IHByb2Nlc3NDaGF0U3RyZWFtKHtcbiAgICAgICAgICBnZXRTdHJlYW1lZFJlc3BvbnNlOiAoKSA9PlxuICAgICAgICAgICAgZ2V0U3RyZWFtZWRSZXNwb25zZShcbiAgICAgICAgICAgICAgYXBpLFxuICAgICAgICAgICAgICBjaGF0UmVxdWVzdCxcbiAgICAgICAgICAgICAgbXV0YXRlLFxuICAgICAgICAgICAgICBtdXRhdGVTdHJlYW1EYXRhLFxuICAgICAgICAgICAgICBzdHJlYW1EYXRhISxcbiAgICAgICAgICAgICAgZXh0cmFNZXRhZGF0YVJlZixcbiAgICAgICAgICAgICAgbWVzc2FnZXNSZWYsXG4gICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlclJlZixcbiAgICAgICAgICAgICAgZ2VuZXJhdGVJZCxcbiAgICAgICAgICAgICAgc3RyZWFtTW9kZSxcbiAgICAgICAgICAgICAgb25GaW5pc2gsXG4gICAgICAgICAgICAgIG9uUmVzcG9uc2UsXG4gICAgICAgICAgICAgIHNlbmRFeHRyYU1lc3NhZ2VGaWVsZHMsXG4gICAgICAgICAgICApLFxuICAgICAgICAgIGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCxcbiAgICAgICAgICBleHBlcmltZW50YWxfb25Ub29sQ2FsbCxcbiAgICAgICAgICB1cGRhdGVDaGF0UmVxdWVzdDogY2hhdFJlcXVlc3RQYXJhbSA9PiB7XG4gICAgICAgICAgICBjaGF0UmVxdWVzdCA9IGNoYXRSZXF1ZXN0UGFyYW07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXRDdXJyZW50TWVzc2FnZXM6ICgpID0+IG1lc3NhZ2VzUmVmLmN1cnJlbnQsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBJZ25vcmUgYWJvcnQgZXJyb3JzIGFzIHRoZXkgYXJlIGV4cGVjdGVkLlxuICAgICAgICBpZiAoKGVyciBhcyBhbnkpLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICAgIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvbkVycm9yICYmIGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0RXJyb3IoZXJyIGFzIEVycm9yKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIG11dGF0ZUxvYWRpbmcoZmFsc2UpO1xuICAgICAgfVxuICAgIH0sXG4gICAgW1xuICAgICAgbXV0YXRlLFxuICAgICAgbXV0YXRlTG9hZGluZyxcbiAgICAgIGFwaSxcbiAgICAgIGV4dHJhTWV0YWRhdGFSZWYsXG4gICAgICBvblJlc3BvbnNlLFxuICAgICAgb25GaW5pc2gsXG4gICAgICBvbkVycm9yLFxuICAgICAgc2V0RXJyb3IsXG4gICAgICBtdXRhdGVTdHJlYW1EYXRhLFxuICAgICAgc3RyZWFtRGF0YSxcbiAgICAgIHNlbmRFeHRyYU1lc3NhZ2VGaWVsZHMsXG4gICAgICBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwsXG4gICAgICBleHBlcmltZW50YWxfb25Ub29sQ2FsbCxcbiAgICAgIG1lc3NhZ2VzUmVmLFxuICAgICAgYWJvcnRDb250cm9sbGVyUmVmLFxuICAgICAgZ2VuZXJhdGVJZCxcbiAgICBdLFxuICApO1xuXG4gIGNvbnN0IGFwcGVuZCA9IHVzZUNhbGxiYWNrKFxuICAgIGFzeW5jIChcbiAgICAgIG1lc3NhZ2U6IE1lc3NhZ2UgfCBDcmVhdGVNZXNzYWdlLFxuICAgICAge1xuICAgICAgICBvcHRpb25zLFxuICAgICAgICBmdW5jdGlvbnMsXG4gICAgICAgIGZ1bmN0aW9uX2NhbGwsXG4gICAgICAgIHRvb2xzLFxuICAgICAgICB0b29sX2Nob2ljZSxcbiAgICAgICAgZGF0YSxcbiAgICAgIH06IENoYXRSZXF1ZXN0T3B0aW9ucyA9IHt9LFxuICAgICkgPT4ge1xuICAgICAgaWYgKCFtZXNzYWdlLmlkKSB7XG4gICAgICAgIG1lc3NhZ2UuaWQgPSBnZW5lcmF0ZUlkKCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNoYXRSZXF1ZXN0OiBDaGF0UmVxdWVzdCA9IHtcbiAgICAgICAgbWVzc2FnZXM6IG1lc3NhZ2VzUmVmLmN1cnJlbnQuY29uY2F0KG1lc3NhZ2UgYXMgTWVzc2FnZSksXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIC4uLihmdW5jdGlvbnMgIT09IHVuZGVmaW5lZCAmJiB7IGZ1bmN0aW9ucyB9KSxcbiAgICAgICAgLi4uKGZ1bmN0aW9uX2NhbGwgIT09IHVuZGVmaW5lZCAmJiB7IGZ1bmN0aW9uX2NhbGwgfSksXG4gICAgICAgIC4uLih0b29scyAhPT0gdW5kZWZpbmVkICYmIHsgdG9vbHMgfSksXG4gICAgICAgIC4uLih0b29sX2Nob2ljZSAhPT0gdW5kZWZpbmVkICYmIHsgdG9vbF9jaG9pY2UgfSksXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gdHJpZ2dlclJlcXVlc3QoY2hhdFJlcXVlc3QpO1xuICAgIH0sXG4gICAgW3RyaWdnZXJSZXF1ZXN0LCBnZW5lcmF0ZUlkXSxcbiAgKTtcblxuICBjb25zdCByZWxvYWQgPSB1c2VDYWxsYmFjayhcbiAgICBhc3luYyAoe1xuICAgICAgb3B0aW9ucyxcbiAgICAgIGZ1bmN0aW9ucyxcbiAgICAgIGZ1bmN0aW9uX2NhbGwsXG4gICAgICB0b29scyxcbiAgICAgIHRvb2xfY2hvaWNlLFxuICAgIH06IENoYXRSZXF1ZXN0T3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICBpZiAobWVzc2FnZXNSZWYuY3VycmVudC5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gICAgICAvLyBSZW1vdmUgbGFzdCBhc3Npc3RhbnQgbWVzc2FnZSBhbmQgcmV0cnkgbGFzdCB1c2VyIG1lc3NhZ2UuXG4gICAgICBjb25zdCBsYXN0TWVzc2FnZSA9IG1lc3NhZ2VzUmVmLmN1cnJlbnRbbWVzc2FnZXNSZWYuY3VycmVudC5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChsYXN0TWVzc2FnZS5yb2xlID09PSAnYXNzaXN0YW50Jykge1xuICAgICAgICBjb25zdCBjaGF0UmVxdWVzdDogQ2hhdFJlcXVlc3QgPSB7XG4gICAgICAgICAgbWVzc2FnZXM6IG1lc3NhZ2VzUmVmLmN1cnJlbnQuc2xpY2UoMCwgLTEpLFxuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgLi4uKGZ1bmN0aW9ucyAhPT0gdW5kZWZpbmVkICYmIHsgZnVuY3Rpb25zIH0pLFxuICAgICAgICAgIC4uLihmdW5jdGlvbl9jYWxsICE9PSB1bmRlZmluZWQgJiYgeyBmdW5jdGlvbl9jYWxsIH0pLFxuICAgICAgICAgIC4uLih0b29scyAhPT0gdW5kZWZpbmVkICYmIHsgdG9vbHMgfSksXG4gICAgICAgICAgLi4uKHRvb2xfY2hvaWNlICE9PSB1bmRlZmluZWQgJiYgeyB0b29sX2Nob2ljZSB9KSxcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdHJpZ2dlclJlcXVlc3QoY2hhdFJlcXVlc3QpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjaGF0UmVxdWVzdDogQ2hhdFJlcXVlc3QgPSB7XG4gICAgICAgIG1lc3NhZ2VzOiBtZXNzYWdlc1JlZi5jdXJyZW50LFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICAuLi4oZnVuY3Rpb25zICE9PSB1bmRlZmluZWQgJiYgeyBmdW5jdGlvbnMgfSksXG4gICAgICAgIC4uLihmdW5jdGlvbl9jYWxsICE9PSB1bmRlZmluZWQgJiYgeyBmdW5jdGlvbl9jYWxsIH0pLFxuICAgICAgICAuLi4odG9vbHMgIT09IHVuZGVmaW5lZCAmJiB7IHRvb2xzIH0pLFxuICAgICAgICAuLi4odG9vbF9jaG9pY2UgIT09IHVuZGVmaW5lZCAmJiB7IHRvb2xfY2hvaWNlIH0pLFxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHRyaWdnZXJSZXF1ZXN0KGNoYXRSZXF1ZXN0KTtcbiAgICB9LFxuICAgIFt0cmlnZ2VyUmVxdWVzdF0sXG4gICk7XG5cbiAgY29uc3Qgc3RvcCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQpIHtcbiAgICAgIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50LmFib3J0KCk7XG4gICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9LCBbXSk7XG5cbiAgY29uc3Qgc2V0TWVzc2FnZXMgPSB1c2VDYWxsYmFjayhcbiAgICAobWVzc2FnZXM6IE1lc3NhZ2VbXSkgPT4ge1xuICAgICAgbXV0YXRlKG1lc3NhZ2VzLCBmYWxzZSk7XG4gICAgICBtZXNzYWdlc1JlZi5jdXJyZW50ID0gbWVzc2FnZXM7XG4gICAgfSxcbiAgICBbbXV0YXRlXSxcbiAgKTtcblxuICAvLyBJbnB1dCBzdGF0ZSBhbmQgaGFuZGxlcnMuXG4gIGNvbnN0IFtpbnB1dCwgc2V0SW5wdXRdID0gdXNlU3RhdGUoaW5pdGlhbElucHV0KTtcblxuICBjb25zdCBoYW5kbGVTdWJtaXQgPSB1c2VDYWxsYmFjayhcbiAgICAoXG4gICAgICBlOiBSZWFjdC5Gb3JtRXZlbnQ8SFRNTEZvcm1FbGVtZW50PixcbiAgICAgIG9wdGlvbnM6IENoYXRSZXF1ZXN0T3B0aW9ucyA9IHt9LFxuICAgICAgbWV0YWRhdGE/OiBPYmplY3QsXG4gICAgKSA9PiB7XG4gICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50ID0ge1xuICAgICAgICAgIC4uLmV4dHJhTWV0YWRhdGFSZWYuY3VycmVudCxcbiAgICAgICAgICAuLi5tZXRhZGF0YSxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgaWYgKCFpbnB1dCkgcmV0dXJuO1xuXG4gICAgICBhcHBlbmQoXG4gICAgICAgIHtcbiAgICAgICAgICBjb250ZW50OiBpbnB1dCxcbiAgICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgICB9LFxuICAgICAgICBvcHRpb25zLFxuICAgICAgKTtcbiAgICAgIHNldElucHV0KCcnKTtcbiAgICB9LFxuICAgIFtpbnB1dCwgYXBwZW5kXSxcbiAgKTtcblxuICBjb25zdCBoYW5kbGVJbnB1dENoYW5nZSA9IChlOiBhbnkpID0+IHtcbiAgICBzZXRJbnB1dChlLnRhcmdldC52YWx1ZSk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBtZXNzYWdlczogbWVzc2FnZXMgfHwgW10sXG4gICAgZXJyb3IsXG4gICAgYXBwZW5kLFxuICAgIHJlbG9hZCxcbiAgICBzdG9wLFxuICAgIHNldE1lc3NhZ2VzLFxuICAgIGlucHV0LFxuICAgIHNldElucHV0LFxuICAgIGhhbmRsZUlucHV0Q2hhbmdlLFxuICAgIGhhbmRsZVN1Ym1pdCxcbiAgICBpc0xvYWRpbmcsXG4gICAgZGF0YTogc3RyZWFtRGF0YSxcbiAgfTtcbn1cbiIsImltcG9ydCB7XG4gIEFzc2lzdGFudE1lc3NhZ2UsXG4gIERhdGFNZXNzYWdlLFxuICBGdW5jdGlvbkNhbGwsXG4gIEpTT05WYWx1ZSxcbiAgVG9vbENhbGwsXG59IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgU3RyZWFtU3RyaW5nIH0gZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RyZWFtUGFydDxDT0RFIGV4dGVuZHMgc3RyaW5nLCBOQU1FIGV4dGVuZHMgc3RyaW5nLCBUWVBFPiB7XG4gIGNvZGU6IENPREU7XG4gIG5hbWU6IE5BTUU7XG4gIHBhcnNlOiAodmFsdWU6IEpTT05WYWx1ZSkgPT4geyB0eXBlOiBOQU1FOyB2YWx1ZTogVFlQRSB9O1xufVxuXG5jb25zdCB0ZXh0U3RyZWFtUGFydDogU3RyZWFtUGFydDwnMCcsICd0ZXh0Jywgc3RyaW5nPiA9IHtcbiAgY29kZTogJzAnLFxuICBuYW1lOiAndGV4dCcsXG4gIHBhcnNlOiAodmFsdWU6IEpTT05WYWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1widGV4dFwiIHBhcnRzIGV4cGVjdCBhIHN0cmluZyB2YWx1ZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogJ3RleHQnLCB2YWx1ZSB9O1xuICB9LFxufTtcblxuY29uc3QgZnVuY3Rpb25DYWxsU3RyZWFtUGFydDogU3RyZWFtUGFydDxcbiAgJzEnLFxuICAnZnVuY3Rpb25fY2FsbCcsXG4gIHsgZnVuY3Rpb25fY2FsbDogRnVuY3Rpb25DYWxsIH1cbj4gPSB7XG4gIGNvZGU6ICcxJyxcbiAgbmFtZTogJ2Z1bmN0aW9uX2NhbGwnLFxuICBwYXJzZTogKHZhbHVlOiBKU09OVmFsdWUpID0+IHtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSA9PSBudWxsIHx8XG4gICAgICB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8XG4gICAgICAhKCdmdW5jdGlvbl9jYWxsJyBpbiB2YWx1ZSkgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZS5mdW5jdGlvbl9jYWxsICE9PSAnb2JqZWN0JyB8fFxuICAgICAgdmFsdWUuZnVuY3Rpb25fY2FsbCA9PSBudWxsIHx8XG4gICAgICAhKCduYW1lJyBpbiB2YWx1ZS5mdW5jdGlvbl9jYWxsKSB8fFxuICAgICAgISgnYXJndW1lbnRzJyBpbiB2YWx1ZS5mdW5jdGlvbl9jYWxsKSB8fFxuICAgICAgdHlwZW9mIHZhbHVlLmZ1bmN0aW9uX2NhbGwubmFtZSAhPT0gJ3N0cmluZycgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZS5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50cyAhPT0gJ3N0cmluZydcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiZnVuY3Rpb25fY2FsbFwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwiZnVuY3Rpb25fY2FsbFwiIHByb3BlcnR5LicsXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnZnVuY3Rpb25fY2FsbCcsXG4gICAgICB2YWx1ZTogdmFsdWUgYXMgdW5rbm93biBhcyB7IGZ1bmN0aW9uX2NhbGw6IEZ1bmN0aW9uQ2FsbCB9LFxuICAgIH07XG4gIH0sXG59O1xuXG5jb25zdCBkYXRhU3RyZWFtUGFydDogU3RyZWFtUGFydDwnMicsICdkYXRhJywgQXJyYXk8SlNPTlZhbHVlPj4gPSB7XG4gIGNvZGU6ICcyJyxcbiAgbmFtZTogJ2RhdGEnLFxuICBwYXJzZTogKHZhbHVlOiBKU09OVmFsdWUpID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiZGF0YVwiIHBhcnRzIGV4cGVjdCBhbiBhcnJheSB2YWx1ZS4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyB0eXBlOiAnZGF0YScsIHZhbHVlIH07XG4gIH0sXG59O1xuXG5jb25zdCBlcnJvclN0cmVhbVBhcnQ6IFN0cmVhbVBhcnQ8JzMnLCAnZXJyb3InLCBzdHJpbmc+ID0ge1xuICBjb2RlOiAnMycsXG4gIG5hbWU6ICdlcnJvcicsXG4gIHBhcnNlOiAodmFsdWU6IEpTT05WYWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiZXJyb3JcIiBwYXJ0cyBleHBlY3QgYSBzdHJpbmcgdmFsdWUuJyk7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6ICdlcnJvcicsIHZhbHVlIH07XG4gIH0sXG59O1xuXG5jb25zdCBhc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydDogU3RyZWFtUGFydDxcbiAgJzQnLFxuICAnYXNzaXN0YW50X21lc3NhZ2UnLFxuICBBc3Npc3RhbnRNZXNzYWdlXG4+ID0ge1xuICBjb2RlOiAnNCcsXG4gIG5hbWU6ICdhc3Npc3RhbnRfbWVzc2FnZScsXG4gIHBhcnNlOiAodmFsdWU6IEpTT05WYWx1ZSkgPT4ge1xuICAgIGlmIChcbiAgICAgIHZhbHVlID09IG51bGwgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICEoJ2lkJyBpbiB2YWx1ZSkgfHxcbiAgICAgICEoJ3JvbGUnIGluIHZhbHVlKSB8fFxuICAgICAgISgnY29udGVudCcgaW4gdmFsdWUpIHx8XG4gICAgICB0eXBlb2YgdmFsdWUuaWQgIT09ICdzdHJpbmcnIHx8XG4gICAgICB0eXBlb2YgdmFsdWUucm9sZSAhPT0gJ3N0cmluZycgfHxcbiAgICAgIHZhbHVlLnJvbGUgIT09ICdhc3Npc3RhbnQnIHx8XG4gICAgICAhQXJyYXkuaXNBcnJheSh2YWx1ZS5jb250ZW50KSB8fFxuICAgICAgIXZhbHVlLmNvbnRlbnQuZXZlcnkoXG4gICAgICAgIGl0ZW0gPT5cbiAgICAgICAgICBpdGVtICE9IG51bGwgJiZcbiAgICAgICAgICB0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAndHlwZScgaW4gaXRlbSAmJlxuICAgICAgICAgIGl0ZW0udHlwZSA9PT0gJ3RleHQnICYmXG4gICAgICAgICAgJ3RleHQnIGluIGl0ZW0gJiZcbiAgICAgICAgICBpdGVtLnRleHQgIT0gbnVsbCAmJlxuICAgICAgICAgIHR5cGVvZiBpdGVtLnRleHQgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgJ3ZhbHVlJyBpbiBpdGVtLnRleHQgJiZcbiAgICAgICAgICB0eXBlb2YgaXRlbS50ZXh0LnZhbHVlID09PSAnc3RyaW5nJyxcbiAgICAgIClcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiYXNzaXN0YW50X21lc3NhZ2VcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYW4gXCJpZFwiLCBcInJvbGVcIiwgYW5kIFwiY29udGVudFwiIHByb3BlcnR5LicsXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnYXNzaXN0YW50X21lc3NhZ2UnLFxuICAgICAgdmFsdWU6IHZhbHVlIGFzIEFzc2lzdGFudE1lc3NhZ2UsXG4gICAgfTtcbiAgfSxcbn07XG5cbmNvbnN0IGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydDogU3RyZWFtUGFydDxcbiAgJzUnLFxuICAnYXNzaXN0YW50X2NvbnRyb2xfZGF0YScsXG4gIHtcbiAgICB0aHJlYWRJZDogc3RyaW5nO1xuICAgIG1lc3NhZ2VJZDogc3RyaW5nO1xuICB9XG4+ID0ge1xuICBjb2RlOiAnNScsXG4gIG5hbWU6ICdhc3Npc3RhbnRfY29udHJvbF9kYXRhJyxcbiAgcGFyc2U6ICh2YWx1ZTogSlNPTlZhbHVlKSA9PiB7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fFxuICAgICAgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fFxuICAgICAgISgndGhyZWFkSWQnIGluIHZhbHVlKSB8fFxuICAgICAgISgnbWVzc2FnZUlkJyBpbiB2YWx1ZSkgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZS50aHJlYWRJZCAhPT0gJ3N0cmluZycgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZS5tZXNzYWdlSWQgIT09ICdzdHJpbmcnXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImFzc2lzdGFudF9jb250cm9sX2RhdGFcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcInRocmVhZElkXCIgYW5kIFwibWVzc2FnZUlkXCIgcHJvcGVydHkuJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdhc3Npc3RhbnRfY29udHJvbF9kYXRhJyxcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIHRocmVhZElkOiB2YWx1ZS50aHJlYWRJZCxcbiAgICAgICAgbWVzc2FnZUlkOiB2YWx1ZS5tZXNzYWdlSWQsXG4gICAgICB9LFxuICAgIH07XG4gIH0sXG59O1xuXG5jb25zdCBkYXRhTWVzc2FnZVN0cmVhbVBhcnQ6IFN0cmVhbVBhcnQ8JzYnLCAnZGF0YV9tZXNzYWdlJywgRGF0YU1lc3NhZ2U+ID0ge1xuICBjb2RlOiAnNicsXG4gIG5hbWU6ICdkYXRhX21lc3NhZ2UnLFxuICBwYXJzZTogKHZhbHVlOiBKU09OVmFsdWUpID0+IHtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSA9PSBudWxsIHx8XG4gICAgICB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8XG4gICAgICAhKCdyb2xlJyBpbiB2YWx1ZSkgfHxcbiAgICAgICEoJ2RhdGEnIGluIHZhbHVlKSB8fFxuICAgICAgdHlwZW9mIHZhbHVlLnJvbGUgIT09ICdzdHJpbmcnIHx8XG4gICAgICB2YWx1ZS5yb2xlICE9PSAnZGF0YSdcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiZGF0YV9tZXNzYWdlXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJyb2xlXCIgYW5kIFwiZGF0YVwiIHByb3BlcnR5LicsXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnZGF0YV9tZXNzYWdlJyxcbiAgICAgIHZhbHVlOiB2YWx1ZSBhcyBEYXRhTWVzc2FnZSxcbiAgICB9O1xuICB9LFxufTtcblxuY29uc3QgdG9vbENhbGxTdHJlYW1QYXJ0OiBTdHJlYW1QYXJ0PFxuICAnNycsXG4gICd0b29sX2NhbGxzJyxcbiAgeyB0b29sX2NhbGxzOiBUb29sQ2FsbFtdIH1cbj4gPSB7XG4gIGNvZGU6ICc3JyxcbiAgbmFtZTogJ3Rvb2xfY2FsbHMnLFxuICBwYXJzZTogKHZhbHVlOiBKU09OVmFsdWUpID0+IHtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSA9PSBudWxsIHx8XG4gICAgICB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8XG4gICAgICAhKCd0b29sX2NhbGxzJyBpbiB2YWx1ZSkgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZS50b29sX2NhbGxzICE9PSAnb2JqZWN0JyB8fFxuICAgICAgdmFsdWUudG9vbF9jYWxscyA9PSBudWxsIHx8XG4gICAgICAhQXJyYXkuaXNBcnJheSh2YWx1ZS50b29sX2NhbGxzKSB8fFxuICAgICAgdmFsdWUudG9vbF9jYWxscy5zb21lKFxuICAgICAgICB0YyA9PlxuICAgICAgICAgIHRjID09IG51bGwgfHxcbiAgICAgICAgICB0eXBlb2YgdGMgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgISgnaWQnIGluIHRjKSB8fFxuICAgICAgICAgIHR5cGVvZiB0Yy5pZCAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAhKCd0eXBlJyBpbiB0YykgfHxcbiAgICAgICAgICB0eXBlb2YgdGMudHlwZSAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAhKCdmdW5jdGlvbicgaW4gdGMpIHx8XG4gICAgICAgICAgdGMuZnVuY3Rpb24gPT0gbnVsbCB8fFxuICAgICAgICAgIHR5cGVvZiB0Yy5mdW5jdGlvbiAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAhKCdhcmd1bWVudHMnIGluIHRjLmZ1bmN0aW9uKSB8fFxuICAgICAgICAgIHR5cGVvZiB0Yy5mdW5jdGlvbi5uYW1lICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgIHR5cGVvZiB0Yy5mdW5jdGlvbi5hcmd1bWVudHMgIT09ICdzdHJpbmcnLFxuICAgICAgKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJ0b29sX2NhbGxzXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgVG9vbENhbGxQYXlsb2FkLicsXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAndG9vbF9jYWxscycsXG4gICAgICB2YWx1ZTogdmFsdWUgYXMgdW5rbm93biBhcyB7IHRvb2xfY2FsbHM6IFRvb2xDYWxsW10gfSxcbiAgICB9O1xuICB9LFxufTtcblxuY29uc3QgbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydDogU3RyZWFtUGFydDxcbiAgJzgnLFxuICAnbWVzc2FnZV9hbm5vdGF0aW9ucycsXG4gIEFycmF5PEpTT05WYWx1ZT5cbj4gPSB7XG4gIGNvZGU6ICc4JyxcbiAgbmFtZTogJ21lc3NhZ2VfYW5ub3RhdGlvbnMnLFxuICBwYXJzZTogKHZhbHVlOiBKU09OVmFsdWUpID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wibWVzc2FnZV9hbm5vdGF0aW9uc1wiIHBhcnRzIGV4cGVjdCBhbiBhcnJheSB2YWx1ZS4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyB0eXBlOiAnbWVzc2FnZV9hbm5vdGF0aW9ucycsIHZhbHVlIH07XG4gIH0sXG59O1xuXG5jb25zdCBzdHJlYW1QYXJ0cyA9IFtcbiAgdGV4dFN0cmVhbVBhcnQsXG4gIGZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQsXG4gIGRhdGFTdHJlYW1QYXJ0LFxuICBlcnJvclN0cmVhbVBhcnQsXG4gIGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0LFxuICBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQsXG4gIGRhdGFNZXNzYWdlU3RyZWFtUGFydCxcbiAgdG9vbENhbGxTdHJlYW1QYXJ0LFxuICBtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0LFxuXSBhcyBjb25zdDtcblxuLy8gdW5pb24gdHlwZSBvZiBhbGwgc3RyZWFtIHBhcnRzXG50eXBlIFN0cmVhbVBhcnRzID1cbiAgfCB0eXBlb2YgdGV4dFN0cmVhbVBhcnRcbiAgfCB0eXBlb2YgZnVuY3Rpb25DYWxsU3RyZWFtUGFydFxuICB8IHR5cGVvZiBkYXRhU3RyZWFtUGFydFxuICB8IHR5cGVvZiBlcnJvclN0cmVhbVBhcnRcbiAgfCB0eXBlb2YgYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnRcbiAgfCB0eXBlb2YgYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0XG4gIHwgdHlwZW9mIGRhdGFNZXNzYWdlU3RyZWFtUGFydFxuICB8IHR5cGVvZiB0b29sQ2FsbFN0cmVhbVBhcnRcbiAgfCB0eXBlb2YgbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydDtcbi8qKlxuICogTWFwcyB0aGUgdHlwZSBvZiBhIHN0cmVhbSBwYXJ0IHRvIGl0cyB2YWx1ZSB0eXBlLlxuICovXG50eXBlIFN0cmVhbVBhcnRWYWx1ZVR5cGUgPSB7XG4gIFtQIGluIFN0cmVhbVBhcnRzIGFzIFBbJ25hbWUnXV06IFJldHVyblR5cGU8UFsncGFyc2UnXT5bJ3ZhbHVlJ107XG59O1xuXG5leHBvcnQgdHlwZSBTdHJlYW1QYXJ0VHlwZSA9XG4gIHwgUmV0dXJuVHlwZTx0eXBlb2YgdGV4dFN0cmVhbVBhcnQucGFyc2U+XG4gIHwgUmV0dXJuVHlwZTx0eXBlb2YgZnVuY3Rpb25DYWxsU3RyZWFtUGFydC5wYXJzZT5cbiAgfCBSZXR1cm5UeXBlPHR5cGVvZiBkYXRhU3RyZWFtUGFydC5wYXJzZT5cbiAgfCBSZXR1cm5UeXBlPHR5cGVvZiBlcnJvclN0cmVhbVBhcnQucGFyc2U+XG4gIHwgUmV0dXJuVHlwZTx0eXBlb2YgYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQucGFyc2U+XG4gIHwgUmV0dXJuVHlwZTx0eXBlb2YgYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0LnBhcnNlPlxuICB8IFJldHVyblR5cGU8dHlwZW9mIGRhdGFNZXNzYWdlU3RyZWFtUGFydC5wYXJzZT5cbiAgfCBSZXR1cm5UeXBlPHR5cGVvZiB0b29sQ2FsbFN0cmVhbVBhcnQucGFyc2U+XG4gIHwgUmV0dXJuVHlwZTx0eXBlb2YgbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydC5wYXJzZT47XG5cbmV4cG9ydCBjb25zdCBzdHJlYW1QYXJ0c0J5Q29kZSA9IHtcbiAgW3RleHRTdHJlYW1QYXJ0LmNvZGVdOiB0ZXh0U3RyZWFtUGFydCxcbiAgW2Z1bmN0aW9uQ2FsbFN0cmVhbVBhcnQuY29kZV06IGZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQsXG4gIFtkYXRhU3RyZWFtUGFydC5jb2RlXTogZGF0YVN0cmVhbVBhcnQsXG4gIFtlcnJvclN0cmVhbVBhcnQuY29kZV06IGVycm9yU3RyZWFtUGFydCxcbiAgW2Fzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0LmNvZGVdOiBhc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydCxcbiAgW2Fzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydC5jb2RlXTogYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0LFxuICBbZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0LmNvZGVdOiBkYXRhTWVzc2FnZVN0cmVhbVBhcnQsXG4gIFt0b29sQ2FsbFN0cmVhbVBhcnQuY29kZV06IHRvb2xDYWxsU3RyZWFtUGFydCxcbiAgW21lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQuY29kZV06IG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQsXG59IGFzIGNvbnN0O1xuXG4vKipcbiAqIFRoZSBtYXAgb2YgcHJlZml4ZXMgZm9yIGRhdGEgaW4gdGhlIHN0cmVhbVxuICpcbiAqIC0gMDogVGV4dCBmcm9tIHRoZSBMTE0gcmVzcG9uc2VcbiAqIC0gMTogKE9wZW5BSSkgZnVuY3Rpb25fY2FsbCByZXNwb25zZXNcbiAqIC0gMjogY3VzdG9tIEpTT04gYWRkZWQgYnkgdGhlIHVzZXIgdXNpbmcgYERhdGFgXG4gKiAtIDY6IChPcGVuQUkpIHRvb2xfY2FsbCByZXNwb25zZXNcbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgXG4gKiAwOlZlcmNlbFxuICogMDonc1xuICogMDogQUlcbiAqIDA6IEFJXG4gKiAwOiBTREtcbiAqIDA6IGlzIGdyZWF0XG4gKiAwOiFcbiAqIDI6IHsgXCJzb21lSnNvblwiOiBcInZhbHVlXCIgfVxuICogMToge1wiZnVuY3Rpb25fY2FsbFwiOiB7XCJuYW1lXCI6IFwiZ2V0X2N1cnJlbnRfd2VhdGhlclwiLCBcImFyZ3VtZW50c1wiOiBcIntcXFxcblxcXFxcImxvY2F0aW9uXFxcXFwiOiBcXFxcXCJDaGFybG90dGVzdmlsbGUsIFZpcmdpbmlhXFxcXFwiLFxcXFxuXFxcXFwiZm9ybWF0XFxcXFwiOiBcXFxcXCJjZWxzaXVzXFxcXFwiXFxcXG59XCJ9fVxuICogNjoge1widG9vbF9jYWxsXCI6IHtcImlkXCI6IFwidG9vbF8wXCIsIFwidHlwZVwiOiBcImZ1bmN0aW9uXCIsIFwiZnVuY3Rpb25cIjoge1wibmFtZVwiOiBcImdldF9jdXJyZW50X3dlYXRoZXJcIiwgXCJhcmd1bWVudHNcIjogXCJ7XFxcXG5cXFxcXCJsb2NhdGlvblxcXFxcIjogXFxcXFwiQ2hhcmxvdHRlc3ZpbGxlLCBWaXJnaW5pYVxcXFxcIixcXFxcblxcXFxcImZvcm1hdFxcXFxcIjogXFxcXFwiY2Vsc2l1c1xcXFxcIlxcXFxufVwifX19XG4gKmBgYFxuICovXG5leHBvcnQgY29uc3QgU3RyZWFtU3RyaW5nUHJlZml4ZXMgPSB7XG4gIFt0ZXh0U3RyZWFtUGFydC5uYW1lXTogdGV4dFN0cmVhbVBhcnQuY29kZSxcbiAgW2Z1bmN0aW9uQ2FsbFN0cmVhbVBhcnQubmFtZV06IGZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQuY29kZSxcbiAgW2RhdGFTdHJlYW1QYXJ0Lm5hbWVdOiBkYXRhU3RyZWFtUGFydC5jb2RlLFxuICBbZXJyb3JTdHJlYW1QYXJ0Lm5hbWVdOiBlcnJvclN0cmVhbVBhcnQuY29kZSxcbiAgW2Fzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0Lm5hbWVdOiBhc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydC5jb2RlLFxuICBbYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0Lm5hbWVdOiBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQuY29kZSxcbiAgW2RhdGFNZXNzYWdlU3RyZWFtUGFydC5uYW1lXTogZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0LmNvZGUsXG4gIFt0b29sQ2FsbFN0cmVhbVBhcnQubmFtZV06IHRvb2xDYWxsU3RyZWFtUGFydC5jb2RlLFxuICBbbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydC5uYW1lXTogbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydC5jb2RlLFxufSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IHZhbGlkQ29kZXMgPSBzdHJlYW1QYXJ0cy5tYXAocGFydCA9PiBwYXJ0LmNvZGUpO1xuXG4vKipcblBhcnNlcyBhIHN0cmVhbSBwYXJ0IGZyb20gYSBzdHJpbmcuXG5cbkBwYXJhbSBsaW5lIFRoZSBzdHJpbmcgdG8gcGFyc2UuXG5AcmV0dXJucyBUaGUgcGFyc2VkIHN0cmVhbSBwYXJ0LlxuQHRocm93cyBBbiBlcnJvciBpZiB0aGUgc3RyaW5nIGNhbm5vdCBiZSBwYXJzZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBwYXJzZVN0cmVhbVBhcnQgPSAobGluZTogc3RyaW5nKTogU3RyZWFtUGFydFR5cGUgPT4ge1xuICBjb25zdCBmaXJzdFNlcGFyYXRvckluZGV4ID0gbGluZS5pbmRleE9mKCc6Jyk7XG5cbiAgaWYgKGZpcnN0U2VwYXJhdG9ySW5kZXggPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcGFyc2Ugc3RyZWFtIHN0cmluZy4gTm8gc2VwYXJhdG9yIGZvdW5kLicpO1xuICB9XG5cbiAgY29uc3QgcHJlZml4ID0gbGluZS5zbGljZSgwLCBmaXJzdFNlcGFyYXRvckluZGV4KTtcblxuICBpZiAoIXZhbGlkQ29kZXMuaW5jbHVkZXMocHJlZml4IGFzIGtleW9mIHR5cGVvZiBzdHJlYW1QYXJ0c0J5Q29kZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBzdHJlYW0gc3RyaW5nLiBJbnZhbGlkIGNvZGUgJHtwcmVmaXh9LmApO1xuICB9XG5cbiAgY29uc3QgY29kZSA9IHByZWZpeCBhcyBrZXlvZiB0eXBlb2Ygc3RyZWFtUGFydHNCeUNvZGU7XG5cbiAgY29uc3QgdGV4dFZhbHVlID0gbGluZS5zbGljZShmaXJzdFNlcGFyYXRvckluZGV4ICsgMSk7XG4gIGNvbnN0IGpzb25WYWx1ZTogSlNPTlZhbHVlID0gSlNPTi5wYXJzZSh0ZXh0VmFsdWUpO1xuXG4gIHJldHVybiBzdHJlYW1QYXJ0c0J5Q29kZVtjb2RlXS5wYXJzZShqc29uVmFsdWUpO1xufTtcblxuLyoqXG5QcmVwZW5kcyBhIHN0cmluZyB3aXRoIGEgcHJlZml4IGZyb20gdGhlIGBTdHJlYW1DaHVua1ByZWZpeGVzYCwgSlNPTi1pZmllcyBpdCxcbmFuZCBhcHBlbmRzIGEgbmV3IGxpbmUuXG5cbkl0IGVuc3VyZXMgdHlwZS1zYWZldHkgZm9yIHRoZSBwYXJ0IHR5cGUgYW5kIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0U3RyZWFtUGFydDxUIGV4dGVuZHMga2V5b2YgU3RyZWFtUGFydFZhbHVlVHlwZT4oXG4gIHR5cGU6IFQsXG4gIHZhbHVlOiBTdHJlYW1QYXJ0VmFsdWVUeXBlW1RdLFxuKTogU3RyZWFtU3RyaW5nIHtcbiAgY29uc3Qgc3RyZWFtUGFydCA9IHN0cmVhbVBhcnRzLmZpbmQocGFydCA9PiBwYXJ0Lm5hbWUgPT09IHR5cGUpO1xuXG4gIGlmICghc3RyZWFtUGFydCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzdHJlYW0gcGFydCB0eXBlOiAke3R5cGV9YCk7XG4gIH1cblxuICByZXR1cm4gYCR7c3RyZWFtUGFydC5jb2RlfToke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1cXG5gO1xufVxuIiwiaW1wb3J0IHsgU3RyZWFtUGFydFR5cGUsIHBhcnNlU3RyZWFtUGFydCB9IGZyb20gJy4vc3RyZWFtLXBhcnRzJztcblxuY29uc3QgTkVXTElORSA9ICdcXG4nLmNoYXJDb2RlQXQoMCk7XG5cbi8vIGNvbmNhdGVuYXRlcyBhbGwgdGhlIGNodW5rcyBpbnRvIGEgc2luZ2xlIFVpbnQ4QXJyYXlcbmZ1bmN0aW9uIGNvbmNhdENodW5rcyhjaHVua3M6IFVpbnQ4QXJyYXlbXSwgdG90YWxMZW5ndGg6IG51bWJlcikge1xuICBjb25zdCBjb25jYXRlbmF0ZWRDaHVua3MgPSBuZXcgVWludDhBcnJheSh0b3RhbExlbmd0aCk7XG5cbiAgbGV0IG9mZnNldCA9IDA7XG4gIGZvciAoY29uc3QgY2h1bmsgb2YgY2h1bmtzKSB7XG4gICAgY29uY2F0ZW5hdGVkQ2h1bmtzLnNldChjaHVuaywgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gY2h1bmsubGVuZ3RoO1xuICB9XG4gIGNodW5rcy5sZW5ndGggPSAwO1xuXG4gIHJldHVybiBjb25jYXRlbmF0ZWRDaHVua3M7XG59XG5cbi8qKlxuQ29udmVydHMgYSBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIgaW50byBhbiBhc3luYyBnZW5lcmF0b3IgdGhhdCB5aWVsZHNcblN0cmVhbVBhcnQgb2JqZWN0cy5cblxuQHBhcmFtIHJlYWRlciBcbiAgICAgICBSZWFkZXIgZm9yIHRoZSBzdHJlYW0gdG8gcmVhZCBmcm9tLlxuQHBhcmFtIGlzQWJvcnRlZFxuICAgICAgIE9wdGlvbmFsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIGlmIHRoZSByZXF1ZXN0IGhhcyBiZWVuIGFib3J0ZWQuXG4gICAgICAgSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSwgdGhlIGdlbmVyYXRvciB3aWxsIHN0b3AgcmVhZGluZyB0aGUgc3RyZWFtLlxuICAgICAgIElmIHRoZSBmdW5jdGlvbiBpcyBub3QgcHJvdmlkZWQsIHRoZSBnZW5lcmF0b3Igd2lsbCBub3Qgc3RvcCByZWFkaW5nIHRoZSBzdHJlYW0uXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiogcmVhZERhdGFTdHJlYW0oXG4gIHJlYWRlcjogUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFVpbnQ4QXJyYXk+LFxuICB7XG4gICAgaXNBYm9ydGVkLFxuICB9OiB7XG4gICAgaXNBYm9ydGVkPzogKCkgPT4gYm9vbGVhbjtcbiAgfSA9IHt9LFxuKTogQXN5bmNHZW5lcmF0b3I8U3RyZWFtUGFydFR5cGU+IHtcbiAgLy8gaW1wbGVtZW50YXRpb24gbm90ZTogdGhpcyBzbGlnaHRseSBtb3JlIGNvbXBsZXggYWxnb3JpdGhtIGlzIHJlcXVpcmVkXG4gIC8vIHRvIHBhc3MgdGhlIHRlc3RzIGluIHRoZSBlZGdlIGVudmlyb25tZW50LlxuXG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgY29uc3QgY2h1bmtzOiBVaW50OEFycmF5W10gPSBbXTtcbiAgbGV0IHRvdGFsTGVuZ3RoID0gMDtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHsgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG5cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGNodW5rcy5wdXNoKHZhbHVlKTtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IHZhbHVlLmxlbmd0aDtcbiAgICAgIGlmICh2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSAhPT0gTkVXTElORSkge1xuICAgICAgICAvLyBpZiB0aGUgbGFzdCBjaGFyYWN0ZXIgaXMgbm90IGEgbmV3bGluZSwgd2UgaGF2ZSBub3QgcmVhZCB0aGUgd2hvbGUgSlNPTiB2YWx1ZVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2h1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgYnJlYWs7IC8vIHdlIGhhdmUgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBzdHJlYW1cbiAgICB9XG5cbiAgICBjb25zdCBjb25jYXRlbmF0ZWRDaHVua3MgPSBjb25jYXRDaHVua3MoY2h1bmtzLCB0b3RhbExlbmd0aCk7XG4gICAgdG90YWxMZW5ndGggPSAwO1xuXG4gICAgY29uc3Qgc3RyZWFtUGFydHMgPSBkZWNvZGVyXG4gICAgICAuZGVjb2RlKGNvbmNhdGVuYXRlZENodW5rcywgeyBzdHJlYW06IHRydWUgfSlcbiAgICAgIC5zcGxpdCgnXFxuJylcbiAgICAgIC5maWx0ZXIobGluZSA9PiBsaW5lICE9PSAnJykgLy8gc3BsaXR0aW5nIGxlYXZlcyBhbiBlbXB0eSBzdHJpbmcgYXQgdGhlIGVuZFxuICAgICAgLm1hcChwYXJzZVN0cmVhbVBhcnQpO1xuXG4gICAgZm9yIChjb25zdCBzdHJlYW1QYXJ0IG9mIHN0cmVhbVBhcnRzKSB7XG4gICAgICB5aWVsZCBzdHJlYW1QYXJ0O1xuICAgIH1cblxuICAgIC8vIFRoZSByZXF1ZXN0IGhhcyBiZWVuIGFib3J0ZWQsIHN0b3AgcmVhZGluZyB0aGUgc3RyZWFtLlxuICAgIGlmIChpc0Fib3J0ZWQ/LigpKSB7XG4gICAgICByZWFkZXIuY2FuY2VsKCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IGN1c3RvbUFscGhhYmV0IH0gZnJvbSAnbmFub2lkL25vbi1zZWN1cmUnO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIDctY2hhcmFjdGVyIHJhbmRvbSBzdHJpbmcgdG8gdXNlIGZvciBJRHMuIE5vdCBzZWN1cmUuXG4gKi9cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZUlkID0gY3VzdG9tQWxwaGFiZXQoXG4gICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eicsXG4gIDcsXG4pO1xuIiwiaW1wb3J0IHsgcmVhZERhdGFTdHJlYW0gfSBmcm9tICcuL3JlYWQtZGF0YS1zdHJlYW0nO1xuaW1wb3J0IHR5cGUgeyBGdW5jdGlvbkNhbGwsIEpTT05WYWx1ZSwgTWVzc2FnZSwgVG9vbENhbGwgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IGdlbmVyYXRlSWQgYXMgZ2VuZXJhdGVJZEZ1bmN0aW9uIH0gZnJvbSAnLi9nZW5lcmF0ZS1pZCc7XG5cbnR5cGUgUHJlZml4TWFwID0ge1xuICB0ZXh0PzogTWVzc2FnZTtcbiAgZnVuY3Rpb25fY2FsbD86IE1lc3NhZ2UgJiB7XG4gICAgcm9sZTogJ2Fzc2lzdGFudCc7XG4gICAgZnVuY3Rpb25fY2FsbDogRnVuY3Rpb25DYWxsO1xuICB9O1xuICB0b29sX2NhbGxzPzogTWVzc2FnZSAmIHtcbiAgICByb2xlOiAnYXNzaXN0YW50JztcbiAgICB0b29sX2NhbGxzOiBUb29sQ2FsbFtdO1xuICB9O1xuICBkYXRhOiBKU09OVmFsdWVbXTtcbn07XG5cbmZ1bmN0aW9uIGFzc2lnbkFubm90YXRpb25zVG9NZXNzYWdlPFQgZXh0ZW5kcyBNZXNzYWdlIHwgbnVsbCB8IHVuZGVmaW5lZD4oXG4gIG1lc3NhZ2U6IFQsXG4gIGFubm90YXRpb25zOiBKU09OVmFsdWVbXSB8IHVuZGVmaW5lZCxcbik6IFQge1xuICBpZiAoIW1lc3NhZ2UgfHwgIWFubm90YXRpb25zIHx8ICFhbm5vdGF0aW9ucy5sZW5ndGgpIHJldHVybiBtZXNzYWdlO1xuICByZXR1cm4geyAuLi5tZXNzYWdlLCBhbm5vdGF0aW9uczogWy4uLmFubm90YXRpb25zXSB9IGFzIFQ7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwYXJzZUNvbXBsZXhSZXNwb25zZSh7XG4gIHJlYWRlcixcbiAgYWJvcnRDb250cm9sbGVyUmVmLFxuICB1cGRhdGUsXG4gIG9uRmluaXNoLFxuICBnZW5lcmF0ZUlkID0gZ2VuZXJhdGVJZEZ1bmN0aW9uLFxuICBnZXRDdXJyZW50RGF0ZSA9ICgpID0+IG5ldyBEYXRlKCksXG59OiB7XG4gIHJlYWRlcjogUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyPFVpbnQ4QXJyYXk+O1xuICBhYm9ydENvbnRyb2xsZXJSZWY/OiB7XG4gICAgY3VycmVudDogQWJvcnRDb250cm9sbGVyIHwgbnVsbDtcbiAgfTtcbiAgdXBkYXRlOiAobWVyZ2VkOiBNZXNzYWdlW10sIGRhdGE6IEpTT05WYWx1ZVtdIHwgdW5kZWZpbmVkKSA9PiB2b2lkO1xuICBvbkZpbmlzaD86IChwcmVmaXhNYXA6IFByZWZpeE1hcCkgPT4gdm9pZDtcbiAgZ2VuZXJhdGVJZD86ICgpID0+IHN0cmluZztcbiAgZ2V0Q3VycmVudERhdGU/OiAoKSA9PiBEYXRlO1xufSkge1xuICBjb25zdCBjcmVhdGVkQXQgPSBnZXRDdXJyZW50RGF0ZSgpO1xuICBjb25zdCBwcmVmaXhNYXA6IFByZWZpeE1hcCA9IHtcbiAgICBkYXRhOiBbXSxcbiAgfTtcblxuICAvLyBrZWVwIGxpc3Qgb2YgY3VycmVudCBtZXNzYWdlIGFubm90YXRpb25zIGZvciBtZXNzYWdlXG4gIGxldCBtZXNzYWdlX2Fubm90YXRpb25zOiBKU09OVmFsdWVbXSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcblxuICAvLyB3ZSBjcmVhdGUgYSBtYXAgb2YgZWFjaCBwcmVmaXgsIGFuZCBmb3IgZWFjaCBwcmVmaXhlZCBtZXNzYWdlIHdlIHB1c2ggdG8gdGhlIG1hcFxuICBmb3IgYXdhaXQgKGNvbnN0IHsgdHlwZSwgdmFsdWUgfSBvZiByZWFkRGF0YVN0cmVhbShyZWFkZXIsIHtcbiAgICBpc0Fib3J0ZWQ6ICgpID0+IGFib3J0Q29udHJvbGxlclJlZj8uY3VycmVudCA9PT0gbnVsbCxcbiAgfSkpIHtcbiAgICBpZiAodHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICBpZiAocHJlZml4TWFwWyd0ZXh0J10pIHtcbiAgICAgICAgcHJlZml4TWFwWyd0ZXh0J10gPSB7XG4gICAgICAgICAgLi4ucHJlZml4TWFwWyd0ZXh0J10sXG4gICAgICAgICAgY29udGVudDogKHByZWZpeE1hcFsndGV4dCddLmNvbnRlbnQgfHwgJycpICsgdmFsdWUsXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmVmaXhNYXBbJ3RleHQnXSA9IHtcbiAgICAgICAgICBpZDogZ2VuZXJhdGVJZCgpLFxuICAgICAgICAgIHJvbGU6ICdhc3Npc3RhbnQnLFxuICAgICAgICAgIGNvbnRlbnQ6IHZhbHVlLFxuICAgICAgICAgIGNyZWF0ZWRBdCxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgZnVuY3Rpb25DYWxsTWVzc2FnZTogTWVzc2FnZSB8IG51bGwgfCB1bmRlZmluZWQgPSBudWxsO1xuXG4gICAgaWYgKHR5cGUgPT09ICdmdW5jdGlvbl9jYWxsJykge1xuICAgICAgcHJlZml4TWFwWydmdW5jdGlvbl9jYWxsJ10gPSB7XG4gICAgICAgIGlkOiBnZW5lcmF0ZUlkKCksXG4gICAgICAgIHJvbGU6ICdhc3Npc3RhbnQnLFxuICAgICAgICBjb250ZW50OiAnJyxcbiAgICAgICAgZnVuY3Rpb25fY2FsbDogdmFsdWUuZnVuY3Rpb25fY2FsbCxcbiAgICAgICAgbmFtZTogdmFsdWUuZnVuY3Rpb25fY2FsbC5uYW1lLFxuICAgICAgICBjcmVhdGVkQXQsXG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbkNhbGxNZXNzYWdlID0gcHJlZml4TWFwWydmdW5jdGlvbl9jYWxsJ107XG4gICAgfVxuXG4gICAgbGV0IHRvb2xDYWxsTWVzc2FnZTogTWVzc2FnZSB8IG51bGwgfCB1bmRlZmluZWQgPSBudWxsO1xuXG4gICAgaWYgKHR5cGUgPT09ICd0b29sX2NhbGxzJykge1xuICAgICAgcHJlZml4TWFwWyd0b29sX2NhbGxzJ10gPSB7XG4gICAgICAgIGlkOiBnZW5lcmF0ZUlkKCksXG4gICAgICAgIHJvbGU6ICdhc3Npc3RhbnQnLFxuICAgICAgICBjb250ZW50OiAnJyxcbiAgICAgICAgdG9vbF9jYWxsczogdmFsdWUudG9vbF9jYWxscyxcbiAgICAgICAgY3JlYXRlZEF0LFxuICAgICAgfTtcblxuICAgICAgdG9vbENhbGxNZXNzYWdlID0gcHJlZml4TWFwWyd0b29sX2NhbGxzJ107XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdkYXRhJykge1xuICAgICAgcHJlZml4TWFwWydkYXRhJ10ucHVzaCguLi52YWx1ZSk7XG4gICAgfVxuXG4gICAgbGV0IHJlc3BvbnNlTWVzc2FnZSA9IHByZWZpeE1hcFsndGV4dCddO1xuXG4gICAgaWYgKHR5cGUgPT09ICdtZXNzYWdlX2Fubm90YXRpb25zJykge1xuICAgICAgaWYgKCFtZXNzYWdlX2Fubm90YXRpb25zKSB7XG4gICAgICAgIG1lc3NhZ2VfYW5ub3RhdGlvbnMgPSBbLi4udmFsdWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVzc2FnZV9hbm5vdGF0aW9ucy5wdXNoKC4uLnZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIGFueSBleGlzdGluZyBtZXNzYWdlIHdpdGggdGhlIGxhdGVzdCBhbm5vdGF0aW9uc1xuICAgICAgZnVuY3Rpb25DYWxsTWVzc2FnZSA9IGFzc2lnbkFubm90YXRpb25zVG9NZXNzYWdlKFxuICAgICAgICBwcmVmaXhNYXBbJ2Z1bmN0aW9uX2NhbGwnXSxcbiAgICAgICAgbWVzc2FnZV9hbm5vdGF0aW9ucyxcbiAgICAgICk7XG4gICAgICB0b29sQ2FsbE1lc3NhZ2UgPSBhc3NpZ25Bbm5vdGF0aW9uc1RvTWVzc2FnZShcbiAgICAgICAgcHJlZml4TWFwWyd0b29sX2NhbGxzJ10sXG4gICAgICAgIG1lc3NhZ2VfYW5ub3RhdGlvbnMsXG4gICAgICApO1xuICAgICAgcmVzcG9uc2VNZXNzYWdlID0gYXNzaWduQW5ub3RhdGlvbnNUb01lc3NhZ2UoXG4gICAgICAgIHByZWZpeE1hcFsndGV4dCddLFxuICAgICAgICBtZXNzYWdlX2Fubm90YXRpb25zLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBrZWVwcyB0aGUgcHJlZml4TWFwIHVwIHRvIGRhdGUgd2l0aCB0aGUgbGF0ZXN0IGFubm90YXRpb25zLCBldmVuIGlmIGFubm90YXRpb25zIHByZWNlZGVkIHRoZSBtZXNzYWdlXG4gICAgaWYgKG1lc3NhZ2VfYW5ub3RhdGlvbnM/Lmxlbmd0aCkge1xuICAgICAgY29uc3QgbWVzc2FnZVByZWZpeEtleXM6IChrZXlvZiBQcmVmaXhNYXApW10gPSBbXG4gICAgICAgICd0ZXh0JyxcbiAgICAgICAgJ2Z1bmN0aW9uX2NhbGwnLFxuICAgICAgICAndG9vbF9jYWxscycsXG4gICAgICBdO1xuICAgICAgbWVzc2FnZVByZWZpeEtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBpZiAocHJlZml4TWFwW2tleV0pIHtcbiAgICAgICAgICAocHJlZml4TWFwW2tleV0gYXMgTWVzc2FnZSkuYW5ub3RhdGlvbnMgPSBbLi4ubWVzc2FnZV9hbm5vdGF0aW9ucyFdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBXZSBhZGQgZnVuY3Rpb24gJiB0b29sIGNhbGxzIGFuZCByZXNwb25zZSBtZXNzYWdlcyB0byB0aGUgbWVzc2FnZXNbXSwgYnV0IGRhdGEgaXMgaXRzIG93biB0aGluZ1xuICAgIGNvbnN0IG1lcmdlZCA9IFtmdW5jdGlvbkNhbGxNZXNzYWdlLCB0b29sQ2FsbE1lc3NhZ2UsIHJlc3BvbnNlTWVzc2FnZV1cbiAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgIC5tYXAobWVzc2FnZSA9PiAoe1xuICAgICAgICAuLi5hc3NpZ25Bbm5vdGF0aW9uc1RvTWVzc2FnZShtZXNzYWdlLCBtZXNzYWdlX2Fubm90YXRpb25zKSxcbiAgICAgIH0pKSBhcyBNZXNzYWdlW107XG5cbiAgICB1cGRhdGUobWVyZ2VkLCBbLi4ucHJlZml4TWFwWydkYXRhJ11dKTsgLy8gbWFrZSBhIGNvcHkgb2YgdGhlIGRhdGEgYXJyYXlcbiAgfVxuXG4gIG9uRmluaXNoPy4ocHJlZml4TWFwKTtcblxuICByZXR1cm4ge1xuICAgIG1lc3NhZ2VzOiBbXG4gICAgICBwcmVmaXhNYXAudGV4dCxcbiAgICAgIHByZWZpeE1hcC5mdW5jdGlvbl9jYWxsLFxuICAgICAgcHJlZml4TWFwLnRvb2xfY2FsbHMsXG4gICAgXS5maWx0ZXIoQm9vbGVhbikgYXMgTWVzc2FnZVtdLFxuICAgIGRhdGE6IHByZWZpeE1hcC5kYXRhLFxuICB9O1xufVxuIiwiaW1wb3J0IHtcbiAgU3RyZWFtUGFydFR5cGUsXG4gIFN0cmVhbVN0cmluZ1ByZWZpeGVzLFxuICBwYXJzZVN0cmVhbVBhcnQsXG59IGZyb20gJy4vc3RyZWFtLXBhcnRzJztcblxuZXhwb3J0ICogZnJvbSAnLi9nZW5lcmF0ZS1pZCc7XG5cbi8vIFRPRE8gcmVtb3ZlIChicmVha2luZyBjaGFuZ2UpXG5leHBvcnQgeyBnZW5lcmF0ZUlkIGFzIG5hbm9pZCB9IGZyb20gJy4vZ2VuZXJhdGUtaWQnO1xuXG4vLyBFeHBvcnQgc3RyZWFtIGRhdGEgdXRpbGl0aWVzIGZvciBjdXN0b20gc3RyZWFtIGltcGxlbWVudGF0aW9ucyxcbi8vIGJvdGggb24gdGhlIGNsaWVudCBhbmQgc2VydmVyIHNpZGUuXG5leHBvcnQgdHlwZSB7IFN0cmVhbVBhcnQgfSBmcm9tICcuL3N0cmVhbS1wYXJ0cyc7XG5leHBvcnQgeyBmb3JtYXRTdHJlYW1QYXJ0LCBwYXJzZVN0cmVhbVBhcnQgfSBmcm9tICcuL3N0cmVhbS1wYXJ0cyc7XG5leHBvcnQgeyByZWFkRGF0YVN0cmVhbSB9IGZyb20gJy4vcmVhZC1kYXRhLXN0cmVhbSc7XG5cbi8vIHNpbXBsZSBkZWNvZGVyIHNpZ25hdHVyZXM6XG5mdW5jdGlvbiBjcmVhdGVDaHVua0RlY29kZXIoKTogKGNodW5rOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkKSA9PiBzdHJpbmc7XG5mdW5jdGlvbiBjcmVhdGVDaHVua0RlY29kZXIoXG4gIGNvbXBsZXg6IGZhbHNlLFxuKTogKGNodW5rOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkKSA9PiBzdHJpbmc7XG4vLyBjb21wbGV4IGRlY29kZXIgc2lnbmF0dXJlOlxuZnVuY3Rpb24gY3JlYXRlQ2h1bmtEZWNvZGVyKFxuICBjb21wbGV4OiB0cnVlLFxuKTogKGNodW5rOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkKSA9PiBTdHJlYW1QYXJ0VHlwZVtdO1xuLy8gY29tYmluZWQgc2lnbmF0dXJlIGZvciB3aGVuIHRoZSBjbGllbnQgY2FsbHMgdGhpcyBmdW5jdGlvbiB3aXRoIGEgYm9vbGVhbjpcbmZ1bmN0aW9uIGNyZWF0ZUNodW5rRGVjb2RlcihcbiAgY29tcGxleD86IGJvb2xlYW4sXG4pOiAoY2h1bms6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQpID0+IFN0cmVhbVBhcnRUeXBlW10gfCBzdHJpbmc7XG5mdW5jdGlvbiBjcmVhdGVDaHVua0RlY29kZXIoY29tcGxleD86IGJvb2xlYW4pIHtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuXG4gIGlmICghY29tcGxleCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoY2h1bms6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQpOiBzdHJpbmcge1xuICAgICAgaWYgKCFjaHVuaykgcmV0dXJuICcnO1xuICAgICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlKGNodW5rLCB7IHN0cmVhbTogdHJ1ZSB9KTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChjaHVuazogVWludDhBcnJheSB8IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IGRlY29kZWQgPSBkZWNvZGVyXG4gICAgICAuZGVjb2RlKGNodW5rLCB7IHN0cmVhbTogdHJ1ZSB9KVxuICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgLmZpbHRlcihsaW5lID0+IGxpbmUgIT09ICcnKTsgLy8gc3BsaXR0aW5nIGxlYXZlcyBhbiBlbXB0eSBzdHJpbmcgYXQgdGhlIGVuZFxuXG4gICAgcmV0dXJuIGRlY29kZWQubWFwKHBhcnNlU3RyZWFtUGFydCkuZmlsdGVyKEJvb2xlYW4pO1xuICB9O1xufVxuXG5leHBvcnQgeyBjcmVhdGVDaHVua0RlY29kZXIgfTtcblxuZXhwb3J0IGNvbnN0IGlzU3RyZWFtU3RyaW5nRXF1YWxUb1R5cGUgPSAoXG4gIHR5cGU6IGtleW9mIHR5cGVvZiBTdHJlYW1TdHJpbmdQcmVmaXhlcyxcbiAgdmFsdWU6IHN0cmluZyxcbik6IHZhbHVlIGlzIFN0cmVhbVN0cmluZyA9PlxuICB2YWx1ZS5zdGFydHNXaXRoKGAke1N0cmVhbVN0cmluZ1ByZWZpeGVzW3R5cGVdfTpgKSAmJiB2YWx1ZS5lbmRzV2l0aCgnXFxuJyk7XG5cbmV4cG9ydCB0eXBlIFN0cmVhbVN0cmluZyA9XG4gIGAkeyh0eXBlb2YgU3RyZWFtU3RyaW5nUHJlZml4ZXMpW2tleW9mIHR5cGVvZiBTdHJlYW1TdHJpbmdQcmVmaXhlc119OiR7c3RyaW5nfVxcbmA7XG4iLCJpbXBvcnQgeyBwYXJzZUNvbXBsZXhSZXNwb25zZSB9IGZyb20gJy4vcGFyc2UtY29tcGxleC1yZXNwb25zZSc7XG5pbXBvcnQgeyBJZEdlbmVyYXRvciwgSlNPTlZhbHVlLCBNZXNzYWdlIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBjcmVhdGVDaHVua0RlY29kZXIgfSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNhbGxDaGF0QXBpKHtcbiAgYXBpLFxuICBtZXNzYWdlcyxcbiAgYm9keSxcbiAgc3RyZWFtTW9kZSA9ICdzdHJlYW0tZGF0YScsXG4gIGNyZWRlbnRpYWxzLFxuICBoZWFkZXJzLFxuICBhYm9ydENvbnRyb2xsZXIsXG4gIHJlc3RvcmVNZXNzYWdlc09uRmFpbHVyZSxcbiAgb25SZXNwb25zZSxcbiAgb25VcGRhdGUsXG4gIG9uRmluaXNoLFxuICBnZW5lcmF0ZUlkLFxufToge1xuICBhcGk6IHN0cmluZztcbiAgbWVzc2FnZXM6IE9taXQ8TWVzc2FnZSwgJ2lkJz5bXTtcbiAgYm9keTogUmVjb3JkPHN0cmluZywgYW55PjtcbiAgc3RyZWFtTW9kZT86ICdzdHJlYW0tZGF0YScgfCAndGV4dCc7XG4gIGNyZWRlbnRpYWxzPzogUmVxdWVzdENyZWRlbnRpYWxzO1xuICBoZWFkZXJzPzogSGVhZGVyc0luaXQ7XG4gIGFib3J0Q29udHJvbGxlcj86ICgpID0+IEFib3J0Q29udHJvbGxlciB8IG51bGw7XG4gIHJlc3RvcmVNZXNzYWdlc09uRmFpbHVyZTogKCkgPT4gdm9pZDtcbiAgb25SZXNwb25zZT86IChyZXNwb25zZTogUmVzcG9uc2UpID0+IHZvaWQgfCBQcm9taXNlPHZvaWQ+O1xuICBvblVwZGF0ZTogKG1lcmdlZDogTWVzc2FnZVtdLCBkYXRhOiBKU09OVmFsdWVbXSB8IHVuZGVmaW5lZCkgPT4gdm9pZDtcbiAgb25GaW5pc2g/OiAobWVzc2FnZTogTWVzc2FnZSkgPT4gdm9pZDtcbiAgZ2VuZXJhdGVJZDogSWRHZW5lcmF0b3I7XG59KSB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYXBpLCB7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgbWVzc2FnZXMsXG4gICAgICAuLi5ib2R5LFxuICAgIH0pLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAuLi5oZWFkZXJzLFxuICAgIH0sXG4gICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXI/LigpPy5zaWduYWwsXG4gICAgY3JlZGVudGlhbHMsXG4gIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgcmVzdG9yZU1lc3NhZ2VzT25GYWlsdXJlKCk7XG4gICAgdGhyb3cgZXJyO1xuICB9KTtcblxuICBpZiAob25SZXNwb25zZSkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBvblJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cblxuICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgcmVzdG9yZU1lc3NhZ2VzT25GYWlsdXJlKCk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgKGF3YWl0IHJlc3BvbnNlLnRleHQoKSkgfHwgJ0ZhaWxlZCB0byBmZXRjaCB0aGUgY2hhdCByZXNwb25zZS4nLFxuICAgICk7XG4gIH1cblxuICBpZiAoIXJlc3BvbnNlLmJvZHkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSByZXNwb25zZSBib2R5IGlzIGVtcHR5LicpO1xuICB9XG5cbiAgY29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcblxuICBzd2l0Y2ggKHN0cmVhbU1vZGUpIHtcbiAgICBjYXNlICd0ZXh0Jzoge1xuICAgICAgY29uc3QgZGVjb2RlciA9IGNyZWF0ZUNodW5rRGVjb2RlcigpO1xuXG4gICAgICBjb25zdCByZXN1bHRNZXNzYWdlID0ge1xuICAgICAgICBpZDogZ2VuZXJhdGVJZCgpLFxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICAgIHJvbGU6ICdhc3Npc3RhbnQnIGFzIGNvbnN0LFxuICAgICAgICBjb250ZW50OiAnJyxcbiAgICAgIH07XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHRNZXNzYWdlLmNvbnRlbnQgKz0gZGVjb2Rlcih2YWx1ZSk7XG4gICAgICAgIHJlc3VsdE1lc3NhZ2UuaWQgPSBnZW5lcmF0ZUlkKCk7XG5cbiAgICAgICAgLy8gbm90ZTogY3JlYXRpbmcgYSBuZXcgbWVzc2FnZSBvYmplY3QgaXMgcmVxdWlyZWQgZm9yIFNvbGlkLmpzIHN0cmVhbWluZ1xuICAgICAgICBvblVwZGF0ZShbeyAuLi5yZXN1bHRNZXNzYWdlIH1dLCBbXSk7XG5cbiAgICAgICAgLy8gVGhlIHJlcXVlc3QgaGFzIGJlZW4gYWJvcnRlZCwgc3RvcCByZWFkaW5nIHRoZSBzdHJlYW0uXG4gICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXI/LigpID09PSBudWxsKSB7XG4gICAgICAgICAgcmVhZGVyLmNhbmNlbCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG9uRmluaXNoPy4ocmVzdWx0TWVzc2FnZSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1lc3NhZ2VzOiBbcmVzdWx0TWVzc2FnZV0sXG4gICAgICAgIGRhdGE6IFtdLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjYXNlICdzdHJlYW0tZGF0YSc6IHtcbiAgICAgIHJldHVybiBhd2FpdCBwYXJzZUNvbXBsZXhSZXNwb25zZSh7XG4gICAgICAgIHJlYWRlcixcbiAgICAgICAgYWJvcnRDb250cm9sbGVyUmVmOlxuICAgICAgICAgIGFib3J0Q29udHJvbGxlciAhPSBudWxsID8geyBjdXJyZW50OiBhYm9ydENvbnRyb2xsZXIoKSB9IDogdW5kZWZpbmVkLFxuICAgICAgICB1cGRhdGU6IG9uVXBkYXRlLFxuICAgICAgICBvbkZpbmlzaChwcmVmaXhNYXApIHtcbiAgICAgICAgICBpZiAob25GaW5pc2ggJiYgcHJlZml4TWFwLnRleHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgb25GaW5pc2gocHJlZml4TWFwLnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2VuZXJhdGVJZCxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGNvbnN0IGV4aGF1c3RpdmVDaGVjazogbmV2ZXIgPSBzdHJlYW1Nb2RlO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHN0cmVhbSBtb2RlOiAke2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIENoYXRSZXF1ZXN0LFxuICBGdW5jdGlvbkNhbGwsXG4gIEpTT05WYWx1ZSxcbiAgTWVzc2FnZSxcbiAgVG9vbENhbGwsXG59IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0NoYXRTdHJlYW0oe1xuICBnZXRTdHJlYW1lZFJlc3BvbnNlLFxuICBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwsXG4gIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsLFxuICB1cGRhdGVDaGF0UmVxdWVzdCxcbiAgZ2V0Q3VycmVudE1lc3NhZ2VzLFxufToge1xuICBnZXRTdHJlYW1lZFJlc3BvbnNlOiAoKSA9PiBQcm9taXNlPFxuICAgIE1lc3NhZ2UgfCB7IG1lc3NhZ2VzOiBNZXNzYWdlW107IGRhdGE6IEpTT05WYWx1ZVtdIH1cbiAgPjtcbiAgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsPzogKFxuICAgIGNoYXRNZXNzYWdlczogTWVzc2FnZVtdLFxuICAgIGZ1bmN0aW9uQ2FsbDogRnVuY3Rpb25DYWxsLFxuICApID0+IFByb21pc2U8dm9pZCB8IENoYXRSZXF1ZXN0PjtcbiAgZXhwZXJpbWVudGFsX29uVG9vbENhbGw/OiAoXG4gICAgY2hhdE1lc3NhZ2VzOiBNZXNzYWdlW10sXG4gICAgdG9vbENhbGxzOiBUb29sQ2FsbFtdLFxuICApID0+IFByb21pc2U8dm9pZCB8IENoYXRSZXF1ZXN0PjtcbiAgdXBkYXRlQ2hhdFJlcXVlc3Q6IChjaGF0UmVxdWVzdDogQ2hhdFJlcXVlc3QpID0+IHZvaWQ7XG4gIGdldEN1cnJlbnRNZXNzYWdlczogKCkgPT4gTWVzc2FnZVtdO1xufSkge1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIFRPRE8tU1RSRUFNREFUQTogVGhpcyBzaG91bGQgYmUgeyAgY29uc3QgeyBtZXNzYWdlczogc3RyZWFtZWRSZXNwb25zZU1lc3NhZ2VzLCBkYXRhIH0gPVxuICAgIC8vIGF3YWl0IGdldFN0cmVhbWVkUmVzcG9uc2UofSBvbmNlIFN0cmVhbSBEYXRhIGlzIG5vdCBleHBlcmltZW50YWxcbiAgICBjb25zdCBtZXNzYWdlc0FuZERhdGFPckp1c3RNZXNzYWdlID0gYXdhaXQgZ2V0U3RyZWFtZWRSZXNwb25zZSgpO1xuXG4gICAgLy8gVXNpbmcgZXhwZXJpbWVudGFsIHN0cmVhbSBkYXRhXG4gICAgaWYgKCdtZXNzYWdlcycgaW4gbWVzc2FnZXNBbmREYXRhT3JKdXN0TWVzc2FnZSkge1xuICAgICAgbGV0IGhhc0ZvbGxvd2luZ1Jlc3BvbnNlID0gZmFsc2U7XG5cbiAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlc0FuZERhdGFPckp1c3RNZXNzYWdlLm1lc3NhZ2VzKSB7XG4gICAgICAgIC8vIFNlZSBpZiB0aGUgbWVzc2FnZSBoYXMgYSBjb21wbGV0ZSBmdW5jdGlvbiBjYWxsIG9yIHRvb2wgY2FsbFxuICAgICAgICBpZiAoXG4gICAgICAgICAgKG1lc3NhZ2UuZnVuY3Rpb25fY2FsbCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICB0eXBlb2YgbWVzc2FnZS5mdW5jdGlvbl9jYWxsID09PSAnc3RyaW5nJykgJiZcbiAgICAgICAgICAobWVzc2FnZS50b29sX2NhbGxzID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIHR5cGVvZiBtZXNzYWdlLnRvb2xfY2FsbHMgPT09ICdzdHJpbmcnKVxuICAgICAgICApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhc0ZvbGxvd2luZ1Jlc3BvbnNlID0gdHJ1ZTtcbiAgICAgICAgLy8gVHJ5IHRvIGhhbmRsZSBmdW5jdGlvbiBjYWxsXG4gICAgICAgIGlmIChleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwpIHtcbiAgICAgICAgICBjb25zdCBmdW5jdGlvbkNhbGwgPSBtZXNzYWdlLmZ1bmN0aW9uX2NhbGw7XG4gICAgICAgICAgLy8gTWFrZSBzdXJlIGZ1bmN0aW9uQ2FsbCBpcyBhbiBvYmplY3RcbiAgICAgICAgICAvLyBJZiBub3QsIHdlIGdvdCB0b29sIGNhbGxzIGluc3RlYWQgb2YgZnVuY3Rpb24gY2FsbHNcbiAgICAgICAgICBpZiAodHlwZW9mIGZ1bmN0aW9uQ2FsbCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgJ2V4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCBzaG91bGQgbm90IGJlIGRlZmluZWQgd2hlbiB1c2luZyB0b29scycsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVXNlciBoYW5kbGVzIHRoZSBmdW5jdGlvbiBjYWxsIGluIHRoZWlyIG93biBmdW5jdGlvbkNhbGxIYW5kbGVyLlxuICAgICAgICAgIC8vIFRoZSBcImFyZ3VtZW50c1wiIGtleSBvZiB0aGUgZnVuY3Rpb24gY2FsbCBvYmplY3Qgd2lsbCBzdGlsbCBiZSBhIHN0cmluZyB3aGljaCB3aWxsIGhhdmUgdG8gYmUgcGFyc2VkIGluIHRoZSBmdW5jdGlvbiBoYW5kbGVyLlxuICAgICAgICAgIC8vIElmIHRoZSBcImFyZ3VtZW50c1wiIEpTT04gaXMgbWFsZm9ybWVkIGR1ZSB0byBtb2RlbCBlcnJvciB0aGUgdXNlciB3aWxsIGhhdmUgdG8gaGFuZGxlIHRoYXQgdGhlbXNlbHZlcy5cblxuICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbFJlc3BvbnNlOiBDaGF0UmVxdWVzdCB8IHZvaWQgPVxuICAgICAgICAgICAgYXdhaXQgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKFxuICAgICAgICAgICAgICBnZXRDdXJyZW50TWVzc2FnZXMoKSxcbiAgICAgICAgICAgICAgZnVuY3Rpb25DYWxsLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIElmIHRoZSB1c2VyIGRvZXMgbm90IHJldHVybiBhbnl0aGluZyBhcyBhIHJlc3VsdCBvZiB0aGUgZnVuY3Rpb24gY2FsbCwgdGhlIGxvb3Agd2lsbCBicmVhay5cbiAgICAgICAgICBpZiAoZnVuY3Rpb25DYWxsUmVzcG9uc2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaGFzRm9sbG93aW5nUmVzcG9uc2UgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEEgZnVuY3Rpb24gY2FsbCByZXNwb25zZSB3YXMgcmV0dXJuZWQuXG4gICAgICAgICAgLy8gVGhlIHVwZGF0ZWQgY2hhdCB3aXRoIGZ1bmN0aW9uIGNhbGwgcmVzcG9uc2Ugd2lsbCBiZSBzZW50IHRvIHRoZSBBUEkgaW4gdGhlIG5leHQgaXRlcmF0aW9uIG9mIHRoZSBsb29wLlxuICAgICAgICAgIHVwZGF0ZUNoYXRSZXF1ZXN0KGZ1bmN0aW9uQ2FsbFJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcnkgdG8gaGFuZGxlIHRvb2wgY2FsbFxuICAgICAgICBpZiAoZXhwZXJpbWVudGFsX29uVG9vbENhbGwpIHtcbiAgICAgICAgICBjb25zdCB0b29sQ2FsbHMgPSBtZXNzYWdlLnRvb2xfY2FsbHM7XG4gICAgICAgICAgLy8gTWFrZSBzdXJlIHRvb2xDYWxscyBpcyBhbiBhcnJheSBvZiBvYmplY3RzXG4gICAgICAgICAgLy8gSWYgbm90LCB3ZSBnb3QgZnVuY3Rpb24gY2FsbHMgaW5zdGVhZCBvZiB0b29sIGNhbGxzXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkodG9vbENhbGxzKSB8fFxuICAgICAgICAgICAgdG9vbENhbGxzLnNvbWUodG9vbENhbGwgPT4gdHlwZW9mIHRvb2xDYWxsICE9PSAnb2JqZWN0JylcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgJ2V4cGVyaW1lbnRhbF9vblRvb2xDYWxsIHNob3VsZCBub3QgYmUgZGVmaW5lZCB3aGVuIHVzaW5nIHRvb2xzJyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBVc2VyIGhhbmRsZXMgdGhlIGZ1bmN0aW9uIGNhbGwgaW4gdGhlaXIgb3duIGZ1bmN0aW9uQ2FsbEhhbmRsZXIuXG4gICAgICAgICAgLy8gVGhlIFwiYXJndW1lbnRzXCIga2V5IG9mIHRoZSBmdW5jdGlvbiBjYWxsIG9iamVjdCB3aWxsIHN0aWxsIGJlIGEgc3RyaW5nIHdoaWNoIHdpbGwgaGF2ZSB0byBiZSBwYXJzZWQgaW4gdGhlIGZ1bmN0aW9uIGhhbmRsZXIuXG4gICAgICAgICAgLy8gSWYgdGhlIFwiYXJndW1lbnRzXCIgSlNPTiBpcyBtYWxmb3JtZWQgZHVlIHRvIG1vZGVsIGVycm9yIHRoZSB1c2VyIHdpbGwgaGF2ZSB0byBoYW5kbGUgdGhhdCB0aGVtc2VsdmVzLlxuICAgICAgICAgIGNvbnN0IHRvb2xDYWxsUmVzcG9uc2U6IENoYXRSZXF1ZXN0IHwgdm9pZCA9XG4gICAgICAgICAgICBhd2FpdCBleHBlcmltZW50YWxfb25Ub29sQ2FsbChnZXRDdXJyZW50TWVzc2FnZXMoKSwgdG9vbENhbGxzKTtcblxuICAgICAgICAgIC8vIElmIHRoZSB1c2VyIGRvZXMgbm90IHJldHVybiBhbnl0aGluZyBhcyBhIHJlc3VsdCBvZiB0aGUgZnVuY3Rpb24gY2FsbCwgdGhlIGxvb3Agd2lsbCBicmVhay5cbiAgICAgICAgICBpZiAodG9vbENhbGxSZXNwb25zZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBoYXNGb2xsb3dpbmdSZXNwb25zZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQSBmdW5jdGlvbiBjYWxsIHJlc3BvbnNlIHdhcyByZXR1cm5lZC5cbiAgICAgICAgICAvLyBUaGUgdXBkYXRlZCBjaGF0IHdpdGggZnVuY3Rpb24gY2FsbCByZXNwb25zZSB3aWxsIGJlIHNlbnQgdG8gdGhlIEFQSSBpbiB0aGUgbmV4dCBpdGVyYXRpb24gb2YgdGhlIGxvb3AuXG4gICAgICAgICAgdXBkYXRlQ2hhdFJlcXVlc3QodG9vbENhbGxSZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghaGFzRm9sbG93aW5nUmVzcG9uc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlID0gbWVzc2FnZXNBbmREYXRhT3JKdXN0TWVzc2FnZTtcblxuICAgICAgLy8gVE9ETy1TVFJFQU1EQVRBOiBSZW1vdmUgdGhpcyBvbmNlIFN0cmVhbSBEYXRhIGlzIG5vdCBleHBlcmltZW50YWxcbiAgICAgIGlmIChcbiAgICAgICAgKHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlLmZ1bmN0aW9uX2NhbGwgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgIHR5cGVvZiBzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZS5mdW5jdGlvbl9jYWxsID09PSAnc3RyaW5nJykgJiZcbiAgICAgICAgKHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlLnRvb2xfY2FsbHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgIHR5cGVvZiBzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZS50b29sX2NhbGxzID09PSAnc3RyaW5nJylcbiAgICAgICkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gSWYgd2UgZ2V0IGhlcmUgYW5kIGFyZSBleHBlY3RpbmcgYSBmdW5jdGlvbiBjYWxsLCB0aGUgbWVzc2FnZSBzaG91bGQgaGF2ZSBvbmUsIGlmIG5vdCB3YXJuIGFuZCBjb250aW51ZVxuICAgICAgaWYgKGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCkge1xuICAgICAgICBjb25zdCBmdW5jdGlvbkNhbGwgPSBzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZS5mdW5jdGlvbl9jYWxsO1xuICAgICAgICBpZiAoISh0eXBlb2YgZnVuY3Rpb25DYWxsID09PSAnb2JqZWN0JykpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAnZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHNob3VsZCBub3QgYmUgZGVmaW5lZCB3aGVuIHVzaW5nIHRvb2xzJyxcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbFJlc3BvbnNlOiBDaGF0UmVxdWVzdCB8IHZvaWQgPVxuICAgICAgICAgIGF3YWl0IGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbChnZXRDdXJyZW50TWVzc2FnZXMoKSwgZnVuY3Rpb25DYWxsKTtcblxuICAgICAgICAvLyBJZiB0aGUgdXNlciBkb2VzIG5vdCByZXR1cm4gYW55dGhpbmcgYXMgYSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uIGNhbGwsIHRoZSBsb29wIHdpbGwgYnJlYWsuXG4gICAgICAgIGlmIChmdW5jdGlvbkNhbGxSZXNwb25zZSA9PT0gdW5kZWZpbmVkKSBicmVhaztcbiAgICAgICAgLy8gQSBmdW5jdGlvbiBjYWxsIHJlc3BvbnNlIHdhcyByZXR1cm5lZC5cbiAgICAgICAgLy8gVGhlIHVwZGF0ZWQgY2hhdCB3aXRoIGZ1bmN0aW9uIGNhbGwgcmVzcG9uc2Ugd2lsbCBiZSBzZW50IHRvIHRoZSBBUEkgaW4gdGhlIG5leHQgaXRlcmF0aW9uIG9mIHRoZSBsb29wLlxuICAgICAgICBmaXhGdW5jdGlvbkNhbGxBcmd1bWVudHMoZnVuY3Rpb25DYWxsUmVzcG9uc2UpO1xuICAgICAgICB1cGRhdGVDaGF0UmVxdWVzdChmdW5jdGlvbkNhbGxSZXNwb25zZSk7XG4gICAgICB9XG4gICAgICAvLyBJZiB3ZSBnZXQgaGVyZSBhbmQgYXJlIGV4cGVjdGluZyBhIHRvb2wgY2FsbCwgdGhlIG1lc3NhZ2Ugc2hvdWxkIGhhdmUgb25lLCBpZiBub3Qgd2FybiBhbmQgY29udGludWVcbiAgICAgIGlmIChleHBlcmltZW50YWxfb25Ub29sQ2FsbCkge1xuICAgICAgICBjb25zdCB0b29sQ2FsbHMgPSBzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZS50b29sX2NhbGxzO1xuICAgICAgICBpZiAoISh0eXBlb2YgdG9vbENhbGxzID09PSAnb2JqZWN0JykpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAnZXhwZXJpbWVudGFsX29uVG9vbENhbGwgc2hvdWxkIG5vdCBiZSBkZWZpbmVkIHdoZW4gdXNpbmcgZnVuY3Rpb25zJyxcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvb2xDYWxsUmVzcG9uc2U6IENoYXRSZXF1ZXN0IHwgdm9pZCA9XG4gICAgICAgICAgYXdhaXQgZXhwZXJpbWVudGFsX29uVG9vbENhbGwoZ2V0Q3VycmVudE1lc3NhZ2VzKCksIHRvb2xDYWxscyk7XG5cbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgZG9lcyBub3QgcmV0dXJuIGFueXRoaW5nIGFzIGEgcmVzdWx0IG9mIHRoZSBmdW5jdGlvbiBjYWxsLCB0aGUgbG9vcCB3aWxsIGJyZWFrLlxuICAgICAgICBpZiAodG9vbENhbGxSZXNwb25zZSA9PT0gdW5kZWZpbmVkKSBicmVhaztcbiAgICAgICAgLy8gQSBmdW5jdGlvbiBjYWxsIHJlc3BvbnNlIHdhcyByZXR1cm5lZC5cbiAgICAgICAgLy8gVGhlIHVwZGF0ZWQgY2hhdCB3aXRoIGZ1bmN0aW9uIGNhbGwgcmVzcG9uc2Ugd2lsbCBiZSBzZW50IHRvIHRoZSBBUEkgaW4gdGhlIG5leHQgaXRlcmF0aW9uIG9mIHRoZSBsb29wLlxuICAgICAgICBmaXhGdW5jdGlvbkNhbGxBcmd1bWVudHModG9vbENhbGxSZXNwb25zZSk7XG4gICAgICAgIHVwZGF0ZUNoYXRSZXF1ZXN0KHRvb2xDYWxsUmVzcG9uc2UpO1xuICAgICAgfVxuXG4gICAgICAvLyBNYWtlIHN1cmUgZnVuY3Rpb24gY2FsbCBhcmd1bWVudHMgYXJlIHNlbnQgYmFjayB0byB0aGUgQVBJIGFzIGEgc3RyaW5nXG4gICAgICBmdW5jdGlvbiBmaXhGdW5jdGlvbkNhbGxBcmd1bWVudHMocmVzcG9uc2U6IENoYXRSZXF1ZXN0KSB7XG4gICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiByZXNwb25zZS5tZXNzYWdlcykge1xuICAgICAgICAgIGlmIChtZXNzYWdlLnRvb2xfY2FsbHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCB0b29sQ2FsbCBvZiBtZXNzYWdlLnRvb2xfY2FsbHMpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b29sQ2FsbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMgJiZcbiAgICAgICAgICAgICAgICAgIHR5cGVvZiB0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMgIT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMgPSBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICAgICAgdG9vbENhbGwuZnVuY3Rpb24uYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZnVuY3Rpb25fY2FsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuZnVuY3Rpb25fY2FsbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZnVuY3Rpb25fY2FsbC5hcmd1bWVudHMgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgbWVzc2FnZS5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50cyAhPT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50cyA9IEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZS5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VJZCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB1c2VTV1IgZnJvbSAnc3dyJztcbmltcG9ydCB7IGNhbGxDb21wbGV0aW9uQXBpIH0gZnJvbSAnLi4vc2hhcmVkL2NhbGwtY29tcGxldGlvbi1hcGknO1xuaW1wb3J0IHtcbiAgSlNPTlZhbHVlLFxuICBSZXF1ZXN0T3B0aW9ucyxcbiAgVXNlQ29tcGxldGlvbk9wdGlvbnMsXG59IGZyb20gJy4uL3NoYXJlZC90eXBlcyc7XG5cbmV4cG9ydCB0eXBlIHsgVXNlQ29tcGxldGlvbk9wdGlvbnMgfTtcblxuZXhwb3J0IHR5cGUgVXNlQ29tcGxldGlvbkhlbHBlcnMgPSB7XG4gIC8qKiBUaGUgY3VycmVudCBjb21wbGV0aW9uIHJlc3VsdCAqL1xuICBjb21wbGV0aW9uOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBTZW5kIGEgbmV3IHByb21wdCB0byB0aGUgQVBJIGVuZHBvaW50IGFuZCB1cGRhdGUgdGhlIGNvbXBsZXRpb24gc3RhdGUuXG4gICAqL1xuICBjb21wbGV0ZTogKFxuICAgIHByb21wdDogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBSZXF1ZXN0T3B0aW9ucyxcbiAgKSA9PiBQcm9taXNlPHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ+O1xuICAvKiogVGhlIGVycm9yIG9iamVjdCBvZiB0aGUgQVBJIHJlcXVlc3QgKi9cbiAgZXJyb3I6IHVuZGVmaW5lZCB8IEVycm9yO1xuICAvKipcbiAgICogQWJvcnQgdGhlIGN1cnJlbnQgQVBJIHJlcXVlc3QgYnV0IGtlZXAgdGhlIGdlbmVyYXRlZCB0b2tlbnMuXG4gICAqL1xuICBzdG9wOiAoKSA9PiB2b2lkO1xuICAvKipcbiAgICogVXBkYXRlIHRoZSBgY29tcGxldGlvbmAgc3RhdGUgbG9jYWxseS5cbiAgICovXG4gIHNldENvbXBsZXRpb246IChjb21wbGV0aW9uOiBzdHJpbmcpID0+IHZvaWQ7XG4gIC8qKiBUaGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgaW5wdXQgKi9cbiAgaW5wdXQ6IHN0cmluZztcbiAgLyoqIHNldFN0YXRlLXBvd2VyZWQgbWV0aG9kIHRvIHVwZGF0ZSB0aGUgaW5wdXQgdmFsdWUgKi9cbiAgc2V0SW5wdXQ6IFJlYWN0LkRpc3BhdGNoPFJlYWN0LlNldFN0YXRlQWN0aW9uPHN0cmluZz4+O1xuICAvKipcbiAgICogQW4gaW5wdXQvdGV4dGFyZWEtcmVhZHkgb25DaGFuZ2UgaGFuZGxlciB0byBjb250cm9sIHRoZSB2YWx1ZSBvZiB0aGUgaW5wdXRcbiAgICogQGV4YW1wbGVcbiAgICogYGBganN4XG4gICAqIDxpbnB1dCBvbkNoYW5nZT17aGFuZGxlSW5wdXRDaGFuZ2V9IHZhbHVlPXtpbnB1dH0gLz5cbiAgICogYGBgXG4gICAqL1xuICBoYW5kbGVJbnB1dENoYW5nZTogKFxuICAgIGU6XG4gICAgICB8IFJlYWN0LkNoYW5nZUV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+XG4gICAgICB8IFJlYWN0LkNoYW5nZUV2ZW50PEhUTUxUZXh0QXJlYUVsZW1lbnQ+LFxuICApID0+IHZvaWQ7XG4gIC8qKlxuICAgKiBGb3JtIHN1Ym1pc3Npb24gaGFuZGxlciB0byBhdXRvbWF0aWNhbGx5IHJlc2V0IGlucHV0IGFuZCBhcHBlbmQgYSB1c2VyIG1lc3NhZ2VcbiAgICogQGV4YW1wbGVcbiAgICogYGBganN4XG4gICAqIDxmb3JtIG9uU3VibWl0PXtoYW5kbGVTdWJtaXR9PlxuICAgKiAgPGlucHV0IG9uQ2hhbmdlPXtoYW5kbGVJbnB1dENoYW5nZX0gdmFsdWU9e2lucHV0fSAvPlxuICAgKiA8L2Zvcm0+XG4gICAqIGBgYFxuICAgKi9cbiAgaGFuZGxlU3VibWl0OiAoZTogUmVhY3QuRm9ybUV2ZW50PEhUTUxGb3JtRWxlbWVudD4pID0+IHZvaWQ7XG4gIC8qKiBXaGV0aGVyIHRoZSBBUEkgcmVxdWVzdCBpcyBpbiBwcm9ncmVzcyAqL1xuICBpc0xvYWRpbmc6IGJvb2xlYW47XG4gIC8qKiBBZGRpdGlvbmFsIGRhdGEgYWRkZWQgb24gdGhlIHNlcnZlciB2aWEgU3RyZWFtRGF0YSAqL1xuICBkYXRhPzogSlNPTlZhbHVlW107XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlQ29tcGxldGlvbih7XG4gIGFwaSA9ICcvYXBpL2NvbXBsZXRpb24nLFxuICBpZCxcbiAgaW5pdGlhbENvbXBsZXRpb24gPSAnJyxcbiAgaW5pdGlhbElucHV0ID0gJycsXG4gIGNyZWRlbnRpYWxzLFxuICBoZWFkZXJzLFxuICBib2R5LFxuICBzdHJlYW1Nb2RlLFxuICBvblJlc3BvbnNlLFxuICBvbkZpbmlzaCxcbiAgb25FcnJvcixcbn06IFVzZUNvbXBsZXRpb25PcHRpb25zID0ge30pOiBVc2VDb21wbGV0aW9uSGVscGVycyB7XG4gIC8vIEdlbmVyYXRlIGFuIHVuaXF1ZSBpZCBmb3IgdGhlIGNvbXBsZXRpb24gaWYgbm90IHByb3ZpZGVkLlxuICBjb25zdCBob29rSWQgPSB1c2VJZCgpO1xuICBjb25zdCBjb21wbGV0aW9uSWQgPSBpZCB8fCBob29rSWQ7XG5cbiAgLy8gU3RvcmUgdGhlIGNvbXBsZXRpb24gc3RhdGUgaW4gU1dSLCB1c2luZyB0aGUgY29tcGxldGlvbklkIGFzIHRoZSBrZXkgdG8gc2hhcmUgc3RhdGVzLlxuICBjb25zdCB7IGRhdGEsIG11dGF0ZSB9ID0gdXNlU1dSPHN0cmluZz4oW2FwaSwgY29tcGxldGlvbklkXSwgbnVsbCwge1xuICAgIGZhbGxiYWNrRGF0YTogaW5pdGlhbENvbXBsZXRpb24sXG4gIH0pO1xuXG4gIGNvbnN0IHsgZGF0YTogaXNMb2FkaW5nID0gZmFsc2UsIG11dGF0ZTogbXV0YXRlTG9hZGluZyB9ID0gdXNlU1dSPGJvb2xlYW4+KFxuICAgIFtjb21wbGV0aW9uSWQsICdsb2FkaW5nJ10sXG4gICAgbnVsbCxcbiAgKTtcblxuICBjb25zdCB7IGRhdGE6IHN0cmVhbURhdGEsIG11dGF0ZTogbXV0YXRlU3RyZWFtRGF0YSB9ID0gdXNlU1dSPFxuICAgIEpTT05WYWx1ZVtdIHwgdW5kZWZpbmVkXG4gID4oW2NvbXBsZXRpb25JZCwgJ3N0cmVhbURhdGEnXSwgbnVsbCk7XG5cbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTx1bmRlZmluZWQgfCBFcnJvcj4odW5kZWZpbmVkKTtcbiAgY29uc3QgY29tcGxldGlvbiA9IGRhdGEhO1xuXG4gIC8vIEFib3J0IGNvbnRyb2xsZXIgdG8gY2FuY2VsIHRoZSBjdXJyZW50IEFQSSBjYWxsLlxuICBjb25zdCBbYWJvcnRDb250cm9sbGVyLCBzZXRBYm9ydENvbnRyb2xsZXJdID1cbiAgICB1c2VTdGF0ZTxBYm9ydENvbnRyb2xsZXIgfCBudWxsPihudWxsKTtcblxuICBjb25zdCBleHRyYU1ldGFkYXRhUmVmID0gdXNlUmVmKHtcbiAgICBjcmVkZW50aWFscyxcbiAgICBoZWFkZXJzLFxuICAgIGJvZHksXG4gIH0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGV4dHJhTWV0YWRhdGFSZWYuY3VycmVudCA9IHtcbiAgICAgIGNyZWRlbnRpYWxzLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGJvZHksXG4gICAgfTtcbiAgfSwgW2NyZWRlbnRpYWxzLCBoZWFkZXJzLCBib2R5XSk7XG5cbiAgY29uc3QgdHJpZ2dlclJlcXVlc3QgPSB1c2VDYWxsYmFjayhcbiAgICBhc3luYyAocHJvbXB0OiBzdHJpbmcsIG9wdGlvbnM/OiBSZXF1ZXN0T3B0aW9ucykgPT5cbiAgICAgIGNhbGxDb21wbGV0aW9uQXBpKHtcbiAgICAgICAgYXBpLFxuICAgICAgICBwcm9tcHQsXG4gICAgICAgIGNyZWRlbnRpYWxzOiBleHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQuY3JlZGVudGlhbHMsXG4gICAgICAgIGhlYWRlcnM6IHsgLi4uZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LmhlYWRlcnMsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgYm9keToge1xuICAgICAgICAgIC4uLmV4dHJhTWV0YWRhdGFSZWYuY3VycmVudC5ib2R5LFxuICAgICAgICAgIC4uLm9wdGlvbnM/LmJvZHksXG4gICAgICAgIH0sXG4gICAgICAgIHN0cmVhbU1vZGUsXG4gICAgICAgIHNldENvbXBsZXRpb246IGNvbXBsZXRpb24gPT4gbXV0YXRlKGNvbXBsZXRpb24sIGZhbHNlKSxcbiAgICAgICAgc2V0TG9hZGluZzogbXV0YXRlTG9hZGluZyxcbiAgICAgICAgc2V0RXJyb3IsXG4gICAgICAgIHNldEFib3J0Q29udHJvbGxlcixcbiAgICAgICAgb25SZXNwb25zZSxcbiAgICAgICAgb25GaW5pc2gsXG4gICAgICAgIG9uRXJyb3IsXG4gICAgICAgIG9uRGF0YTogZGF0YSA9PiB7XG4gICAgICAgICAgbXV0YXRlU3RyZWFtRGF0YShbLi4uKHN0cmVhbURhdGEgfHwgW10pLCAuLi4oZGF0YSB8fCBbXSldLCBmYWxzZSk7XG4gICAgICAgIH0sXG4gICAgICB9KSxcbiAgICBbXG4gICAgICBtdXRhdGUsXG4gICAgICBtdXRhdGVMb2FkaW5nLFxuICAgICAgYXBpLFxuICAgICAgZXh0cmFNZXRhZGF0YVJlZixcbiAgICAgIHNldEFib3J0Q29udHJvbGxlcixcbiAgICAgIG9uUmVzcG9uc2UsXG4gICAgICBvbkZpbmlzaCxcbiAgICAgIG9uRXJyb3IsXG4gICAgICBzZXRFcnJvcixcbiAgICAgIHN0cmVhbURhdGEsXG4gICAgICBtdXRhdGVTdHJlYW1EYXRhLFxuICAgIF0sXG4gICk7XG5cbiAgY29uc3Qgc3RvcCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIHNldEFib3J0Q29udHJvbGxlcihudWxsKTtcbiAgICB9XG4gIH0sIFthYm9ydENvbnRyb2xsZXJdKTtcblxuICBjb25zdCBzZXRDb21wbGV0aW9uID0gdXNlQ2FsbGJhY2soXG4gICAgKGNvbXBsZXRpb246IHN0cmluZykgPT4ge1xuICAgICAgbXV0YXRlKGNvbXBsZXRpb24sIGZhbHNlKTtcbiAgICB9LFxuICAgIFttdXRhdGVdLFxuICApO1xuXG4gIGNvbnN0IGNvbXBsZXRlID0gdXNlQ2FsbGJhY2s8VXNlQ29tcGxldGlvbkhlbHBlcnNbJ2NvbXBsZXRlJ10+KFxuICAgIGFzeW5jIChwcm9tcHQsIG9wdGlvbnMpID0+IHtcbiAgICAgIHJldHVybiB0cmlnZ2VyUmVxdWVzdChwcm9tcHQsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgW3RyaWdnZXJSZXF1ZXN0XSxcbiAgKTtcblxuICBjb25zdCBbaW5wdXQsIHNldElucHV0XSA9IHVzZVN0YXRlKGluaXRpYWxJbnB1dCk7XG5cbiAgY29uc3QgaGFuZGxlU3VibWl0ID0gdXNlQ2FsbGJhY2soXG4gICAgKGU6IFJlYWN0LkZvcm1FdmVudDxIVE1MRm9ybUVsZW1lbnQ+KSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAoIWlucHV0KSByZXR1cm47XG4gICAgICByZXR1cm4gY29tcGxldGUoaW5wdXQpO1xuICAgIH0sXG4gICAgW2lucHV0LCBjb21wbGV0ZV0sXG4gICk7XG5cbiAgY29uc3QgaGFuZGxlSW5wdXRDaGFuZ2UgPSAoZTogYW55KSA9PiB7XG4gICAgc2V0SW5wdXQoZS50YXJnZXQudmFsdWUpO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgY29tcGxldGlvbixcbiAgICBjb21wbGV0ZSxcbiAgICBlcnJvcixcbiAgICBzZXRDb21wbGV0aW9uLFxuICAgIHN0b3AsXG4gICAgaW5wdXQsXG4gICAgc2V0SW5wdXQsXG4gICAgaGFuZGxlSW5wdXRDaGFuZ2UsXG4gICAgaGFuZGxlU3VibWl0LFxuICAgIGlzTG9hZGluZyxcbiAgICBkYXRhOiBzdHJlYW1EYXRhLFxuICB9O1xufVxuIiwiaW1wb3J0IHsgcmVhZERhdGFTdHJlYW0gfSBmcm9tICcuL3JlYWQtZGF0YS1zdHJlYW0nO1xuaW1wb3J0IHsgSlNPTlZhbHVlIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBjcmVhdGVDaHVua0RlY29kZXIgfSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNhbGxDb21wbGV0aW9uQXBpKHtcbiAgYXBpLFxuICBwcm9tcHQsXG4gIGNyZWRlbnRpYWxzLFxuICBoZWFkZXJzLFxuICBib2R5LFxuICBzdHJlYW1Nb2RlID0gJ3N0cmVhbS1kYXRhJyxcbiAgc2V0Q29tcGxldGlvbixcbiAgc2V0TG9hZGluZyxcbiAgc2V0RXJyb3IsXG4gIHNldEFib3J0Q29udHJvbGxlcixcbiAgb25SZXNwb25zZSxcbiAgb25GaW5pc2gsXG4gIG9uRXJyb3IsXG4gIG9uRGF0YSxcbn06IHtcbiAgYXBpOiBzdHJpbmc7XG4gIHByb21wdDogc3RyaW5nO1xuICBjcmVkZW50aWFscz86IFJlcXVlc3RDcmVkZW50aWFscztcbiAgaGVhZGVycz86IEhlYWRlcnNJbml0O1xuICBib2R5OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICBzdHJlYW1Nb2RlPzogJ3N0cmVhbS1kYXRhJyB8ICd0ZXh0JztcbiAgc2V0Q29tcGxldGlvbjogKGNvbXBsZXRpb246IHN0cmluZykgPT4gdm9pZDtcbiAgc2V0TG9hZGluZzogKGxvYWRpbmc6IGJvb2xlYW4pID0+IHZvaWQ7XG4gIHNldEVycm9yOiAoZXJyb3I6IEVycm9yIHwgdW5kZWZpbmVkKSA9PiB2b2lkO1xuICBzZXRBYm9ydENvbnRyb2xsZXI6IChhYm9ydENvbnRyb2xsZXI6IEFib3J0Q29udHJvbGxlciB8IG51bGwpID0+IHZvaWQ7XG4gIG9uUmVzcG9uc2U/OiAocmVzcG9uc2U6IFJlc3BvbnNlKSA9PiB2b2lkIHwgUHJvbWlzZTx2b2lkPjtcbiAgb25GaW5pc2g/OiAocHJvbXB0OiBzdHJpbmcsIGNvbXBsZXRpb246IHN0cmluZykgPT4gdm9pZDtcbiAgb25FcnJvcj86IChlcnJvcjogRXJyb3IpID0+IHZvaWQ7XG4gIG9uRGF0YT86IChkYXRhOiBKU09OVmFsdWVbXSkgPT4gdm9pZDtcbn0pIHtcbiAgdHJ5IHtcbiAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgIHNldEVycm9yKHVuZGVmaW5lZCk7XG5cbiAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgc2V0QWJvcnRDb250cm9sbGVyKGFib3J0Q29udHJvbGxlcik7XG5cbiAgICAvLyBFbXB0eSB0aGUgY29tcGxldGlvbiBpbW1lZGlhdGVseS5cbiAgICBzZXRDb21wbGV0aW9uKCcnKTtcblxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGFwaSwge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHByb21wdCxcbiAgICAgICAgLi4uYm9keSxcbiAgICAgIH0pLFxuICAgICAgY3JlZGVudGlhbHMsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIC4uLmhlYWRlcnMsXG4gICAgICB9LFxuICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSk7XG5cbiAgICBpZiAob25SZXNwb25zZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgb25SZXNwb25zZShyZXMpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAoYXdhaXQgcmVzLnRleHQoKSkgfHwgJ0ZhaWxlZCB0byBmZXRjaCB0aGUgY2hhdCByZXNwb25zZS4nLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIXJlcy5ib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSByZXNwb25zZSBib2R5IGlzIGVtcHR5LicpO1xuICAgIH1cblxuICAgIGxldCByZXN1bHQgPSAnJztcbiAgICBjb25zdCByZWFkZXIgPSByZXMuYm9keS5nZXRSZWFkZXIoKTtcblxuICAgIHN3aXRjaCAoc3RyZWFtTW9kZSkge1xuICAgICAgY2FzZSAndGV4dCc6IHtcbiAgICAgICAgY29uc3QgZGVjb2RlciA9IGNyZWF0ZUNodW5rRGVjb2RlcigpO1xuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVXBkYXRlIHRoZSBjb21wbGV0aW9uIHN0YXRlIHdpdGggdGhlIG5ldyBtZXNzYWdlIHRva2Vucy5cbiAgICAgICAgICByZXN1bHQgKz0gZGVjb2Rlcih2YWx1ZSk7XG4gICAgICAgICAgc2V0Q29tcGxldGlvbihyZXN1bHQpO1xuXG4gICAgICAgICAgLy8gVGhlIHJlcXVlc3QgaGFzIGJlZW4gYWJvcnRlZCwgc3RvcCByZWFkaW5nIHRoZSBzdHJlYW0uXG4gICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmVhZGVyLmNhbmNlbCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNhc2UgJ3N0cmVhbS1kYXRhJzoge1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHsgdHlwZSwgdmFsdWUgfSBvZiByZWFkRGF0YVN0cmVhbShyZWFkZXIsIHtcbiAgICAgICAgICBpc0Fib3J0ZWQ6ICgpID0+IGFib3J0Q29udHJvbGxlciA9PT0gbnVsbCxcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3RleHQnOiB7XG4gICAgICAgICAgICAgIHJlc3VsdCArPSB2YWx1ZTtcbiAgICAgICAgICAgICAgc2V0Q29tcGxldGlvbihyZXN1bHQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2RhdGEnOiB7XG4gICAgICAgICAgICAgIG9uRGF0YT8uKHZhbHVlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGNvbnN0IGV4aGF1c3RpdmVDaGVjazogbmV2ZXIgPSBzdHJlYW1Nb2RlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gc3RyZWFtIG1vZGU6ICR7ZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvbkZpbmlzaCkge1xuICAgICAgb25GaW5pc2gocHJvbXB0LCByZXN1bHQpO1xuICAgIH1cblxuICAgIHNldEFib3J0Q29udHJvbGxlcihudWxsKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBJZ25vcmUgYWJvcnQgZXJyb3JzIGFzIHRoZXkgYXJlIGV4cGVjdGVkLlxuICAgIGlmICgoZXJyIGFzIGFueSkubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICBzZXRBYm9ydENvbnRyb2xsZXIobnVsbCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRFcnJvcihlcnIgYXMgRXJyb3IpO1xuICB9IGZpbmFsbHkge1xuICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICB9XG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rcyAqL1xuXG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgZ2VuZXJhdGVJZCB9IGZyb20gJy4uL3NoYXJlZC9nZW5lcmF0ZS1pZCc7XG5pbXBvcnQgeyByZWFkRGF0YVN0cmVhbSB9IGZyb20gJy4uL3NoYXJlZC9yZWFkLWRhdGEtc3RyZWFtJztcbmltcG9ydCB7IENyZWF0ZU1lc3NhZ2UsIE1lc3NhZ2UgfSBmcm9tICcuLi9zaGFyZWQvdHlwZXMnO1xuXG5leHBvcnQgdHlwZSBBc3Npc3RhbnRTdGF0dXMgPSAnaW5fcHJvZ3Jlc3MnIHwgJ2F3YWl0aW5nX21lc3NhZ2UnO1xuXG5leHBvcnQgdHlwZSBVc2VBc3Npc3RhbnRIZWxwZXJzID0ge1xuICAvKipcbiAgICogVGhlIGN1cnJlbnQgYXJyYXkgb2YgY2hhdCBtZXNzYWdlcy5cbiAgICovXG4gIG1lc3NhZ2VzOiBNZXNzYWdlW107XG5cbiAgLyoqXG4gICAqIHNldFN0YXRlLXBvd2VyZWQgbWV0aG9kIHRvIHVwZGF0ZSB0aGUgbWVzc2FnZXMgYXJyYXkuXG4gICAqL1xuICBzZXRNZXNzYWdlczogUmVhY3QuRGlzcGF0Y2g8UmVhY3QuU2V0U3RhdGVBY3Rpb248TWVzc2FnZVtdPj47XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHRocmVhZCBJRC5cbiAgICovXG4gIHRocmVhZElkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBpbnB1dCBmaWVsZC5cbiAgICovXG4gIGlucHV0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEFwcGVuZCBhIHVzZXIgbWVzc2FnZSB0byB0aGUgY2hhdCBsaXN0LiBUaGlzIHRyaWdnZXJzIHRoZSBBUEkgY2FsbCB0byBmZXRjaFxuICAgKiB0aGUgYXNzaXN0YW50J3MgcmVzcG9uc2UuXG4gICAqIEBwYXJhbSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGFwcGVuZFxuICAgKiBAcGFyYW0gcmVxdWVzdE9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIEFQSSBjYWxsXG4gICAqL1xuICBhcHBlbmQ6IChcbiAgICBtZXNzYWdlOiBNZXNzYWdlIHwgQ3JlYXRlTWVzc2FnZSxcbiAgICByZXF1ZXN0T3B0aW9ucz86IHtcbiAgICAgIGRhdGE/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICAgIH0sXG4gICkgPT4gUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogc2V0U3RhdGUtcG93ZXJlZCBtZXRob2QgdG8gdXBkYXRlIHRoZSBpbnB1dCB2YWx1ZS5cbiAgICovXG4gIHNldElucHV0OiBSZWFjdC5EaXNwYXRjaDxSZWFjdC5TZXRTdGF0ZUFjdGlvbjxzdHJpbmc+PjtcblxuICAvKipcbiAgICogSGFuZGxlciBmb3IgdGhlIGBvbkNoYW5nZWAgZXZlbnQgb2YgdGhlIGlucHV0IGZpZWxkIHRvIGNvbnRyb2wgdGhlIGlucHV0J3MgdmFsdWUuXG4gICAqL1xuICBoYW5kbGVJbnB1dENoYW5nZTogKFxuICAgIGV2ZW50OlxuICAgICAgfCBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PlxuICAgICAgfCBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MVGV4dEFyZWFFbGVtZW50PixcbiAgKSA9PiB2b2lkO1xuXG4gIC8qKlxuICAgKiBGb3JtIHN1Ym1pc3Npb24gaGFuZGxlciB0aGF0IGF1dG9tYXRpY2FsbHkgcmVzZXRzIHRoZSBpbnB1dCBmaWVsZCBhbmQgYXBwZW5kcyBhIHVzZXIgbWVzc2FnZS5cbiAgICovXG4gIHN1Ym1pdE1lc3NhZ2U6IChcbiAgICBldmVudD86IFJlYWN0LkZvcm1FdmVudDxIVE1MRm9ybUVsZW1lbnQ+LFxuICAgIHJlcXVlc3RPcHRpb25zPzoge1xuICAgICAgZGF0YT86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gICAgfSxcbiAgKSA9PiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBzdGF0dXMgb2YgdGhlIGFzc2lzdGFudC4gVGhpcyBjYW4gYmUgdXNlZCB0byBzaG93IGEgbG9hZGluZyBpbmRpY2F0b3IuXG4gICAqL1xuICBzdGF0dXM6IEFzc2lzdGFudFN0YXR1cztcblxuICAvKipcbiAgICogVGhlIGVycm9yIHRocm93biBkdXJpbmcgdGhlIGFzc2lzdGFudCBtZXNzYWdlIHByb2Nlc3NpbmcsIGlmIGFueS5cbiAgICovXG4gIGVycm9yOiB1bmRlZmluZWQgfCB1bmtub3duO1xufTtcblxuZXhwb3J0IHR5cGUgVXNlQXNzaXN0YW50T3B0aW9ucyA9IHtcbiAgLyoqXG4gICAqIFRoZSBBUEkgZW5kcG9pbnQgdGhhdCBhY2NlcHRzIGEgYHsgdGhyZWFkSWQ6IHN0cmluZyB8IG51bGw7IG1lc3NhZ2U6IHN0cmluZzsgfWAgb2JqZWN0IGFuZCByZXR1cm5zIGFuIGBBc3Npc3RhbnRSZXNwb25zZWAgc3RyZWFtLlxuICAgKiBUaGUgdGhyZWFkSWQgcmVmZXJzIHRvIGFuIGV4aXN0aW5nIHRocmVhZCB3aXRoIG1lc3NhZ2VzIChvciBpcyBgbnVsbGAgdG8gY3JlYXRlIGEgbmV3IHRocmVhZCkuXG4gICAqIFRoZSBtZXNzYWdlIGlzIHRoZSBuZXh0IG1lc3NhZ2UgdGhhdCBzaG91bGQgYmUgYXBwZW5kZWQgdG8gdGhlIHRocmVhZCBhbmQgc2VudCB0byB0aGUgYXNzaXN0YW50LlxuICAgKi9cbiAgYXBpOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEFuIG9wdGlvbmFsIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgdGhlIElEIG9mIGFuIGV4aXN0aW5nIHRocmVhZC5cbiAgICogSWYgbm90IHByb3ZpZGVkLCBhIG5ldyB0aHJlYWQgd2lsbCBiZSBjcmVhdGVkLlxuICAgKi9cbiAgdGhyZWFkSWQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEFuIG9wdGlvbmFsIGxpdGVyYWwgdGhhdCBzZXRzIHRoZSBtb2RlIG9mIGNyZWRlbnRpYWxzIHRvIGJlIHVzZWQgb24gdGhlIHJlcXVlc3QuXG4gICAqIERlZmF1bHRzIHRvIFwic2FtZS1vcmlnaW5cIi5cbiAgICovXG4gIGNyZWRlbnRpYWxzPzogUmVxdWVzdENyZWRlbnRpYWxzO1xuXG4gIC8qKlxuICAgKiBBbiBvcHRpb25hbCBvYmplY3Qgb2YgaGVhZGVycyB0byBiZSBwYXNzZWQgdG8gdGhlIEFQSSBlbmRwb2ludC5cbiAgICovXG4gIGhlYWRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHwgSGVhZGVycztcblxuICAvKipcbiAgICogQW4gb3B0aW9uYWwsIGFkZGl0aW9uYWwgYm9keSBvYmplY3QgdG8gYmUgcGFzc2VkIHRvIHRoZSBBUEkgZW5kcG9pbnQuXG4gICAqL1xuICBib2R5Pzogb2JqZWN0O1xuXG4gIC8qKlxuICAgKiBBbiBvcHRpb25hbCBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGFzc2lzdGFudCBlbmNvdW50ZXJzIGFuIGVycm9yLlxuICAgKi9cbiAgb25FcnJvcj86IChlcnJvcjogRXJyb3IpID0+IHZvaWQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlQXNzaXN0YW50KHtcbiAgYXBpLFxuICB0aHJlYWRJZDogdGhyZWFkSWRQYXJhbSxcbiAgY3JlZGVudGlhbHMsXG4gIGhlYWRlcnMsXG4gIGJvZHksXG4gIG9uRXJyb3IsXG59OiBVc2VBc3Npc3RhbnRPcHRpb25zKTogVXNlQXNzaXN0YW50SGVscGVycyB7XG4gIGNvbnN0IFttZXNzYWdlcywgc2V0TWVzc2FnZXNdID0gdXNlU3RhdGU8TWVzc2FnZVtdPihbXSk7XG4gIGNvbnN0IFtpbnB1dCwgc2V0SW5wdXRdID0gdXNlU3RhdGUoJycpO1xuICBjb25zdCBbdGhyZWFkSWQsIHNldFRocmVhZElkXSA9IHVzZVN0YXRlPHN0cmluZyB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcbiAgY29uc3QgW3N0YXR1cywgc2V0U3RhdHVzXSA9IHVzZVN0YXRlPEFzc2lzdGFudFN0YXR1cz4oJ2F3YWl0aW5nX21lc3NhZ2UnKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTx1bmRlZmluZWQgfCBFcnJvcj4odW5kZWZpbmVkKTtcblxuICBjb25zdCBoYW5kbGVJbnB1dENoYW5nZSA9IChcbiAgICBldmVudDpcbiAgICAgIHwgUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD5cbiAgICAgIHwgUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTFRleHRBcmVhRWxlbWVudD4sXG4gICkgPT4ge1xuICAgIHNldElucHV0KGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gIH07XG5cbiAgY29uc3QgYXBwZW5kID0gYXN5bmMgKFxuICAgIG1lc3NhZ2U6IE1lc3NhZ2UgfCBDcmVhdGVNZXNzYWdlLFxuICAgIHJlcXVlc3RPcHRpb25zPzoge1xuICAgICAgZGF0YT86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gICAgfSxcbiAgKSA9PiB7XG4gICAgc2V0U3RhdHVzKCdpbl9wcm9ncmVzcycpO1xuXG4gICAgc2V0TWVzc2FnZXMobWVzc2FnZXMgPT4gW1xuICAgICAgLi4ubWVzc2FnZXMsXG4gICAgICB7XG4gICAgICAgIC4uLm1lc3NhZ2UsXG4gICAgICAgIGlkOiBtZXNzYWdlLmlkID8/IGdlbmVyYXRlSWQoKSxcbiAgICAgIH0sXG4gICAgXSk7XG5cbiAgICBzZXRJbnB1dCgnJyk7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZmV0Y2goYXBpLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBjcmVkZW50aWFscyxcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLCAuLi5oZWFkZXJzIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAuLi5ib2R5LFxuICAgICAgICAgIC8vIGFsd2F5cyB1c2UgdXNlci1wcm92aWRlZCB0aHJlYWRJZCB3aGVuIGF2YWlsYWJsZTpcbiAgICAgICAgICB0aHJlYWRJZDogdGhyZWFkSWRQYXJhbSA/PyB0aHJlYWRJZCA/PyBudWxsLFxuICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UuY29udGVudCxcblxuICAgICAgICAgIC8vIG9wdGlvbmFsIHJlcXVlc3QgZGF0YTpcbiAgICAgICAgICBkYXRhOiByZXF1ZXN0T3B0aW9ucz8uZGF0YSxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgaWYgKHJlc3VsdC5ib2R5ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcmVzcG9uc2UgYm9keSBpcyBlbXB0eS4nKTtcbiAgICAgIH1cblxuICAgICAgZm9yIGF3YWl0IChjb25zdCB7IHR5cGUsIHZhbHVlIH0gb2YgcmVhZERhdGFTdHJlYW0oXG4gICAgICAgIHJlc3VsdC5ib2R5LmdldFJlYWRlcigpLFxuICAgICAgKSkge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlICdhc3Npc3RhbnRfbWVzc2FnZSc6IHtcbiAgICAgICAgICAgIHNldE1lc3NhZ2VzKG1lc3NhZ2VzID0+IFtcbiAgICAgICAgICAgICAgLi4ubWVzc2FnZXMsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZDogdmFsdWUuaWQsXG4gICAgICAgICAgICAgICAgcm9sZTogdmFsdWUucm9sZSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiB2YWx1ZS5jb250ZW50WzBdLnRleHQudmFsdWUsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ3RleHQnOiB7XG4gICAgICAgICAgICAvLyB0ZXh0IGRlbHRhIC0gYWRkIHRvIGxhc3QgbWVzc2FnZTpcbiAgICAgICAgICAgIHNldE1lc3NhZ2VzKG1lc3NhZ2VzID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgbGFzdE1lc3NhZ2UgPSBtZXNzYWdlc1ttZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAuLi5tZXNzYWdlcy5zbGljZSgwLCBtZXNzYWdlcy5sZW5ndGggLSAxKSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZDogbGFzdE1lc3NhZ2UuaWQsXG4gICAgICAgICAgICAgICAgICByb2xlOiBsYXN0TWVzc2FnZS5yb2xlLFxuICAgICAgICAgICAgICAgICAgY29udGVudDogbGFzdE1lc3NhZ2UuY29udGVudCArIHZhbHVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnZGF0YV9tZXNzYWdlJzoge1xuICAgICAgICAgICAgc2V0TWVzc2FnZXMobWVzc2FnZXMgPT4gW1xuICAgICAgICAgICAgICAuLi5tZXNzYWdlcyxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlkOiB2YWx1ZS5pZCA/PyBnZW5lcmF0ZUlkKCksXG4gICAgICAgICAgICAgICAgcm9sZTogJ2RhdGEnLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgICAgICAgICAgIGRhdGE6IHZhbHVlLmRhdGEsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2Fzc2lzdGFudF9jb250cm9sX2RhdGEnOiB7XG4gICAgICAgICAgICBzZXRUaHJlYWRJZCh2YWx1ZS50aHJlYWRJZCk7XG5cbiAgICAgICAgICAgIC8vIHNldCBpZCBvZiBsYXN0IG1lc3NhZ2U6XG4gICAgICAgICAgICBzZXRNZXNzYWdlcyhtZXNzYWdlcyA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGxhc3RNZXNzYWdlID0gbWVzc2FnZXNbbWVzc2FnZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgIGxhc3RNZXNzYWdlLmlkID0gdmFsdWUubWVzc2FnZUlkO1xuICAgICAgICAgICAgICByZXR1cm4gWy4uLm1lc3NhZ2VzLnNsaWNlKDAsIG1lc3NhZ2VzLmxlbmd0aCAtIDEpLCBsYXN0TWVzc2FnZV07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnZXJyb3InOiB7XG4gICAgICAgICAgICBjb25zdCBlcnJvck9iaiA9IG5ldyBFcnJvcih2YWx1ZSk7XG4gICAgICAgICAgICBzZXRFcnJvcihlcnJvck9iaik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKG9uRXJyb3IgJiYgZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgc2V0RXJyb3IoZXJyb3IgYXMgRXJyb3IpO1xuICAgIH1cblxuICAgIHNldFN0YXR1cygnYXdhaXRpbmdfbWVzc2FnZScpO1xuICB9O1xuXG4gIGNvbnN0IHN1Ym1pdE1lc3NhZ2UgPSBhc3luYyAoXG4gICAgZXZlbnQ/OiBSZWFjdC5Gb3JtRXZlbnQ8SFRNTEZvcm1FbGVtZW50PixcbiAgICByZXF1ZXN0T3B0aW9ucz86IHtcbiAgICAgIGRhdGE/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICAgIH0sXG4gICkgPT4ge1xuICAgIGV2ZW50Py5wcmV2ZW50RGVmYXVsdD8uKCk7XG5cbiAgICBpZiAoaW5wdXQgPT09ICcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYXBwZW5kKHsgcm9sZTogJ3VzZXInLCBjb250ZW50OiBpbnB1dCB9LCByZXF1ZXN0T3B0aW9ucyk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBhcHBlbmQsXG4gICAgbWVzc2FnZXMsXG4gICAgc2V0TWVzc2FnZXMsXG4gICAgdGhyZWFkSWQsXG4gICAgaW5wdXQsXG4gICAgc2V0SW5wdXQsXG4gICAgaGFuZGxlSW5wdXRDaGFuZ2UsXG4gICAgc3VibWl0TWVzc2FnZSxcbiAgICBzdGF0dXMsXG4gICAgZXJyb3IsXG4gIH07XG59XG5cbi8qKlxuQGRlcHJlY2F0ZWQgVXNlIGB1c2VBc3Npc3RhbnRgIGluc3RlYWQuXG4gKi9cbmV4cG9ydCBjb25zdCBleHBlcmltZW50YWxfdXNlQXNzaXN0YW50ID0gdXNlQXNzaXN0YW50O1xuIl0sIm5hbWVzIjpbInVzZUNhbGxiYWNrIiwidXNlRWZmZWN0IiwidXNlSWQiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZVNXUiIsInRleHRTdHJlYW1QYXJ0IiwiY29kZSIsIm5hbWUiLCJwYXJzZSIsInZhbHVlIiwiRXJyb3IiLCJ0eXBlIiwiZnVuY3Rpb25DYWxsU3RyZWFtUGFydCIsImZ1bmN0aW9uX2NhbGwiLCJhcmd1bWVudHMiLCJkYXRhU3RyZWFtUGFydCIsIkFycmF5IiwiaXNBcnJheSIsImVycm9yU3RyZWFtUGFydCIsImFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0IiwiaWQiLCJyb2xlIiwiY29udGVudCIsImV2ZXJ5IiwiaXRlbSIsInRleHQiLCJhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQiLCJ0aHJlYWRJZCIsIm1lc3NhZ2VJZCIsImRhdGFNZXNzYWdlU3RyZWFtUGFydCIsInRvb2xDYWxsU3RyZWFtUGFydCIsInRvb2xfY2FsbHMiLCJzb21lIiwidGMiLCJmdW5jdGlvbiIsIm1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQiLCJzdHJlYW1QYXJ0cyIsInN0cmVhbVBhcnRzQnlDb2RlIiwiU3RyZWFtU3RyaW5nUHJlZml4ZXMiLCJ2YWxpZENvZGVzIiwibWFwIiwicGFydCIsInBhcnNlU3RyZWFtUGFydCIsImxpbmUiLCJmaXJzdFNlcGFyYXRvckluZGV4IiwiaW5kZXhPZiIsInByZWZpeCIsInNsaWNlIiwiaW5jbHVkZXMiLCJ0ZXh0VmFsdWUiLCJqc29uVmFsdWUiLCJKU09OIiwiTkVXTElORSIsImNoYXJDb2RlQXQiLCJjb25jYXRDaHVua3MiLCJjaHVua3MiLCJ0b3RhbExlbmd0aCIsImNvbmNhdGVuYXRlZENodW5rcyIsIlVpbnQ4QXJyYXkiLCJvZmZzZXQiLCJjaHVuayIsInNldCIsImxlbmd0aCIsInJlYWREYXRhU3RyZWFtIiwicmVhZGVyIiwiaXNBYm9ydGVkIiwiZGVjb2RlciIsIlRleHREZWNvZGVyIiwicmVhZCIsInB1c2giLCJkZWNvZGUiLCJzdHJlYW0iLCJzcGxpdCIsImZpbHRlciIsInN0cmVhbVBhcnQiLCJjYW5jZWwiLCJjdXN0b21BbHBoYWJldCIsImdlbmVyYXRlSWQiLCJhc3NpZ25Bbm5vdGF0aW9uc1RvTWVzc2FnZSIsIm1lc3NhZ2UiLCJhbm5vdGF0aW9ucyIsInBhcnNlQ29tcGxleFJlc3BvbnNlIiwiYWJvcnRDb250cm9sbGVyUmVmIiwidXBkYXRlIiwib25GaW5pc2giLCJnZXRDdXJyZW50RGF0ZSIsIkRhdGUiLCJjcmVhdGVkQXQiLCJwcmVmaXhNYXAiLCJkYXRhIiwibWVzc2FnZV9hbm5vdGF0aW9ucyIsImN1cnJlbnQiLCJmdW5jdGlvbkNhbGxNZXNzYWdlIiwidG9vbENhbGxNZXNzYWdlIiwicmVzcG9uc2VNZXNzYWdlIiwibWVzc2FnZVByZWZpeEtleXMiLCJmb3JFYWNoIiwia2V5IiwibWVyZ2VkIiwiQm9vbGVhbiIsIm1lc3NhZ2VzIiwiY3JlYXRlQ2h1bmtEZWNvZGVyIiwiY29tcGxleCIsImRlY29kZWQiLCJjYWxsQ2hhdEFwaSIsImFwaSIsImJvZHkiLCJzdHJlYW1Nb2RlIiwiY3JlZGVudGlhbHMiLCJoZWFkZXJzIiwiYWJvcnRDb250cm9sbGVyIiwicmVzdG9yZU1lc3NhZ2VzT25GYWlsdXJlIiwib25SZXNwb25zZSIsIm9uVXBkYXRlIiwiX2EiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwic3RyaW5naWZ5Iiwic2lnbmFsIiwiY2F0Y2giLCJlcnIiLCJvayIsImdldFJlYWRlciIsInJlc3VsdE1lc3NhZ2UiLCJkb25lIiwiZXhoYXVzdGl2ZUNoZWNrIiwicHJvY2Vzc0NoYXRTdHJlYW0iLCJnZXRTdHJlYW1lZFJlc3BvbnNlIiwiZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIiwiZXhwZXJpbWVudGFsX29uVG9vbENhbGwiLCJ1cGRhdGVDaGF0UmVxdWVzdCIsImdldEN1cnJlbnRNZXNzYWdlcyIsIm1lc3NhZ2VzQW5kRGF0YU9ySnVzdE1lc3NhZ2UiLCJoYXNGb2xsb3dpbmdSZXNwb25zZSIsImZ1bmN0aW9uQ2FsbCIsImNvbnNvbGUiLCJ3YXJuIiwiZnVuY3Rpb25DYWxsUmVzcG9uc2UiLCJ0b29sQ2FsbHMiLCJ0b29sQ2FsbCIsInRvb2xDYWxsUmVzcG9uc2UiLCJmaXhGdW5jdGlvbkNhbGxBcmd1bWVudHMiLCJzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZSIsImNoYXRSZXF1ZXN0IiwibXV0YXRlIiwibXV0YXRlU3RyZWFtRGF0YSIsImV4aXN0aW5nRGF0YSIsImV4dHJhTWV0YWRhdGFSZWYiLCJtZXNzYWdlc1JlZiIsInNlbmRFeHRyYU1lc3NhZ2VGaWVsZHMiLCJfYiIsInByZXZpb3VzTWVzc2FnZXMiLCJjb25zdHJ1Y3RlZE1lc3NhZ2VzUGF5bG9hZCIsInRvb2xfY2FsbF9pZCIsInJlcGx5SWQiLCJyZWFkUm93IiwicHJvbWlzZSIsInVpIiwibmV4dCIsImUiLCJvcHRpb25zIiwiZnVuY3Rpb25zIiwidG9vbHMiLCJ0b29sX2Nob2ljZSIsInVzZUNoYXQiLCJpbml0aWFsTWVzc2FnZXMiLCJpbml0aWFsSW5wdXQiLCJvbkVycm9yIiwiaG9va0lkIiwiaWRLZXkiLCJjaGF0S2V5IiwiaW5pdGlhbE1lc3NhZ2VzRmFsbGJhY2siLCJmYWxsYmFja0RhdGEiLCJpc0xvYWRpbmciLCJtdXRhdGVMb2FkaW5nIiwic3RyZWFtRGF0YSIsImVycm9yIiwic2V0RXJyb3IiLCJ0cmlnZ2VyUmVxdWVzdCIsIkFib3J0Q29udHJvbGxlciIsImNoYXRSZXF1ZXN0UGFyYW0iLCJhcHBlbmQiLCJjb25jYXQiLCJyZWxvYWQiLCJsYXN0TWVzc2FnZSIsInN0b3AiLCJhYm9ydCIsInNldE1lc3NhZ2VzIiwiaW5wdXQiLCJzZXRJbnB1dCIsImhhbmRsZVN1Ym1pdCIsIm1ldGFkYXRhIiwicHJldmVudERlZmF1bHQiLCJoYW5kbGVJbnB1dENoYW5nZSIsInRhcmdldCIsImNhbGxDb21wbGV0aW9uQXBpIiwicHJvbXB0Iiwic2V0Q29tcGxldGlvbiIsInNldExvYWRpbmciLCJzZXRBYm9ydENvbnRyb2xsZXIiLCJvbkRhdGEiLCJyZXMiLCJyZXN1bHQiLCJ1c2VDb21wbGV0aW9uIiwiaW5pdGlhbENvbXBsZXRpb24iLCJjb21wbGV0aW9uSWQiLCJjb21wbGV0aW9uIiwiY29tcGxldGUiLCJ1c2VBc3Npc3RhbnQiLCJ0aHJlYWRJZFBhcmFtIiwic2V0VGhyZWFkSWQiLCJzdGF0dXMiLCJzZXRTdGF0dXMiLCJldmVudCIsInJlcXVlc3RPcHRpb25zIiwiZXJyb3JPYmoiLCJzdWJtaXRNZXNzYWdlIiwiY2FsbCIsImV4cGVyaW1lbnRhbF91c2VBc3Npc3RhbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ai/react/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/nanoid/non-secure/index.js":
/*!*************************************************!*\
  !*** ./node_modules/nanoid/non-secure/index.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   customAlphabet: function() { return /* binding */ customAlphabet; },\n/* harmony export */   nanoid: function() { return /* binding */ nanoid; }\n/* harmony export */ });\nlet urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nlet customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = ''\n    let i = size\n    while (i--) {\n      id += alphabet[(Math.random() * alphabet.length) | 0]\n    }\n    return id\n  }\n}\nlet nanoid = (size = 21) => {\n  let id = ''\n  let i = size\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0]\n  }\n  return id\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uYW5vaWQvbm9uLXNlY3VyZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25hbm9pZC9ub24tc2VjdXJlL2luZGV4LmpzP2YxYmQiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IHVybEFscGhhYmV0ID1cbiAgJ3VzZWFuZG9tLTI2VDE5ODM0MFBYNzVweEpBQ0tWRVJZTUlOREJVU0hXT0xGX0dRWmJmZ2hqa2xxdnd5enJpY3QnXG5sZXQgY3VzdG9tQWxwaGFiZXQgPSAoYWxwaGFiZXQsIGRlZmF1bHRTaXplID0gMjEpID0+IHtcbiAgcmV0dXJuIChzaXplID0gZGVmYXVsdFNpemUpID0+IHtcbiAgICBsZXQgaWQgPSAnJ1xuICAgIGxldCBpID0gc2l6ZVxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlkICs9IGFscGhhYmV0WyhNYXRoLnJhbmRvbSgpICogYWxwaGFiZXQubGVuZ3RoKSB8IDBdXG4gICAgfVxuICAgIHJldHVybiBpZFxuICB9XG59XG5sZXQgbmFub2lkID0gKHNpemUgPSAyMSkgPT4ge1xuICBsZXQgaWQgPSAnJ1xuICBsZXQgaSA9IHNpemVcbiAgd2hpbGUgKGktLSkge1xuICAgIGlkICs9IHVybEFscGhhYmV0WyhNYXRoLnJhbmRvbSgpICogNjQpIHwgMF1cbiAgfVxuICByZXR1cm4gaWRcbn1cbmV4cG9ydCB7IG5hbm9pZCwgY3VzdG9tQWxwaGFiZXQgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/nanoid/non-secure/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/swr/_internal/dist/index.mjs":
/*!***************************************************!*\
  !*** ./node_modules/swr/_internal/dist/index.mjs ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IS_REACT_LEGACY: function() { return /* binding */ IS_REACT_LEGACY; },\n/* harmony export */   IS_SERVER: function() { return /* binding */ IS_SERVER; },\n/* harmony export */   OBJECT: function() { return /* binding */ OBJECT; },\n/* harmony export */   SWRConfig: function() { return /* binding */ SWRConfig; },\n/* harmony export */   SWRGlobalState: function() { return /* binding */ SWRGlobalState; },\n/* harmony export */   UNDEFINED: function() { return /* binding */ UNDEFINED; },\n/* harmony export */   cache: function() { return /* binding */ cache; },\n/* harmony export */   compare: function() { return /* binding */ compare; },\n/* harmony export */   createCacheHelper: function() { return /* binding */ createCacheHelper; },\n/* harmony export */   defaultConfig: function() { return /* binding */ defaultConfig; },\n/* harmony export */   defaultConfigOptions: function() { return /* binding */ defaultConfigOptions; },\n/* harmony export */   getTimestamp: function() { return /* binding */ getTimestamp; },\n/* harmony export */   hasRequestAnimationFrame: function() { return /* binding */ hasRequestAnimationFrame; },\n/* harmony export */   initCache: function() { return /* binding */ initCache; },\n/* harmony export */   internalMutate: function() { return /* binding */ internalMutate; },\n/* harmony export */   isDocumentDefined: function() { return /* binding */ isDocumentDefined; },\n/* harmony export */   isFunction: function() { return /* binding */ isFunction; },\n/* harmony export */   isPromiseLike: function() { return /* binding */ isPromiseLike; },\n/* harmony export */   isUndefined: function() { return /* binding */ isUndefined; },\n/* harmony export */   isWindowDefined: function() { return /* binding */ isWindowDefined; },\n/* harmony export */   mergeConfigs: function() { return /* binding */ mergeConfigs; },\n/* harmony export */   mergeObjects: function() { return /* binding */ mergeObjects; },\n/* harmony export */   mutate: function() { return /* binding */ mutate; },\n/* harmony export */   noop: function() { return /* binding */ noop; },\n/* harmony export */   normalize: function() { return /* binding */ normalize; },\n/* harmony export */   preload: function() { return /* binding */ preload; },\n/* harmony export */   preset: function() { return /* binding */ preset; },\n/* harmony export */   rAF: function() { return /* binding */ rAF; },\n/* harmony export */   revalidateEvents: function() { return /* binding */ constants; },\n/* harmony export */   serialize: function() { return /* binding */ serialize; },\n/* harmony export */   slowConnection: function() { return /* binding */ slowConnection; },\n/* harmony export */   stableHash: function() { return /* binding */ stableHash; },\n/* harmony export */   subscribeCallback: function() { return /* binding */ subscribeCallback; },\n/* harmony export */   useIsomorphicLayoutEffect: function() { return /* binding */ useIsomorphicLayoutEffect; },\n/* harmony export */   useSWRConfig: function() { return /* binding */ useSWRConfig; },\n/* harmony export */   useStateWithDeps: function() { return /* binding */ useStateWithDeps; },\n/* harmony export */   withArgs: function() { return /* binding */ withArgs; },\n/* harmony export */   withMiddleware: function() { return /* binding */ withMiddleware; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n\n// Shared state between server components and client components\nconst noop = ()=>{};\n// Using noop() as the undefined value as undefined can be replaced\n// by something else. Prettier ignore and extra parentheses are necessary here\n// to ensure that tsc doesn't remove the __NOINLINE__ comment.\n// prettier-ignore\nconst UNDEFINED = /*#__NOINLINE__*/ noop();\nconst OBJECT = Object;\nconst isUndefined = (v)=>v === UNDEFINED;\nconst isFunction = (v)=>typeof v == 'function';\nconst mergeObjects = (a, b)=>({\n        ...a,\n        ...b\n    });\nconst isPromiseLike = (x)=>isFunction(x.then);\n\n// use WeakMap to store the object->key mapping\n// so the objects can be garbage collected.\n// WeakMap uses a hashtable under the hood, so the lookup\n// complexity is almost O(1).\nconst table = new WeakMap();\n// counter of the key\nlet counter = 0;\n// A stable hash implementation that supports:\n// - Fast and ensures unique hash properties\n// - Handles unserializable values\n// - Handles object key ordering\n// - Generates short results\n//\n// This is not a serialization function, and the result is not guaranteed to be\n// parsable.\nconst stableHash = (arg)=>{\n    const type = typeof arg;\n    const constructor = arg && arg.constructor;\n    const isDate = constructor == Date;\n    let result;\n    let index;\n    if (OBJECT(arg) === arg && !isDate && constructor != RegExp) {\n        // Object/function, not null/date/regexp. Use WeakMap to store the id first.\n        // If it's already hashed, directly return the result.\n        result = table.get(arg);\n        if (result) return result;\n        // Store the hash first for circular reference detection before entering the\n        // recursive `stableHash` calls.\n        // For other objects like set and map, we use this id directly as the hash.\n        result = ++counter + '~';\n        table.set(arg, result);\n        if (constructor == Array) {\n            // Array.\n            result = '@';\n            for(index = 0; index < arg.length; index++){\n                result += stableHash(arg[index]) + ',';\n            }\n            table.set(arg, result);\n        }\n        if (constructor == OBJECT) {\n            // Object, sort keys.\n            result = '#';\n            const keys = OBJECT.keys(arg).sort();\n            while(!isUndefined(index = keys.pop())){\n                if (!isUndefined(arg[index])) {\n                    result += index + ':' + stableHash(arg[index]) + ',';\n                }\n            }\n            table.set(arg, result);\n        }\n    } else {\n        result = isDate ? arg.toJSON() : type == 'symbol' ? arg.toString() : type == 'string' ? JSON.stringify(arg) : '' + arg;\n    }\n    return result;\n};\n\n// Global state used to deduplicate requests and store listeners\nconst SWRGlobalState = new WeakMap();\n\nconst EMPTY_CACHE = {};\nconst INITIAL_CACHE = {};\nconst STR_UNDEFINED = 'undefined';\n// NOTE: Use the function to guarantee it's re-evaluated between jsdom and node runtime for tests.\nconst isWindowDefined = typeof window != STR_UNDEFINED;\nconst isDocumentDefined = typeof document != STR_UNDEFINED;\nconst hasRequestAnimationFrame = ()=>isWindowDefined && typeof window['requestAnimationFrame'] != STR_UNDEFINED;\nconst createCacheHelper = (cache, key)=>{\n    const state = SWRGlobalState.get(cache);\n    return [\n        // Getter\n        ()=>!isUndefined(key) && cache.get(key) || EMPTY_CACHE,\n        // Setter\n        (info)=>{\n            if (!isUndefined(key)) {\n                const prev = cache.get(key);\n                // Before writing to the store, we keep the value in the initial cache\n                // if it's not there yet.\n                if (!(key in INITIAL_CACHE)) {\n                    INITIAL_CACHE[key] = prev;\n                }\n                state[5](key, mergeObjects(prev, info), prev || EMPTY_CACHE);\n            }\n        },\n        // Subscriber\n        state[6],\n        // Get server cache snapshot\n        ()=>{\n            if (!isUndefined(key)) {\n                // If the cache was updated on the client, we return the stored initial value.\n                if (key in INITIAL_CACHE) return INITIAL_CACHE[key];\n            }\n            // If we haven't done any client-side updates, we return the current value.\n            return !isUndefined(key) && cache.get(key) || EMPTY_CACHE;\n        }\n    ];\n} // export { UNDEFINED, OBJECT, isUndefined, isFunction, mergeObjects, isPromiseLike }\n;\n\n/**\n * Due to the bug https://bugs.chromium.org/p/chromium/issues/detail?id=678075,\n * it's not reliable to detect if the browser is currently online or offline\n * based on `navigator.onLine`.\n * As a workaround, we always assume it's online on the first load, and change\n * the status upon `online` or `offline` events.\n */ let online = true;\nconst isOnline = ()=>online;\n// For node and React Native, `add/removeEventListener` doesn't exist on window.\nconst [onWindowEvent, offWindowEvent] = isWindowDefined && window.addEventListener ? [\n    window.addEventListener.bind(window),\n    window.removeEventListener.bind(window)\n] : [\n    noop,\n    noop\n];\nconst isVisible = ()=>{\n    const visibilityState = isDocumentDefined && document.visibilityState;\n    return isUndefined(visibilityState) || visibilityState !== 'hidden';\n};\nconst initFocus = (callback)=>{\n    // focus revalidate\n    if (isDocumentDefined) {\n        document.addEventListener('visibilitychange', callback);\n    }\n    onWindowEvent('focus', callback);\n    return ()=>{\n        if (isDocumentDefined) {\n            document.removeEventListener('visibilitychange', callback);\n        }\n        offWindowEvent('focus', callback);\n    };\n};\nconst initReconnect = (callback)=>{\n    // revalidate on reconnected\n    const onOnline = ()=>{\n        online = true;\n        callback();\n    };\n    // nothing to revalidate, just update the status\n    const onOffline = ()=>{\n        online = false;\n    };\n    onWindowEvent('online', onOnline);\n    onWindowEvent('offline', onOffline);\n    return ()=>{\n        offWindowEvent('online', onOnline);\n        offWindowEvent('offline', onOffline);\n    };\n};\nconst preset = {\n    isOnline,\n    isVisible\n};\nconst defaultConfigOptions = {\n    initFocus,\n    initReconnect\n};\n\nconst IS_REACT_LEGACY = !react__WEBPACK_IMPORTED_MODULE_0__.useId;\nconst IS_SERVER = !isWindowDefined || 'Deno' in window;\n// Polyfill requestAnimationFrame\nconst rAF = (f)=>hasRequestAnimationFrame() ? window['requestAnimationFrame'](f) : setTimeout(f, 1);\n// React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser.\nconst useIsomorphicLayoutEffect = IS_SERVER ? react__WEBPACK_IMPORTED_MODULE_0__.useEffect : react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect;\n// This assignment is to extend the Navigator type to use effectiveType.\nconst navigatorConnection = typeof navigator !== 'undefined' && navigator.connection;\n// Adjust the config based on slow connection status (<= 70Kbps).\nconst slowConnection = !IS_SERVER && navigatorConnection && ([\n    'slow-2g',\n    '2g'\n].includes(navigatorConnection.effectiveType) || navigatorConnection.saveData);\n\nconst serialize = (key)=>{\n    if (isFunction(key)) {\n        try {\n            key = key();\n        } catch (err) {\n            // dependencies not ready\n            key = '';\n        }\n    }\n    // Use the original key as the argument of fetcher. This can be a string or an\n    // array of values.\n    const args = key;\n    // If key is not falsy, or not an empty array, hash it.\n    key = typeof key == 'string' ? key : (Array.isArray(key) ? key.length : key) ? stableHash(key) : '';\n    return [\n        key,\n        args\n    ];\n};\n\n// Global timestamp.\nlet __timestamp = 0;\nconst getTimestamp = ()=>++__timestamp;\n\nconst FOCUS_EVENT = 0;\nconst RECONNECT_EVENT = 1;\nconst MUTATE_EVENT = 2;\nconst ERROR_REVALIDATE_EVENT = 3;\n\nvar constants = {\n  __proto__: null,\n  ERROR_REVALIDATE_EVENT: ERROR_REVALIDATE_EVENT,\n  FOCUS_EVENT: FOCUS_EVENT,\n  MUTATE_EVENT: MUTATE_EVENT,\n  RECONNECT_EVENT: RECONNECT_EVENT\n};\n\nasync function internalMutate(...args) {\n    const [cache, _key, _data, _opts] = args;\n    // When passing as a boolean, it's explicitly used to disable/enable\n    // revalidation.\n    const options = mergeObjects({\n        populateCache: true,\n        throwOnError: true\n    }, typeof _opts === 'boolean' ? {\n        revalidate: _opts\n    } : _opts || {});\n    let populateCache = options.populateCache;\n    const rollbackOnErrorOption = options.rollbackOnError;\n    let optimisticData = options.optimisticData;\n    const revalidate = options.revalidate !== false;\n    const rollbackOnError = (error)=>{\n        return typeof rollbackOnErrorOption === 'function' ? rollbackOnErrorOption(error) : rollbackOnErrorOption !== false;\n    };\n    const throwOnError = options.throwOnError;\n    // If the second argument is a key filter, return the mutation results for all\n    // filtered keys.\n    if (isFunction(_key)) {\n        const keyFilter = _key;\n        const matchedKeys = [];\n        const it = cache.keys();\n        for (const key of it){\n            if (// Skip the special useSWRInfinite and useSWRSubscription keys.\n            !/^\\$(inf|sub)\\$/.test(key) && keyFilter(cache.get(key)._k)) {\n                matchedKeys.push(key);\n            }\n        }\n        return Promise.all(matchedKeys.map(mutateByKey));\n    }\n    return mutateByKey(_key);\n    async function mutateByKey(_k) {\n        // Serialize key\n        const [key] = serialize(_k);\n        if (!key) return;\n        const [get, set] = createCacheHelper(cache, key);\n        const [EVENT_REVALIDATORS, MUTATION, FETCH, PRELOAD] = SWRGlobalState.get(cache);\n        const revalidators = EVENT_REVALIDATORS[key];\n        const startRevalidate = ()=>{\n            if (revalidate) {\n                // Invalidate the key by deleting the concurrent request markers so new\n                // requests will not be deduped.\n                delete FETCH[key];\n                delete PRELOAD[key];\n                if (revalidators && revalidators[0]) {\n                    return revalidators[0](MUTATE_EVENT).then(()=>get().data);\n                }\n            }\n            return get().data;\n        };\n        // If there is no new data provided, revalidate the key with current state.\n        if (args.length < 3) {\n            // Revalidate and broadcast state.\n            return startRevalidate();\n        }\n        let data = _data;\n        let error;\n        // Update global timestamps.\n        const beforeMutationTs = getTimestamp();\n        MUTATION[key] = [\n            beforeMutationTs,\n            0\n        ];\n        const hasOptimisticData = !isUndefined(optimisticData);\n        const state = get();\n        // `displayedData` is the current value on screen. It could be the optimistic value\n        // that is going to be overridden by a `committedData`, or get reverted back.\n        // `committedData` is the validated value that comes from a fetch or mutation.\n        const displayedData = state.data;\n        const currentData = state._c;\n        const committedData = isUndefined(currentData) ? displayedData : currentData;\n        // Do optimistic data update.\n        if (hasOptimisticData) {\n            optimisticData = isFunction(optimisticData) ? optimisticData(committedData, displayedData) : optimisticData;\n            // When we set optimistic data, backup the current committedData data in `_c`.\n            set({\n                data: optimisticData,\n                _c: committedData\n            });\n        }\n        if (isFunction(data)) {\n            // `data` is a function, call it passing current cache value.\n            try {\n                data = data(committedData);\n            } catch (err) {\n                // If it throws an error synchronously, we shouldn't update the cache.\n                error = err;\n            }\n        }\n        // `data` is a promise/thenable, resolve the final data first.\n        if (data && isPromiseLike(data)) {\n            // This means that the mutation is async, we need to check timestamps to\n            // avoid race conditions.\n            data = await data.catch((err)=>{\n                error = err;\n            });\n            // Check if other mutations have occurred since we've started this mutation.\n            // If there's a race we don't update cache or broadcast the change,\n            // just return the data.\n            if (beforeMutationTs !== MUTATION[key][0]) {\n                if (error) throw error;\n                return data;\n            } else if (error && hasOptimisticData && rollbackOnError(error)) {\n                // Rollback. Always populate the cache in this case but without\n                // transforming the data.\n                populateCache = true;\n                data = committedData;\n                // Reset data to be the latest committed data, and clear the `_c` value.\n                set({\n                    data,\n                    _c: UNDEFINED\n                });\n            }\n        }\n        // If we should write back the cache after request.\n        if (populateCache) {\n            if (!error) {\n                // Transform the result into data.\n                if (isFunction(populateCache)) {\n                    data = populateCache(data, committedData);\n                }\n                // Only update cached data and reset the error if there's no error. Data can be `undefined` here.\n                set({\n                    data,\n                    error: UNDEFINED,\n                    _c: UNDEFINED\n                });\n            }\n        }\n        // Reset the timestamp to mark the mutation has ended.\n        MUTATION[key][1] = getTimestamp();\n        // Update existing SWR Hooks' internal states:\n        const res = await startRevalidate();\n        // The mutation and revalidation are ended, we can clear it since the data is\n        // not an optimistic value anymore.\n        set({\n            _c: UNDEFINED\n        });\n        // Throw error or return data\n        if (error) {\n            if (throwOnError) throw error;\n            return;\n        }\n        return populateCache ? res : data;\n    }\n}\n\nconst revalidateAllKeys = (revalidators, type)=>{\n    for(const key in revalidators){\n        if (revalidators[key][0]) revalidators[key][0](type);\n    }\n};\nconst initCache = (provider, options)=>{\n    // The global state for a specific provider will be used to deduplicate\n    // requests and store listeners. As well as a mutate function that is bound to\n    // the cache.\n    // The provider's global state might be already initialized. Let's try to get the\n    // global state associated with the provider first.\n    if (!SWRGlobalState.has(provider)) {\n        const opts = mergeObjects(defaultConfigOptions, options);\n        // If there's no global state bound to the provider, create a new one with the\n        // new mutate function.\n        const EVENT_REVALIDATORS = {};\n        const mutate = internalMutate.bind(UNDEFINED, provider);\n        let unmount = noop;\n        const subscriptions = {};\n        const subscribe = (key, callback)=>{\n            const subs = subscriptions[key] || [];\n            subscriptions[key] = subs;\n            subs.push(callback);\n            return ()=>subs.splice(subs.indexOf(callback), 1);\n        };\n        const setter = (key, value, prev)=>{\n            provider.set(key, value);\n            const subs = subscriptions[key];\n            if (subs) {\n                for (const fn of subs){\n                    fn(value, prev);\n                }\n            }\n        };\n        const initProvider = ()=>{\n            if (!SWRGlobalState.has(provider)) {\n                // Update the state if it's new, or if the provider has been extended.\n                SWRGlobalState.set(provider, [\n                    EVENT_REVALIDATORS,\n                    {},\n                    {},\n                    {},\n                    mutate,\n                    setter,\n                    subscribe\n                ]);\n                if (!IS_SERVER) {\n                    // When listening to the native events for auto revalidations,\n                    // we intentionally put a delay (setTimeout) here to make sure they are\n                    // fired after immediate JavaScript executions, which can be\n                    // React's state updates.\n                    // This avoids some unnecessary revalidations such as\n                    // https://github.com/vercel/swr/issues/1680.\n                    const releaseFocus = opts.initFocus(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, FOCUS_EVENT)));\n                    const releaseReconnect = opts.initReconnect(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, RECONNECT_EVENT)));\n                    unmount = ()=>{\n                        releaseFocus && releaseFocus();\n                        releaseReconnect && releaseReconnect();\n                        // When un-mounting, we need to remove the cache provider from the state\n                        // storage too because it's a side-effect. Otherwise, when re-mounting we\n                        // will not re-register those event listeners.\n                        SWRGlobalState.delete(provider);\n                    };\n                }\n            }\n        };\n        initProvider();\n        // This is a new provider, we need to initialize it and setup DOM events\n        // listeners for `focus` and `reconnect` actions.\n        // We might want to inject an extra layer on top of `provider` in the future,\n        // such as key serialization, auto GC, etc.\n        // For now, it's just a `Map` interface without any modifications.\n        return [\n            provider,\n            mutate,\n            initProvider,\n            unmount\n        ];\n    }\n    return [\n        provider,\n        SWRGlobalState.get(provider)[4]\n    ];\n};\n\n// error retry\nconst onErrorRetry = (_, __, config, revalidate, opts)=>{\n    const maxRetryCount = config.errorRetryCount;\n    const currentRetryCount = opts.retryCount;\n    // Exponential backoff\n    const timeout = ~~((Math.random() + 0.5) * (1 << (currentRetryCount < 8 ? currentRetryCount : 8))) * config.errorRetryInterval;\n    if (!isUndefined(maxRetryCount) && currentRetryCount > maxRetryCount) {\n        return;\n    }\n    setTimeout(revalidate, timeout, opts);\n};\nconst compare = (currentData, newData)=>stableHash(currentData) == stableHash(newData);\n// Default cache provider\nconst [cache, mutate] = initCache(new Map());\n// Default config\nconst defaultConfig = mergeObjects({\n    // events\n    onLoadingSlow: noop,\n    onSuccess: noop,\n    onError: noop,\n    onErrorRetry,\n    onDiscarded: noop,\n    // switches\n    revalidateOnFocus: true,\n    revalidateOnReconnect: true,\n    revalidateIfStale: true,\n    shouldRetryOnError: true,\n    // timeouts\n    errorRetryInterval: slowConnection ? 10000 : 5000,\n    focusThrottleInterval: 5 * 1000,\n    dedupingInterval: 2 * 1000,\n    loadingTimeout: slowConnection ? 5000 : 3000,\n    // providers\n    compare,\n    isPaused: ()=>false,\n    cache,\n    mutate,\n    fallback: {}\n}, // use web preset by default\npreset);\n\nconst mergeConfigs = (a, b)=>{\n    // Need to create a new object to avoid mutating the original here.\n    const v = mergeObjects(a, b);\n    // If two configs are provided, merge their `use` and `fallback` options.\n    if (b) {\n        const { use: u1 , fallback: f1  } = a;\n        const { use: u2 , fallback: f2  } = b;\n        if (u1 && u2) {\n            v.use = u1.concat(u2);\n        }\n        if (f1 && f2) {\n            v.fallback = mergeObjects(f1, f2);\n        }\n    }\n    return v;\n};\n\nconst SWRConfigContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\nconst SWRConfig = (props)=>{\n    const { value  } = props;\n    const parentConfig = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SWRConfigContext);\n    const isFunctionalConfig = isFunction(value);\n    const config = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>isFunctionalConfig ? value(parentConfig) : value, [\n        isFunctionalConfig,\n        parentConfig,\n        value\n    ]);\n    // Extend parent context values and middleware.\n    const extendedConfig = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>isFunctionalConfig ? config : mergeConfigs(parentConfig, config), [\n        isFunctionalConfig,\n        parentConfig,\n        config\n    ]);\n    // Should not use the inherited provider.\n    const provider = config && config.provider;\n    // initialize the cache only on first access.\n    const cacheContextRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(UNDEFINED);\n    if (provider && !cacheContextRef.current) {\n        cacheContextRef.current = initCache(provider(extendedConfig.cache || cache), config);\n    }\n    const cacheContext = cacheContextRef.current;\n    // Override the cache if a new provider is given.\n    if (cacheContext) {\n        extendedConfig.cache = cacheContext[0];\n        extendedConfig.mutate = cacheContext[1];\n    }\n    // Unsubscribe events.\n    useIsomorphicLayoutEffect(()=>{\n        if (cacheContext) {\n            cacheContext[2] && cacheContext[2]();\n            return cacheContext[3];\n        }\n    }, []);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(SWRConfigContext.Provider, mergeObjects(props, {\n        value: extendedConfig\n    }));\n};\n\n// @ts-expect-error\nconst enableDevtools = isWindowDefined && window.__SWR_DEVTOOLS_USE__;\nconst use = enableDevtools ? window.__SWR_DEVTOOLS_USE__ : [];\nconst setupDevTools = ()=>{\n    if (enableDevtools) {\n        // @ts-expect-error\n        window.__SWR_DEVTOOLS_REACT__ = react__WEBPACK_IMPORTED_MODULE_0__;\n    }\n};\n\nconst normalize = (args)=>{\n    return isFunction(args[1]) ? [\n        args[0],\n        args[1],\n        args[2] || {}\n    ] : [\n        args[0],\n        null,\n        (args[1] === null ? args[2] : args[1]) || {}\n    ];\n};\n\nconst useSWRConfig = ()=>{\n    return mergeObjects(defaultConfig, (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SWRConfigContext));\n};\n\nconst preload = (key_, fetcher)=>{\n    const [key, fnArg] = serialize(key_);\n    const [, , , PRELOAD] = SWRGlobalState.get(cache);\n    // Prevent preload to be called multiple times before used.\n    if (PRELOAD[key]) return PRELOAD[key];\n    const req = fetcher(fnArg);\n    PRELOAD[key] = req;\n    return req;\n};\nconst middleware = (useSWRNext)=>(key_, fetcher_, config)=>{\n        // fetcher might be a sync function, so this should not be an async function\n        const fetcher = fetcher_ && ((...args)=>{\n            const [key] = serialize(key_);\n            const [, , , PRELOAD] = SWRGlobalState.get(cache);\n            const req = PRELOAD[key];\n            if (isUndefined(req)) return fetcher_(...args);\n            delete PRELOAD[key];\n            return req;\n        });\n        return useSWRNext(key_, fetcher, config);\n    };\n\nconst BUILT_IN_MIDDLEWARE = use.concat(middleware);\n\n// It's tricky to pass generic types as parameters, so we just directly override\n// the types here.\nconst withArgs = (hook)=>{\n    return function useSWRArgs(...args) {\n        // Get the default and inherited configuration.\n        const fallbackConfig = useSWRConfig();\n        // Normalize arguments.\n        const [key, fn, _config] = normalize(args);\n        // Merge configurations.\n        const config = mergeConfigs(fallbackConfig, _config);\n        // Apply middleware\n        let next = hook;\n        const { use  } = config;\n        const middleware = (use || []).concat(BUILT_IN_MIDDLEWARE);\n        for(let i = middleware.length; i--;){\n            next = middleware[i](next);\n        }\n        return next(key, fn || config.fetcher || null, config);\n    };\n};\n\n/**\n * An implementation of state with dependency-tracking.\n */ const useStateWithDeps = (state)=>{\n    const rerender = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({})[1];\n    const unmountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const stateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(state);\n    // If a state property (data, error, or isValidating) is accessed by the render\n    // function, we mark the property as a dependency so if it is updated again\n    // in the future, we trigger a rerender.\n    // This is also known as dependency-tracking.\n    const stateDependenciesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        data: false,\n        error: false,\n        isValidating: false\n    });\n    /**\n   * @param payload To change stateRef, pass the values explicitly to setState:\n   * @example\n   * ```js\n   * setState({\n   *   isValidating: false\n   *   data: newData // set data to newData\n   *   error: undefined // set error to undefined\n   * })\n   *\n   * setState({\n   *   isValidating: false\n   *   data: undefined // set data to undefined\n   *   error: err // set error to err\n   * })\n   * ```\n   */ const setState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((payload)=>{\n        let shouldRerender = false;\n        const currentState = stateRef.current;\n        for(const _ in payload){\n            const k = _;\n            // If the property has changed, update the state and mark rerender as\n            // needed.\n            if (currentState[k] !== payload[k]) {\n                currentState[k] = payload[k];\n                // If the property is accessed by the component, a rerender should be\n                // triggered.\n                if (stateDependenciesRef.current[k]) {\n                    shouldRerender = true;\n                }\n            }\n        }\n        if (shouldRerender && !unmountedRef.current) {\n            if (IS_REACT_LEGACY) {\n                rerender({});\n            } else {\n                react__WEBPACK_IMPORTED_MODULE_0__.startTransition(()=>rerender({}));\n            }\n        }\n    }, [\n        rerender\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        unmountedRef.current = false;\n        return ()=>{\n            unmountedRef.current = true;\n        };\n    });\n    return [\n        stateRef,\n        stateDependenciesRef.current,\n        setState\n    ];\n};\n\n// Add a callback function to a list of keyed callback functions and return\n// the unsubscribe function.\nconst subscribeCallback = (key, callbacks, callback)=>{\n    const keyedRevalidators = callbacks[key] || (callbacks[key] = []);\n    keyedRevalidators.push(callback);\n    return ()=>{\n        const index = keyedRevalidators.indexOf(callback);\n        if (index >= 0) {\n            // O(1): faster than splice\n            keyedRevalidators[index] = keyedRevalidators[keyedRevalidators.length - 1];\n            keyedRevalidators.pop();\n        }\n    };\n};\n\n// Create a custom hook with a middleware\nconst withMiddleware = (useSWR, middleware)=>{\n    return (...args)=>{\n        const [key, fn, config] = normalize(args);\n        const uses = (config.use || []).concat(middleware);\n        return useSWR(key, fn, {\n            ...config,\n            use: uses\n        });\n    };\n};\n\nsetupDevTools();\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zd3IvX2ludGVybmFsL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE0STs7QUFFNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0JBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxZQUFZO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLHdDQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyw0Q0FBUyxHQUFHLGtEQUFlO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsTUFBTSxhQUFhO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMEJBQTBCO0FBQzFDLGdCQUFnQiwwQkFBMEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixvREFBYSxHQUFHO0FBQ3pDO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLHlCQUF5QixpREFBVTtBQUNuQztBQUNBLG1CQUFtQiw4Q0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDhDQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDZDQUFNO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxXQUFXLG9EQUFhO0FBQ3hCO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxrQ0FBSztBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUMsaURBQVU7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQSx1Q0FBdUMsSUFBSTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwrQ0FBUSxHQUFHO0FBQ2hDLHlCQUF5Qiw2Q0FBTTtBQUMvQixxQkFBcUIsNkNBQU07QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNkNBQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHVCQUF1QixrREFBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLGNBQWM7QUFDZCxnQkFBZ0Isa0RBQXFCLGdCQUFnQjtBQUNyRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFb2lCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9zd3IvX2ludGVybmFsL2Rpc3QvaW5kZXgubWpzP2UzM2MiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0LCBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VNZW1vLCB1c2VSZWYsIGNyZWF0ZUVsZW1lbnQsIHVzZVN0YXRlLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcblxuLy8gU2hhcmVkIHN0YXRlIGJldHdlZW4gc2VydmVyIGNvbXBvbmVudHMgYW5kIGNsaWVudCBjb21wb25lbnRzXG5jb25zdCBub29wID0gKCk9Pnt9O1xuLy8gVXNpbmcgbm9vcCgpIGFzIHRoZSB1bmRlZmluZWQgdmFsdWUgYXMgdW5kZWZpbmVkIGNhbiBiZSByZXBsYWNlZFxuLy8gYnkgc29tZXRoaW5nIGVsc2UuIFByZXR0aWVyIGlnbm9yZSBhbmQgZXh0cmEgcGFyZW50aGVzZXMgYXJlIG5lY2Vzc2FyeSBoZXJlXG4vLyB0byBlbnN1cmUgdGhhdCB0c2MgZG9lc24ndCByZW1vdmUgdGhlIF9fTk9JTkxJTkVfXyBjb21tZW50LlxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBVTkRFRklORUQgPSAvKiNfX05PSU5MSU5FX18qLyBub29wKCk7XG5jb25zdCBPQkpFQ1QgPSBPYmplY3Q7XG5jb25zdCBpc1VuZGVmaW5lZCA9ICh2KT0+diA9PT0gVU5ERUZJTkVEO1xuY29uc3QgaXNGdW5jdGlvbiA9ICh2KT0+dHlwZW9mIHYgPT0gJ2Z1bmN0aW9uJztcbmNvbnN0IG1lcmdlT2JqZWN0cyA9IChhLCBiKT0+KHtcbiAgICAgICAgLi4uYSxcbiAgICAgICAgLi4uYlxuICAgIH0pO1xuY29uc3QgaXNQcm9taXNlTGlrZSA9ICh4KT0+aXNGdW5jdGlvbih4LnRoZW4pO1xuXG4vLyB1c2UgV2Vha01hcCB0byBzdG9yZSB0aGUgb2JqZWN0LT5rZXkgbWFwcGluZ1xuLy8gc28gdGhlIG9iamVjdHMgY2FuIGJlIGdhcmJhZ2UgY29sbGVjdGVkLlxuLy8gV2Vha01hcCB1c2VzIGEgaGFzaHRhYmxlIHVuZGVyIHRoZSBob29kLCBzbyB0aGUgbG9va3VwXG4vLyBjb21wbGV4aXR5IGlzIGFsbW9zdCBPKDEpLlxuY29uc3QgdGFibGUgPSBuZXcgV2Vha01hcCgpO1xuLy8gY291bnRlciBvZiB0aGUga2V5XG5sZXQgY291bnRlciA9IDA7XG4vLyBBIHN0YWJsZSBoYXNoIGltcGxlbWVudGF0aW9uIHRoYXQgc3VwcG9ydHM6XG4vLyAtIEZhc3QgYW5kIGVuc3VyZXMgdW5pcXVlIGhhc2ggcHJvcGVydGllc1xuLy8gLSBIYW5kbGVzIHVuc2VyaWFsaXphYmxlIHZhbHVlc1xuLy8gLSBIYW5kbGVzIG9iamVjdCBrZXkgb3JkZXJpbmdcbi8vIC0gR2VuZXJhdGVzIHNob3J0IHJlc3VsdHNcbi8vXG4vLyBUaGlzIGlzIG5vdCBhIHNlcmlhbGl6YXRpb24gZnVuY3Rpb24sIGFuZCB0aGUgcmVzdWx0IGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlXG4vLyBwYXJzYWJsZS5cbmNvbnN0IHN0YWJsZUhhc2ggPSAoYXJnKT0+e1xuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgYXJnO1xuICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gYXJnICYmIGFyZy5jb25zdHJ1Y3RvcjtcbiAgICBjb25zdCBpc0RhdGUgPSBjb25zdHJ1Y3RvciA9PSBEYXRlO1xuICAgIGxldCByZXN1bHQ7XG4gICAgbGV0IGluZGV4O1xuICAgIGlmIChPQkpFQ1QoYXJnKSA9PT0gYXJnICYmICFpc0RhdGUgJiYgY29uc3RydWN0b3IgIT0gUmVnRXhwKSB7XG4gICAgICAgIC8vIE9iamVjdC9mdW5jdGlvbiwgbm90IG51bGwvZGF0ZS9yZWdleHAuIFVzZSBXZWFrTWFwIHRvIHN0b3JlIHRoZSBpZCBmaXJzdC5cbiAgICAgICAgLy8gSWYgaXQncyBhbHJlYWR5IGhhc2hlZCwgZGlyZWN0bHkgcmV0dXJuIHRoZSByZXN1bHQuXG4gICAgICAgIHJlc3VsdCA9IHRhYmxlLmdldChhcmcpO1xuICAgICAgICBpZiAocmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuICAgICAgICAvLyBTdG9yZSB0aGUgaGFzaCBmaXJzdCBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlIGRldGVjdGlvbiBiZWZvcmUgZW50ZXJpbmcgdGhlXG4gICAgICAgIC8vIHJlY3Vyc2l2ZSBgc3RhYmxlSGFzaGAgY2FsbHMuXG4gICAgICAgIC8vIEZvciBvdGhlciBvYmplY3RzIGxpa2Ugc2V0IGFuZCBtYXAsIHdlIHVzZSB0aGlzIGlkIGRpcmVjdGx5IGFzIHRoZSBoYXNoLlxuICAgICAgICByZXN1bHQgPSArK2NvdW50ZXIgKyAnfic7XG4gICAgICAgIHRhYmxlLnNldChhcmcsIHJlc3VsdCk7XG4gICAgICAgIGlmIChjb25zdHJ1Y3RvciA9PSBBcnJheSkge1xuICAgICAgICAgICAgLy8gQXJyYXkuXG4gICAgICAgICAgICByZXN1bHQgPSAnQCc7XG4gICAgICAgICAgICBmb3IoaW5kZXggPSAwOyBpbmRleCA8IGFyZy5sZW5ndGg7IGluZGV4Kyspe1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzdGFibGVIYXNoKGFyZ1tpbmRleF0pICsgJywnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFibGUuc2V0KGFyZywgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uc3RydWN0b3IgPT0gT0JKRUNUKSB7XG4gICAgICAgICAgICAvLyBPYmplY3QsIHNvcnQga2V5cy5cbiAgICAgICAgICAgIHJlc3VsdCA9ICcjJztcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPQkpFQ1Qua2V5cyhhcmcpLnNvcnQoKTtcbiAgICAgICAgICAgIHdoaWxlKCFpc1VuZGVmaW5lZChpbmRleCA9IGtleXMucG9wKCkpKXtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGFyZ1tpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBpbmRleCArICc6JyArIHN0YWJsZUhhc2goYXJnW2luZGV4XSkgKyAnLCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFibGUuc2V0KGFyZywgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGlzRGF0ZSA/IGFyZy50b0pTT04oKSA6IHR5cGUgPT0gJ3N5bWJvbCcgPyBhcmcudG9TdHJpbmcoKSA6IHR5cGUgPT0gJ3N0cmluZycgPyBKU09OLnN0cmluZ2lmeShhcmcpIDogJycgKyBhcmc7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBHbG9iYWwgc3RhdGUgdXNlZCB0byBkZWR1cGxpY2F0ZSByZXF1ZXN0cyBhbmQgc3RvcmUgbGlzdGVuZXJzXG5jb25zdCBTV1JHbG9iYWxTdGF0ZSA9IG5ldyBXZWFrTWFwKCk7XG5cbmNvbnN0IEVNUFRZX0NBQ0hFID0ge307XG5jb25zdCBJTklUSUFMX0NBQ0hFID0ge307XG5jb25zdCBTVFJfVU5ERUZJTkVEID0gJ3VuZGVmaW5lZCc7XG4vLyBOT1RFOiBVc2UgdGhlIGZ1bmN0aW9uIHRvIGd1YXJhbnRlZSBpdCdzIHJlLWV2YWx1YXRlZCBiZXR3ZWVuIGpzZG9tIGFuZCBub2RlIHJ1bnRpbWUgZm9yIHRlc3RzLlxuY29uc3QgaXNXaW5kb3dEZWZpbmVkID0gdHlwZW9mIHdpbmRvdyAhPSBTVFJfVU5ERUZJTkVEO1xuY29uc3QgaXNEb2N1bWVudERlZmluZWQgPSB0eXBlb2YgZG9jdW1lbnQgIT0gU1RSX1VOREVGSU5FRDtcbmNvbnN0IGhhc1JlcXVlc3RBbmltYXRpb25GcmFtZSA9ICgpPT5pc1dpbmRvd0RlZmluZWQgJiYgdHlwZW9mIHdpbmRvd1sncmVxdWVzdEFuaW1hdGlvbkZyYW1lJ10gIT0gU1RSX1VOREVGSU5FRDtcbmNvbnN0IGNyZWF0ZUNhY2hlSGVscGVyID0gKGNhY2hlLCBrZXkpPT57XG4gICAgY29uc3Qgc3RhdGUgPSBTV1JHbG9iYWxTdGF0ZS5nZXQoY2FjaGUpO1xuICAgIHJldHVybiBbXG4gICAgICAgIC8vIEdldHRlclxuICAgICAgICAoKT0+IWlzVW5kZWZpbmVkKGtleSkgJiYgY2FjaGUuZ2V0KGtleSkgfHwgRU1QVFlfQ0FDSEUsXG4gICAgICAgIC8vIFNldHRlclxuICAgICAgICAoaW5mbyk9PntcbiAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBjYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICAvLyBCZWZvcmUgd3JpdGluZyB0byB0aGUgc3RvcmUsIHdlIGtlZXAgdGhlIHZhbHVlIGluIHRoZSBpbml0aWFsIGNhY2hlXG4gICAgICAgICAgICAgICAgLy8gaWYgaXQncyBub3QgdGhlcmUgeWV0LlxuICAgICAgICAgICAgICAgIGlmICghKGtleSBpbiBJTklUSUFMX0NBQ0hFKSkge1xuICAgICAgICAgICAgICAgICAgICBJTklUSUFMX0NBQ0hFW2tleV0gPSBwcmV2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0ZVs1XShrZXksIG1lcmdlT2JqZWN0cyhwcmV2LCBpbmZvKSwgcHJldiB8fCBFTVBUWV9DQUNIRSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFN1YnNjcmliZXJcbiAgICAgICAgc3RhdGVbNl0sXG4gICAgICAgIC8vIEdldCBzZXJ2ZXIgY2FjaGUgc25hcHNob3RcbiAgICAgICAgKCk9PntcbiAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQoa2V5KSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjYWNoZSB3YXMgdXBkYXRlZCBvbiB0aGUgY2xpZW50LCB3ZSByZXR1cm4gdGhlIHN0b3JlZCBpbml0aWFsIHZhbHVlLlxuICAgICAgICAgICAgICAgIGlmIChrZXkgaW4gSU5JVElBTF9DQUNIRSkgcmV0dXJuIElOSVRJQUxfQ0FDSEVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmVuJ3QgZG9uZSBhbnkgY2xpZW50LXNpZGUgdXBkYXRlcywgd2UgcmV0dXJuIHRoZSBjdXJyZW50IHZhbHVlLlxuICAgICAgICAgICAgcmV0dXJuICFpc1VuZGVmaW5lZChrZXkpICYmIGNhY2hlLmdldChrZXkpIHx8IEVNUFRZX0NBQ0hFO1xuICAgICAgICB9XG4gICAgXTtcbn0gLy8gZXhwb3J0IHsgVU5ERUZJTkVELCBPQkpFQ1QsIGlzVW5kZWZpbmVkLCBpc0Z1bmN0aW9uLCBtZXJnZU9iamVjdHMsIGlzUHJvbWlzZUxpa2UgfVxuO1xuXG4vKipcbiAqIER1ZSB0byB0aGUgYnVnIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTY3ODA3NSxcbiAqIGl0J3Mgbm90IHJlbGlhYmxlIHRvIGRldGVjdCBpZiB0aGUgYnJvd3NlciBpcyBjdXJyZW50bHkgb25saW5lIG9yIG9mZmxpbmVcbiAqIGJhc2VkIG9uIGBuYXZpZ2F0b3Iub25MaW5lYC5cbiAqIEFzIGEgd29ya2Fyb3VuZCwgd2UgYWx3YXlzIGFzc3VtZSBpdCdzIG9ubGluZSBvbiB0aGUgZmlyc3QgbG9hZCwgYW5kIGNoYW5nZVxuICogdGhlIHN0YXR1cyB1cG9uIGBvbmxpbmVgIG9yIGBvZmZsaW5lYCBldmVudHMuXG4gKi8gbGV0IG9ubGluZSA9IHRydWU7XG5jb25zdCBpc09ubGluZSA9ICgpPT5vbmxpbmU7XG4vLyBGb3Igbm9kZSBhbmQgUmVhY3QgTmF0aXZlLCBgYWRkL3JlbW92ZUV2ZW50TGlzdGVuZXJgIGRvZXNuJ3QgZXhpc3Qgb24gd2luZG93LlxuY29uc3QgW29uV2luZG93RXZlbnQsIG9mZldpbmRvd0V2ZW50XSA9IGlzV2luZG93RGVmaW5lZCAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciA/IFtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lci5iaW5kKHdpbmRvdyksXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIuYmluZCh3aW5kb3cpXG5dIDogW1xuICAgIG5vb3AsXG4gICAgbm9vcFxuXTtcbmNvbnN0IGlzVmlzaWJsZSA9ICgpPT57XG4gICAgY29uc3QgdmlzaWJpbGl0eVN0YXRlID0gaXNEb2N1bWVudERlZmluZWQgJiYgZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlO1xuICAgIHJldHVybiBpc1VuZGVmaW5lZCh2aXNpYmlsaXR5U3RhdGUpIHx8IHZpc2liaWxpdHlTdGF0ZSAhPT0gJ2hpZGRlbic7XG59O1xuY29uc3QgaW5pdEZvY3VzID0gKGNhbGxiYWNrKT0+e1xuICAgIC8vIGZvY3VzIHJldmFsaWRhdGVcbiAgICBpZiAoaXNEb2N1bWVudERlZmluZWQpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgb25XaW5kb3dFdmVudCgnZm9jdXMnLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuICgpPT57XG4gICAgICAgIGlmIChpc0RvY3VtZW50RGVmaW5lZCkge1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBvZmZXaW5kb3dFdmVudCgnZm9jdXMnLCBjYWxsYmFjayk7XG4gICAgfTtcbn07XG5jb25zdCBpbml0UmVjb25uZWN0ID0gKGNhbGxiYWNrKT0+e1xuICAgIC8vIHJldmFsaWRhdGUgb24gcmVjb25uZWN0ZWRcbiAgICBjb25zdCBvbk9ubGluZSA9ICgpPT57XG4gICAgICAgIG9ubGluZSA9IHRydWU7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfTtcbiAgICAvLyBub3RoaW5nIHRvIHJldmFsaWRhdGUsIGp1c3QgdXBkYXRlIHRoZSBzdGF0dXNcbiAgICBjb25zdCBvbk9mZmxpbmUgPSAoKT0+e1xuICAgICAgICBvbmxpbmUgPSBmYWxzZTtcbiAgICB9O1xuICAgIG9uV2luZG93RXZlbnQoJ29ubGluZScsIG9uT25saW5lKTtcbiAgICBvbldpbmRvd0V2ZW50KCdvZmZsaW5lJywgb25PZmZsaW5lKTtcbiAgICByZXR1cm4gKCk9PntcbiAgICAgICAgb2ZmV2luZG93RXZlbnQoJ29ubGluZScsIG9uT25saW5lKTtcbiAgICAgICAgb2ZmV2luZG93RXZlbnQoJ29mZmxpbmUnLCBvbk9mZmxpbmUpO1xuICAgIH07XG59O1xuY29uc3QgcHJlc2V0ID0ge1xuICAgIGlzT25saW5lLFxuICAgIGlzVmlzaWJsZVxufTtcbmNvbnN0IGRlZmF1bHRDb25maWdPcHRpb25zID0ge1xuICAgIGluaXRGb2N1cyxcbiAgICBpbml0UmVjb25uZWN0XG59O1xuXG5jb25zdCBJU19SRUFDVF9MRUdBQ1kgPSAhUmVhY3QudXNlSWQ7XG5jb25zdCBJU19TRVJWRVIgPSAhaXNXaW5kb3dEZWZpbmVkIHx8ICdEZW5vJyBpbiB3aW5kb3c7XG4vLyBQb2x5ZmlsbCByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbmNvbnN0IHJBRiA9IChmKT0+aGFzUmVxdWVzdEFuaW1hdGlvbkZyYW1lKCkgPyB3aW5kb3dbJ3JlcXVlc3RBbmltYXRpb25GcmFtZSddKGYpIDogc2V0VGltZW91dChmLCAxKTtcbi8vIFJlYWN0IGN1cnJlbnRseSB0aHJvd3MgYSB3YXJuaW5nIHdoZW4gdXNpbmcgdXNlTGF5b3V0RWZmZWN0IG9uIHRoZSBzZXJ2ZXIuXG4vLyBUbyBnZXQgYXJvdW5kIGl0LCB3ZSBjYW4gY29uZGl0aW9uYWxseSB1c2VFZmZlY3Qgb24gdGhlIHNlcnZlciAobm8tb3ApIGFuZFxuLy8gdXNlTGF5b3V0RWZmZWN0IGluIHRoZSBicm93c2VyLlxuY29uc3QgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IElTX1NFUlZFUiA/IHVzZUVmZmVjdCA6IHVzZUxheW91dEVmZmVjdDtcbi8vIFRoaXMgYXNzaWdubWVudCBpcyB0byBleHRlbmQgdGhlIE5hdmlnYXRvciB0eXBlIHRvIHVzZSBlZmZlY3RpdmVUeXBlLlxuY29uc3QgbmF2aWdhdG9yQ29ubmVjdGlvbiA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci5jb25uZWN0aW9uO1xuLy8gQWRqdXN0IHRoZSBjb25maWcgYmFzZWQgb24gc2xvdyBjb25uZWN0aW9uIHN0YXR1cyAoPD0gNzBLYnBzKS5cbmNvbnN0IHNsb3dDb25uZWN0aW9uID0gIUlTX1NFUlZFUiAmJiBuYXZpZ2F0b3JDb25uZWN0aW9uICYmIChbXG4gICAgJ3Nsb3ctMmcnLFxuICAgICcyZydcbl0uaW5jbHVkZXMobmF2aWdhdG9yQ29ubmVjdGlvbi5lZmZlY3RpdmVUeXBlKSB8fCBuYXZpZ2F0b3JDb25uZWN0aW9uLnNhdmVEYXRhKTtcblxuY29uc3Qgc2VyaWFsaXplID0gKGtleSk9PntcbiAgICBpZiAoaXNGdW5jdGlvbihrZXkpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBrZXkgPSBrZXkoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBkZXBlbmRlbmNpZXMgbm90IHJlYWR5XG4gICAgICAgICAgICBrZXkgPSAnJztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBVc2UgdGhlIG9yaWdpbmFsIGtleSBhcyB0aGUgYXJndW1lbnQgb2YgZmV0Y2hlci4gVGhpcyBjYW4gYmUgYSBzdHJpbmcgb3IgYW5cbiAgICAvLyBhcnJheSBvZiB2YWx1ZXMuXG4gICAgY29uc3QgYXJncyA9IGtleTtcbiAgICAvLyBJZiBrZXkgaXMgbm90IGZhbHN5LCBvciBub3QgYW4gZW1wdHkgYXJyYXksIGhhc2ggaXQuXG4gICAga2V5ID0gdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/IGtleSA6IChBcnJheS5pc0FycmF5KGtleSkgPyBrZXkubGVuZ3RoIDoga2V5KSA/IHN0YWJsZUhhc2goa2V5KSA6ICcnO1xuICAgIHJldHVybiBbXG4gICAgICAgIGtleSxcbiAgICAgICAgYXJnc1xuICAgIF07XG59O1xuXG4vLyBHbG9iYWwgdGltZXN0YW1wLlxubGV0IF9fdGltZXN0YW1wID0gMDtcbmNvbnN0IGdldFRpbWVzdGFtcCA9ICgpPT4rK19fdGltZXN0YW1wO1xuXG5jb25zdCBGT0NVU19FVkVOVCA9IDA7XG5jb25zdCBSRUNPTk5FQ1RfRVZFTlQgPSAxO1xuY29uc3QgTVVUQVRFX0VWRU5UID0gMjtcbmNvbnN0IEVSUk9SX1JFVkFMSURBVEVfRVZFTlQgPSAzO1xuXG52YXIgY29uc3RhbnRzID0ge1xuICBfX3Byb3RvX186IG51bGwsXG4gIEVSUk9SX1JFVkFMSURBVEVfRVZFTlQ6IEVSUk9SX1JFVkFMSURBVEVfRVZFTlQsXG4gIEZPQ1VTX0VWRU5UOiBGT0NVU19FVkVOVCxcbiAgTVVUQVRFX0VWRU5UOiBNVVRBVEVfRVZFTlQsXG4gIFJFQ09OTkVDVF9FVkVOVDogUkVDT05ORUNUX0VWRU5UXG59O1xuXG5hc3luYyBmdW5jdGlvbiBpbnRlcm5hbE11dGF0ZSguLi5hcmdzKSB7XG4gICAgY29uc3QgW2NhY2hlLCBfa2V5LCBfZGF0YSwgX29wdHNdID0gYXJncztcbiAgICAvLyBXaGVuIHBhc3NpbmcgYXMgYSBib29sZWFuLCBpdCdzIGV4cGxpY2l0bHkgdXNlZCB0byBkaXNhYmxlL2VuYWJsZVxuICAgIC8vIHJldmFsaWRhdGlvbi5cbiAgICBjb25zdCBvcHRpb25zID0gbWVyZ2VPYmplY3RzKHtcbiAgICAgICAgcG9wdWxhdGVDYWNoZTogdHJ1ZSxcbiAgICAgICAgdGhyb3dPbkVycm9yOiB0cnVlXG4gICAgfSwgdHlwZW9mIF9vcHRzID09PSAnYm9vbGVhbicgPyB7XG4gICAgICAgIHJldmFsaWRhdGU6IF9vcHRzXG4gICAgfSA6IF9vcHRzIHx8IHt9KTtcbiAgICBsZXQgcG9wdWxhdGVDYWNoZSA9IG9wdGlvbnMucG9wdWxhdGVDYWNoZTtcbiAgICBjb25zdCByb2xsYmFja09uRXJyb3JPcHRpb24gPSBvcHRpb25zLnJvbGxiYWNrT25FcnJvcjtcbiAgICBsZXQgb3B0aW1pc3RpY0RhdGEgPSBvcHRpb25zLm9wdGltaXN0aWNEYXRhO1xuICAgIGNvbnN0IHJldmFsaWRhdGUgPSBvcHRpb25zLnJldmFsaWRhdGUgIT09IGZhbHNlO1xuICAgIGNvbnN0IHJvbGxiYWNrT25FcnJvciA9IChlcnJvcik9PntcbiAgICAgICAgcmV0dXJuIHR5cGVvZiByb2xsYmFja09uRXJyb3JPcHRpb24gPT09ICdmdW5jdGlvbicgPyByb2xsYmFja09uRXJyb3JPcHRpb24oZXJyb3IpIDogcm9sbGJhY2tPbkVycm9yT3B0aW9uICE9PSBmYWxzZTtcbiAgICB9O1xuICAgIGNvbnN0IHRocm93T25FcnJvciA9IG9wdGlvbnMudGhyb3dPbkVycm9yO1xuICAgIC8vIElmIHRoZSBzZWNvbmQgYXJndW1lbnQgaXMgYSBrZXkgZmlsdGVyLCByZXR1cm4gdGhlIG11dGF0aW9uIHJlc3VsdHMgZm9yIGFsbFxuICAgIC8vIGZpbHRlcmVkIGtleXMuXG4gICAgaWYgKGlzRnVuY3Rpb24oX2tleSkpIHtcbiAgICAgICAgY29uc3Qga2V5RmlsdGVyID0gX2tleTtcbiAgICAgICAgY29uc3QgbWF0Y2hlZEtleXMgPSBbXTtcbiAgICAgICAgY29uc3QgaXQgPSBjYWNoZS5rZXlzKCk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGl0KXtcbiAgICAgICAgICAgIGlmICgvLyBTa2lwIHRoZSBzcGVjaWFsIHVzZVNXUkluZmluaXRlIGFuZCB1c2VTV1JTdWJzY3JpcHRpb24ga2V5cy5cbiAgICAgICAgICAgICEvXlxcJChpbmZ8c3ViKVxcJC8udGVzdChrZXkpICYmIGtleUZpbHRlcihjYWNoZS5nZXQoa2V5KS5faykpIHtcbiAgICAgICAgICAgICAgICBtYXRjaGVkS2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKG1hdGNoZWRLZXlzLm1hcChtdXRhdGVCeUtleSkpO1xuICAgIH1cbiAgICByZXR1cm4gbXV0YXRlQnlLZXkoX2tleSk7XG4gICAgYXN5bmMgZnVuY3Rpb24gbXV0YXRlQnlLZXkoX2spIHtcbiAgICAgICAgLy8gU2VyaWFsaXplIGtleVxuICAgICAgICBjb25zdCBba2V5XSA9IHNlcmlhbGl6ZShfayk7XG4gICAgICAgIGlmICgha2V5KSByZXR1cm47XG4gICAgICAgIGNvbnN0IFtnZXQsIHNldF0gPSBjcmVhdGVDYWNoZUhlbHBlcihjYWNoZSwga2V5KTtcbiAgICAgICAgY29uc3QgW0VWRU5UX1JFVkFMSURBVE9SUywgTVVUQVRJT04sIEZFVENILCBQUkVMT0FEXSA9IFNXUkdsb2JhbFN0YXRlLmdldChjYWNoZSk7XG4gICAgICAgIGNvbnN0IHJldmFsaWRhdG9ycyA9IEVWRU5UX1JFVkFMSURBVE9SU1trZXldO1xuICAgICAgICBjb25zdCBzdGFydFJldmFsaWRhdGUgPSAoKT0+e1xuICAgICAgICAgICAgaWYgKHJldmFsaWRhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyBJbnZhbGlkYXRlIHRoZSBrZXkgYnkgZGVsZXRpbmcgdGhlIGNvbmN1cnJlbnQgcmVxdWVzdCBtYXJrZXJzIHNvIG5ld1xuICAgICAgICAgICAgICAgIC8vIHJlcXVlc3RzIHdpbGwgbm90IGJlIGRlZHVwZWQuXG4gICAgICAgICAgICAgICAgZGVsZXRlIEZFVENIW2tleV07XG4gICAgICAgICAgICAgICAgZGVsZXRlIFBSRUxPQURba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAocmV2YWxpZGF0b3JzICYmIHJldmFsaWRhdG9yc1swXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV2YWxpZGF0b3JzWzBdKE1VVEFURV9FVkVOVCkudGhlbigoKT0+Z2V0KCkuZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdldCgpLmRhdGE7XG4gICAgICAgIH07XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIG5ldyBkYXRhIHByb3ZpZGVkLCByZXZhbGlkYXRlIHRoZSBrZXkgd2l0aCBjdXJyZW50IHN0YXRlLlxuICAgICAgICBpZiAoYXJncy5sZW5ndGggPCAzKSB7XG4gICAgICAgICAgICAvLyBSZXZhbGlkYXRlIGFuZCBicm9hZGNhc3Qgc3RhdGUuXG4gICAgICAgICAgICByZXR1cm4gc3RhcnRSZXZhbGlkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRhdGEgPSBfZGF0YTtcbiAgICAgICAgbGV0IGVycm9yO1xuICAgICAgICAvLyBVcGRhdGUgZ2xvYmFsIHRpbWVzdGFtcHMuXG4gICAgICAgIGNvbnN0IGJlZm9yZU11dGF0aW9uVHMgPSBnZXRUaW1lc3RhbXAoKTtcbiAgICAgICAgTVVUQVRJT05ba2V5XSA9IFtcbiAgICAgICAgICAgIGJlZm9yZU11dGF0aW9uVHMsXG4gICAgICAgICAgICAwXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGhhc09wdGltaXN0aWNEYXRhID0gIWlzVW5kZWZpbmVkKG9wdGltaXN0aWNEYXRhKTtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBnZXQoKTtcbiAgICAgICAgLy8gYGRpc3BsYXllZERhdGFgIGlzIHRoZSBjdXJyZW50IHZhbHVlIG9uIHNjcmVlbi4gSXQgY291bGQgYmUgdGhlIG9wdGltaXN0aWMgdmFsdWVcbiAgICAgICAgLy8gdGhhdCBpcyBnb2luZyB0byBiZSBvdmVycmlkZGVuIGJ5IGEgYGNvbW1pdHRlZERhdGFgLCBvciBnZXQgcmV2ZXJ0ZWQgYmFjay5cbiAgICAgICAgLy8gYGNvbW1pdHRlZERhdGFgIGlzIHRoZSB2YWxpZGF0ZWQgdmFsdWUgdGhhdCBjb21lcyBmcm9tIGEgZmV0Y2ggb3IgbXV0YXRpb24uXG4gICAgICAgIGNvbnN0IGRpc3BsYXllZERhdGEgPSBzdGF0ZS5kYXRhO1xuICAgICAgICBjb25zdCBjdXJyZW50RGF0YSA9IHN0YXRlLl9jO1xuICAgICAgICBjb25zdCBjb21taXR0ZWREYXRhID0gaXNVbmRlZmluZWQoY3VycmVudERhdGEpID8gZGlzcGxheWVkRGF0YSA6IGN1cnJlbnREYXRhO1xuICAgICAgICAvLyBEbyBvcHRpbWlzdGljIGRhdGEgdXBkYXRlLlxuICAgICAgICBpZiAoaGFzT3B0aW1pc3RpY0RhdGEpIHtcbiAgICAgICAgICAgIG9wdGltaXN0aWNEYXRhID0gaXNGdW5jdGlvbihvcHRpbWlzdGljRGF0YSkgPyBvcHRpbWlzdGljRGF0YShjb21taXR0ZWREYXRhLCBkaXNwbGF5ZWREYXRhKSA6IG9wdGltaXN0aWNEYXRhO1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBzZXQgb3B0aW1pc3RpYyBkYXRhLCBiYWNrdXAgdGhlIGN1cnJlbnQgY29tbWl0dGVkRGF0YSBkYXRhIGluIGBfY2AuXG4gICAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgICAgIGRhdGE6IG9wdGltaXN0aWNEYXRhLFxuICAgICAgICAgICAgICAgIF9jOiBjb21taXR0ZWREYXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNGdW5jdGlvbihkYXRhKSkge1xuICAgICAgICAgICAgLy8gYGRhdGFgIGlzIGEgZnVuY3Rpb24sIGNhbGwgaXQgcGFzc2luZyBjdXJyZW50IGNhY2hlIHZhbHVlLlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkYXRhID0gZGF0YShjb21taXR0ZWREYXRhKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIC8vIElmIGl0IHRocm93cyBhbiBlcnJvciBzeW5jaHJvbm91c2x5LCB3ZSBzaG91bGRuJ3QgdXBkYXRlIHRoZSBjYWNoZS5cbiAgICAgICAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBgZGF0YWAgaXMgYSBwcm9taXNlL3RoZW5hYmxlLCByZXNvbHZlIHRoZSBmaW5hbCBkYXRhIGZpcnN0LlxuICAgICAgICBpZiAoZGF0YSAmJiBpc1Byb21pc2VMaWtlKGRhdGEpKSB7XG4gICAgICAgICAgICAvLyBUaGlzIG1lYW5zIHRoYXQgdGhlIG11dGF0aW9uIGlzIGFzeW5jLCB3ZSBuZWVkIHRvIGNoZWNrIHRpbWVzdGFtcHMgdG9cbiAgICAgICAgICAgIC8vIGF2b2lkIHJhY2UgY29uZGl0aW9ucy5cbiAgICAgICAgICAgIGRhdGEgPSBhd2FpdCBkYXRhLmNhdGNoKChlcnIpPT57XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIG90aGVyIG11dGF0aW9ucyBoYXZlIG9jY3VycmVkIHNpbmNlIHdlJ3ZlIHN0YXJ0ZWQgdGhpcyBtdXRhdGlvbi5cbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYSByYWNlIHdlIGRvbid0IHVwZGF0ZSBjYWNoZSBvciBicm9hZGNhc3QgdGhlIGNoYW5nZSxcbiAgICAgICAgICAgIC8vIGp1c3QgcmV0dXJuIHRoZSBkYXRhLlxuICAgICAgICAgICAgaWYgKGJlZm9yZU11dGF0aW9uVHMgIT09IE1VVEFUSU9OW2tleV1bMF0pIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlcnJvciAmJiBoYXNPcHRpbWlzdGljRGF0YSAmJiByb2xsYmFja09uRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgLy8gUm9sbGJhY2suIEFsd2F5cyBwb3B1bGF0ZSB0aGUgY2FjaGUgaW4gdGhpcyBjYXNlIGJ1dCB3aXRob3V0XG4gICAgICAgICAgICAgICAgLy8gdHJhbnNmb3JtaW5nIHRoZSBkYXRhLlxuICAgICAgICAgICAgICAgIHBvcHVsYXRlQ2FjaGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGRhdGEgPSBjb21taXR0ZWREYXRhO1xuICAgICAgICAgICAgICAgIC8vIFJlc2V0IGRhdGEgdG8gYmUgdGhlIGxhdGVzdCBjb21taXR0ZWQgZGF0YSwgYW5kIGNsZWFyIHRoZSBgX2NgIHZhbHVlLlxuICAgICAgICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIF9jOiBVTkRFRklORURcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBzaG91bGQgd3JpdGUgYmFjayB0aGUgY2FjaGUgYWZ0ZXIgcmVxdWVzdC5cbiAgICAgICAgaWYgKHBvcHVsYXRlQ2FjaGUpIHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBUcmFuc2Zvcm0gdGhlIHJlc3VsdCBpbnRvIGRhdGEuXG4gICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ocG9wdWxhdGVDYWNoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHBvcHVsYXRlQ2FjaGUoZGF0YSwgY29tbWl0dGVkRGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE9ubHkgdXBkYXRlIGNhY2hlZCBkYXRhIGFuZCByZXNldCB0aGUgZXJyb3IgaWYgdGhlcmUncyBubyBlcnJvci4gRGF0YSBjYW4gYmUgYHVuZGVmaW5lZGAgaGVyZS5cbiAgICAgICAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogVU5ERUZJTkVELFxuICAgICAgICAgICAgICAgICAgICBfYzogVU5ERUZJTkVEXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzZXQgdGhlIHRpbWVzdGFtcCB0byBtYXJrIHRoZSBtdXRhdGlvbiBoYXMgZW5kZWQuXG4gICAgICAgIE1VVEFUSU9OW2tleV1bMV0gPSBnZXRUaW1lc3RhbXAoKTtcbiAgICAgICAgLy8gVXBkYXRlIGV4aXN0aW5nIFNXUiBIb29rcycgaW50ZXJuYWwgc3RhdGVzOlxuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBzdGFydFJldmFsaWRhdGUoKTtcbiAgICAgICAgLy8gVGhlIG11dGF0aW9uIGFuZCByZXZhbGlkYXRpb24gYXJlIGVuZGVkLCB3ZSBjYW4gY2xlYXIgaXQgc2luY2UgdGhlIGRhdGEgaXNcbiAgICAgICAgLy8gbm90IGFuIG9wdGltaXN0aWMgdmFsdWUgYW55bW9yZS5cbiAgICAgICAgc2V0KHtcbiAgICAgICAgICAgIF9jOiBVTkRFRklORURcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRocm93IGVycm9yIG9yIHJldHVybiBkYXRhXG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKHRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcHVsYXRlQ2FjaGUgPyByZXMgOiBkYXRhO1xuICAgIH1cbn1cblxuY29uc3QgcmV2YWxpZGF0ZUFsbEtleXMgPSAocmV2YWxpZGF0b3JzLCB0eXBlKT0+e1xuICAgIGZvcihjb25zdCBrZXkgaW4gcmV2YWxpZGF0b3JzKXtcbiAgICAgICAgaWYgKHJldmFsaWRhdG9yc1trZXldWzBdKSByZXZhbGlkYXRvcnNba2V5XVswXSh0eXBlKTtcbiAgICB9XG59O1xuY29uc3QgaW5pdENhY2hlID0gKHByb3ZpZGVyLCBvcHRpb25zKT0+e1xuICAgIC8vIFRoZSBnbG9iYWwgc3RhdGUgZm9yIGEgc3BlY2lmaWMgcHJvdmlkZXIgd2lsbCBiZSB1c2VkIHRvIGRlZHVwbGljYXRlXG4gICAgLy8gcmVxdWVzdHMgYW5kIHN0b3JlIGxpc3RlbmVycy4gQXMgd2VsbCBhcyBhIG11dGF0ZSBmdW5jdGlvbiB0aGF0IGlzIGJvdW5kIHRvXG4gICAgLy8gdGhlIGNhY2hlLlxuICAgIC8vIFRoZSBwcm92aWRlcidzIGdsb2JhbCBzdGF0ZSBtaWdodCBiZSBhbHJlYWR5IGluaXRpYWxpemVkLiBMZXQncyB0cnkgdG8gZ2V0IHRoZVxuICAgIC8vIGdsb2JhbCBzdGF0ZSBhc3NvY2lhdGVkIHdpdGggdGhlIHByb3ZpZGVyIGZpcnN0LlxuICAgIGlmICghU1dSR2xvYmFsU3RhdGUuaGFzKHByb3ZpZGVyKSkge1xuICAgICAgICBjb25zdCBvcHRzID0gbWVyZ2VPYmplY3RzKGRlZmF1bHRDb25maWdPcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgLy8gSWYgdGhlcmUncyBubyBnbG9iYWwgc3RhdGUgYm91bmQgdG8gdGhlIHByb3ZpZGVyLCBjcmVhdGUgYSBuZXcgb25lIHdpdGggdGhlXG4gICAgICAgIC8vIG5ldyBtdXRhdGUgZnVuY3Rpb24uXG4gICAgICAgIGNvbnN0IEVWRU5UX1JFVkFMSURBVE9SUyA9IHt9O1xuICAgICAgICBjb25zdCBtdXRhdGUgPSBpbnRlcm5hbE11dGF0ZS5iaW5kKFVOREVGSU5FRCwgcHJvdmlkZXIpO1xuICAgICAgICBsZXQgdW5tb3VudCA9IG5vb3A7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSB7fTtcbiAgICAgICAgY29uc3Qgc3Vic2NyaWJlID0gKGtleSwgY2FsbGJhY2spPT57XG4gICAgICAgICAgICBjb25zdCBzdWJzID0gc3Vic2NyaXB0aW9uc1trZXldIHx8IFtdO1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uc1trZXldID0gc3VicztcbiAgICAgICAgICAgIHN1YnMucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICByZXR1cm4gKCk9PnN1YnMuc3BsaWNlKHN1YnMuaW5kZXhPZihjYWxsYmFjayksIDEpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzZXR0ZXIgPSAoa2V5LCB2YWx1ZSwgcHJldik9PntcbiAgICAgICAgICAgIHByb3ZpZGVyLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IHN1YnMgPSBzdWJzY3JpcHRpb25zW2tleV07XG4gICAgICAgICAgICBpZiAoc3Vicykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZm4gb2Ygc3Vicyl7XG4gICAgICAgICAgICAgICAgICAgIGZuKHZhbHVlLCBwcmV2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGluaXRQcm92aWRlciA9ICgpPT57XG4gICAgICAgICAgICBpZiAoIVNXUkdsb2JhbFN0YXRlLmhhcyhwcm92aWRlcikpIHtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHN0YXRlIGlmIGl0J3MgbmV3LCBvciBpZiB0aGUgcHJvdmlkZXIgaGFzIGJlZW4gZXh0ZW5kZWQuXG4gICAgICAgICAgICAgICAgU1dSR2xvYmFsU3RhdGUuc2V0KHByb3ZpZGVyLCBbXG4gICAgICAgICAgICAgICAgICAgIEVWRU5UX1JFVkFMSURBVE9SUyxcbiAgICAgICAgICAgICAgICAgICAge30sXG4gICAgICAgICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAgICAgICB7fSxcbiAgICAgICAgICAgICAgICAgICAgbXV0YXRlLFxuICAgICAgICAgICAgICAgICAgICBzZXR0ZXIsXG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZVxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIGlmICghSVNfU0VSVkVSKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gbGlzdGVuaW5nIHRvIHRoZSBuYXRpdmUgZXZlbnRzIGZvciBhdXRvIHJldmFsaWRhdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGludGVudGlvbmFsbHkgcHV0IGEgZGVsYXkgKHNldFRpbWVvdXQpIGhlcmUgdG8gbWFrZSBzdXJlIHRoZXkgYXJlXG4gICAgICAgICAgICAgICAgICAgIC8vIGZpcmVkIGFmdGVyIGltbWVkaWF0ZSBKYXZhU2NyaXB0IGV4ZWN1dGlvbnMsIHdoaWNoIGNhbiBiZVxuICAgICAgICAgICAgICAgICAgICAvLyBSZWFjdCdzIHN0YXRlIHVwZGF0ZXMuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgYXZvaWRzIHNvbWUgdW5uZWNlc3NhcnkgcmV2YWxpZGF0aW9ucyBzdWNoIGFzXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvc3dyL2lzc3Vlcy8xNjgwLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWxlYXNlRm9jdXMgPSBvcHRzLmluaXRGb2N1cyhzZXRUaW1lb3V0LmJpbmQoVU5ERUZJTkVELCByZXZhbGlkYXRlQWxsS2V5cy5iaW5kKFVOREVGSU5FRCwgRVZFTlRfUkVWQUxJREFUT1JTLCBGT0NVU19FVkVOVCkpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVsZWFzZVJlY29ubmVjdCA9IG9wdHMuaW5pdFJlY29ubmVjdChzZXRUaW1lb3V0LmJpbmQoVU5ERUZJTkVELCByZXZhbGlkYXRlQWxsS2V5cy5iaW5kKFVOREVGSU5FRCwgRVZFTlRfUkVWQUxJREFUT1JTLCBSRUNPTk5FQ1RfRVZFTlQpKSk7XG4gICAgICAgICAgICAgICAgICAgIHVubW91bnQgPSAoKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVsZWFzZUZvY3VzICYmIHJlbGVhc2VGb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVsZWFzZVJlY29ubmVjdCAmJiByZWxlYXNlUmVjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHVuLW1vdW50aW5nLCB3ZSBuZWVkIHRvIHJlbW92ZSB0aGUgY2FjaGUgcHJvdmlkZXIgZnJvbSB0aGUgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0b3JhZ2UgdG9vIGJlY2F1c2UgaXQncyBhIHNpZGUtZWZmZWN0LiBPdGhlcndpc2UsIHdoZW4gcmUtbW91bnRpbmcgd2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpbGwgbm90IHJlLXJlZ2lzdGVyIHRob3NlIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgICAgICAgICAgICAgICAgICAgIFNXUkdsb2JhbFN0YXRlLmRlbGV0ZShwcm92aWRlcik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpbml0UHJvdmlkZXIoKTtcbiAgICAgICAgLy8gVGhpcyBpcyBhIG5ldyBwcm92aWRlciwgd2UgbmVlZCB0byBpbml0aWFsaXplIGl0IGFuZCBzZXR1cCBET00gZXZlbnRzXG4gICAgICAgIC8vIGxpc3RlbmVycyBmb3IgYGZvY3VzYCBhbmQgYHJlY29ubmVjdGAgYWN0aW9ucy5cbiAgICAgICAgLy8gV2UgbWlnaHQgd2FudCB0byBpbmplY3QgYW4gZXh0cmEgbGF5ZXIgb24gdG9wIG9mIGBwcm92aWRlcmAgaW4gdGhlIGZ1dHVyZSxcbiAgICAgICAgLy8gc3VjaCBhcyBrZXkgc2VyaWFsaXphdGlvbiwgYXV0byBHQywgZXRjLlxuICAgICAgICAvLyBGb3Igbm93LCBpdCdzIGp1c3QgYSBgTWFwYCBpbnRlcmZhY2Ugd2l0aG91dCBhbnkgbW9kaWZpY2F0aW9ucy5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHByb3ZpZGVyLFxuICAgICAgICAgICAgbXV0YXRlLFxuICAgICAgICAgICAgaW5pdFByb3ZpZGVyLFxuICAgICAgICAgICAgdW5tb3VudFxuICAgICAgICBdO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgICBwcm92aWRlcixcbiAgICAgICAgU1dSR2xvYmFsU3RhdGUuZ2V0KHByb3ZpZGVyKVs0XVxuICAgIF07XG59O1xuXG4vLyBlcnJvciByZXRyeVxuY29uc3Qgb25FcnJvclJldHJ5ID0gKF8sIF9fLCBjb25maWcsIHJldmFsaWRhdGUsIG9wdHMpPT57XG4gICAgY29uc3QgbWF4UmV0cnlDb3VudCA9IGNvbmZpZy5lcnJvclJldHJ5Q291bnQ7XG4gICAgY29uc3QgY3VycmVudFJldHJ5Q291bnQgPSBvcHRzLnJldHJ5Q291bnQ7XG4gICAgLy8gRXhwb25lbnRpYWwgYmFja29mZlxuICAgIGNvbnN0IHRpbWVvdXQgPSB+figoTWF0aC5yYW5kb20oKSArIDAuNSkgKiAoMSA8PCAoY3VycmVudFJldHJ5Q291bnQgPCA4ID8gY3VycmVudFJldHJ5Q291bnQgOiA4KSkpICogY29uZmlnLmVycm9yUmV0cnlJbnRlcnZhbDtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKG1heFJldHJ5Q291bnQpICYmIGN1cnJlbnRSZXRyeUNvdW50ID4gbWF4UmV0cnlDb3VudCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHNldFRpbWVvdXQocmV2YWxpZGF0ZSwgdGltZW91dCwgb3B0cyk7XG59O1xuY29uc3QgY29tcGFyZSA9IChjdXJyZW50RGF0YSwgbmV3RGF0YSk9PnN0YWJsZUhhc2goY3VycmVudERhdGEpID09IHN0YWJsZUhhc2gobmV3RGF0YSk7XG4vLyBEZWZhdWx0IGNhY2hlIHByb3ZpZGVyXG5jb25zdCBbY2FjaGUsIG11dGF0ZV0gPSBpbml0Q2FjaGUobmV3IE1hcCgpKTtcbi8vIERlZmF1bHQgY29uZmlnXG5jb25zdCBkZWZhdWx0Q29uZmlnID0gbWVyZ2VPYmplY3RzKHtcbiAgICAvLyBldmVudHNcbiAgICBvbkxvYWRpbmdTbG93OiBub29wLFxuICAgIG9uU3VjY2Vzczogbm9vcCxcbiAgICBvbkVycm9yOiBub29wLFxuICAgIG9uRXJyb3JSZXRyeSxcbiAgICBvbkRpc2NhcmRlZDogbm9vcCxcbiAgICAvLyBzd2l0Y2hlc1xuICAgIHJldmFsaWRhdGVPbkZvY3VzOiB0cnVlLFxuICAgIHJldmFsaWRhdGVPblJlY29ubmVjdDogdHJ1ZSxcbiAgICByZXZhbGlkYXRlSWZTdGFsZTogdHJ1ZSxcbiAgICBzaG91bGRSZXRyeU9uRXJyb3I6IHRydWUsXG4gICAgLy8gdGltZW91dHNcbiAgICBlcnJvclJldHJ5SW50ZXJ2YWw6IHNsb3dDb25uZWN0aW9uID8gMTAwMDAgOiA1MDAwLFxuICAgIGZvY3VzVGhyb3R0bGVJbnRlcnZhbDogNSAqIDEwMDAsXG4gICAgZGVkdXBpbmdJbnRlcnZhbDogMiAqIDEwMDAsXG4gICAgbG9hZGluZ1RpbWVvdXQ6IHNsb3dDb25uZWN0aW9uID8gNTAwMCA6IDMwMDAsXG4gICAgLy8gcHJvdmlkZXJzXG4gICAgY29tcGFyZSxcbiAgICBpc1BhdXNlZDogKCk9PmZhbHNlLFxuICAgIGNhY2hlLFxuICAgIG11dGF0ZSxcbiAgICBmYWxsYmFjazoge31cbn0sIC8vIHVzZSB3ZWIgcHJlc2V0IGJ5IGRlZmF1bHRcbnByZXNldCk7XG5cbmNvbnN0IG1lcmdlQ29uZmlncyA9IChhLCBiKT0+e1xuICAgIC8vIE5lZWQgdG8gY3JlYXRlIGEgbmV3IG9iamVjdCB0byBhdm9pZCBtdXRhdGluZyB0aGUgb3JpZ2luYWwgaGVyZS5cbiAgICBjb25zdCB2ID0gbWVyZ2VPYmplY3RzKGEsIGIpO1xuICAgIC8vIElmIHR3byBjb25maWdzIGFyZSBwcm92aWRlZCwgbWVyZ2UgdGhlaXIgYHVzZWAgYW5kIGBmYWxsYmFja2Agb3B0aW9ucy5cbiAgICBpZiAoYikge1xuICAgICAgICBjb25zdCB7IHVzZTogdTEgLCBmYWxsYmFjazogZjEgIH0gPSBhO1xuICAgICAgICBjb25zdCB7IHVzZTogdTIgLCBmYWxsYmFjazogZjIgIH0gPSBiO1xuICAgICAgICBpZiAodTEgJiYgdTIpIHtcbiAgICAgICAgICAgIHYudXNlID0gdTEuY29uY2F0KHUyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZjEgJiYgZjIpIHtcbiAgICAgICAgICAgIHYuZmFsbGJhY2sgPSBtZXJnZU9iamVjdHMoZjEsIGYyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdjtcbn07XG5cbmNvbnN0IFNXUkNvbmZpZ0NvbnRleHQgPSBjcmVhdGVDb250ZXh0KHt9KTtcbmNvbnN0IFNXUkNvbmZpZyA9IChwcm9wcyk9PntcbiAgICBjb25zdCB7IHZhbHVlICB9ID0gcHJvcHM7XG4gICAgY29uc3QgcGFyZW50Q29uZmlnID0gdXNlQ29udGV4dChTV1JDb25maWdDb250ZXh0KTtcbiAgICBjb25zdCBpc0Z1bmN0aW9uYWxDb25maWcgPSBpc0Z1bmN0aW9uKHZhbHVlKTtcbiAgICBjb25zdCBjb25maWcgPSB1c2VNZW1vKCgpPT5pc0Z1bmN0aW9uYWxDb25maWcgPyB2YWx1ZShwYXJlbnRDb25maWcpIDogdmFsdWUsIFtcbiAgICAgICAgaXNGdW5jdGlvbmFsQ29uZmlnLFxuICAgICAgICBwYXJlbnRDb25maWcsXG4gICAgICAgIHZhbHVlXG4gICAgXSk7XG4gICAgLy8gRXh0ZW5kIHBhcmVudCBjb250ZXh0IHZhbHVlcyBhbmQgbWlkZGxld2FyZS5cbiAgICBjb25zdCBleHRlbmRlZENvbmZpZyA9IHVzZU1lbW8oKCk9PmlzRnVuY3Rpb25hbENvbmZpZyA/IGNvbmZpZyA6IG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNvbmZpZyksIFtcbiAgICAgICAgaXNGdW5jdGlvbmFsQ29uZmlnLFxuICAgICAgICBwYXJlbnRDb25maWcsXG4gICAgICAgIGNvbmZpZ1xuICAgIF0pO1xuICAgIC8vIFNob3VsZCBub3QgdXNlIHRoZSBpbmhlcml0ZWQgcHJvdmlkZXIuXG4gICAgY29uc3QgcHJvdmlkZXIgPSBjb25maWcgJiYgY29uZmlnLnByb3ZpZGVyO1xuICAgIC8vIGluaXRpYWxpemUgdGhlIGNhY2hlIG9ubHkgb24gZmlyc3QgYWNjZXNzLlxuICAgIGNvbnN0IGNhY2hlQ29udGV4dFJlZiA9IHVzZVJlZihVTkRFRklORUQpO1xuICAgIGlmIChwcm92aWRlciAmJiAhY2FjaGVDb250ZXh0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY2FjaGVDb250ZXh0UmVmLmN1cnJlbnQgPSBpbml0Q2FjaGUocHJvdmlkZXIoZXh0ZW5kZWRDb25maWcuY2FjaGUgfHwgY2FjaGUpLCBjb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBjYWNoZUNvbnRleHQgPSBjYWNoZUNvbnRleHRSZWYuY3VycmVudDtcbiAgICAvLyBPdmVycmlkZSB0aGUgY2FjaGUgaWYgYSBuZXcgcHJvdmlkZXIgaXMgZ2l2ZW4uXG4gICAgaWYgKGNhY2hlQ29udGV4dCkge1xuICAgICAgICBleHRlbmRlZENvbmZpZy5jYWNoZSA9IGNhY2hlQ29udGV4dFswXTtcbiAgICAgICAgZXh0ZW5kZWRDb25maWcubXV0YXRlID0gY2FjaGVDb250ZXh0WzFdO1xuICAgIH1cbiAgICAvLyBVbnN1YnNjcmliZSBldmVudHMuXG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKT0+e1xuICAgICAgICBpZiAoY2FjaGVDb250ZXh0KSB7XG4gICAgICAgICAgICBjYWNoZUNvbnRleHRbMl0gJiYgY2FjaGVDb250ZXh0WzJdKCk7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVDb250ZXh0WzNdO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KFNXUkNvbmZpZ0NvbnRleHQuUHJvdmlkZXIsIG1lcmdlT2JqZWN0cyhwcm9wcywge1xuICAgICAgICB2YWx1ZTogZXh0ZW5kZWRDb25maWdcbiAgICB9KSk7XG59O1xuXG4vLyBAdHMtZXhwZWN0LWVycm9yXG5jb25zdCBlbmFibGVEZXZ0b29scyA9IGlzV2luZG93RGVmaW5lZCAmJiB3aW5kb3cuX19TV1JfREVWVE9PTFNfVVNFX187XG5jb25zdCB1c2UgPSBlbmFibGVEZXZ0b29scyA/IHdpbmRvdy5fX1NXUl9ERVZUT09MU19VU0VfXyA6IFtdO1xuY29uc3Qgc2V0dXBEZXZUb29scyA9ICgpPT57XG4gICAgaWYgKGVuYWJsZURldnRvb2xzKSB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgd2luZG93Ll9fU1dSX0RFVlRPT0xTX1JFQUNUX18gPSBSZWFjdDtcbiAgICB9XG59O1xuXG5jb25zdCBub3JtYWxpemUgPSAoYXJncyk9PntcbiAgICByZXR1cm4gaXNGdW5jdGlvbihhcmdzWzFdKSA/IFtcbiAgICAgICAgYXJnc1swXSxcbiAgICAgICAgYXJnc1sxXSxcbiAgICAgICAgYXJnc1syXSB8fCB7fVxuICAgIF0gOiBbXG4gICAgICAgIGFyZ3NbMF0sXG4gICAgICAgIG51bGwsXG4gICAgICAgIChhcmdzWzFdID09PSBudWxsID8gYXJnc1syXSA6IGFyZ3NbMV0pIHx8IHt9XG4gICAgXTtcbn07XG5cbmNvbnN0IHVzZVNXUkNvbmZpZyA9ICgpPT57XG4gICAgcmV0dXJuIG1lcmdlT2JqZWN0cyhkZWZhdWx0Q29uZmlnLCB1c2VDb250ZXh0KFNXUkNvbmZpZ0NvbnRleHQpKTtcbn07XG5cbmNvbnN0IHByZWxvYWQgPSAoa2V5XywgZmV0Y2hlcik9PntcbiAgICBjb25zdCBba2V5LCBmbkFyZ10gPSBzZXJpYWxpemUoa2V5Xyk7XG4gICAgY29uc3QgWywgLCAsIFBSRUxPQURdID0gU1dSR2xvYmFsU3RhdGUuZ2V0KGNhY2hlKTtcbiAgICAvLyBQcmV2ZW50IHByZWxvYWQgdG8gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIGJlZm9yZSB1c2VkLlxuICAgIGlmIChQUkVMT0FEW2tleV0pIHJldHVybiBQUkVMT0FEW2tleV07XG4gICAgY29uc3QgcmVxID0gZmV0Y2hlcihmbkFyZyk7XG4gICAgUFJFTE9BRFtrZXldID0gcmVxO1xuICAgIHJldHVybiByZXE7XG59O1xuY29uc3QgbWlkZGxld2FyZSA9ICh1c2VTV1JOZXh0KT0+KGtleV8sIGZldGNoZXJfLCBjb25maWcpPT57XG4gICAgICAgIC8vIGZldGNoZXIgbWlnaHQgYmUgYSBzeW5jIGZ1bmN0aW9uLCBzbyB0aGlzIHNob3VsZCBub3QgYmUgYW4gYXN5bmMgZnVuY3Rpb25cbiAgICAgICAgY29uc3QgZmV0Y2hlciA9IGZldGNoZXJfICYmICgoLi4uYXJncyk9PntcbiAgICAgICAgICAgIGNvbnN0IFtrZXldID0gc2VyaWFsaXplKGtleV8pO1xuICAgICAgICAgICAgY29uc3QgWywgLCAsIFBSRUxPQURdID0gU1dSR2xvYmFsU3RhdGUuZ2V0KGNhY2hlKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcSA9IFBSRUxPQURba2V5XTtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChyZXEpKSByZXR1cm4gZmV0Y2hlcl8oLi4uYXJncyk7XG4gICAgICAgICAgICBkZWxldGUgUFJFTE9BRFtrZXldO1xuICAgICAgICAgICAgcmV0dXJuIHJlcTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB1c2VTV1JOZXh0KGtleV8sIGZldGNoZXIsIGNvbmZpZyk7XG4gICAgfTtcblxuY29uc3QgQlVJTFRfSU5fTUlERExFV0FSRSA9IHVzZS5jb25jYXQobWlkZGxld2FyZSk7XG5cbi8vIEl0J3MgdHJpY2t5IHRvIHBhc3MgZ2VuZXJpYyB0eXBlcyBhcyBwYXJhbWV0ZXJzLCBzbyB3ZSBqdXN0IGRpcmVjdGx5IG92ZXJyaWRlXG4vLyB0aGUgdHlwZXMgaGVyZS5cbmNvbnN0IHdpdGhBcmdzID0gKGhvb2spPT57XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVzZVNXUkFyZ3MoLi4uYXJncykge1xuICAgICAgICAvLyBHZXQgdGhlIGRlZmF1bHQgYW5kIGluaGVyaXRlZCBjb25maWd1cmF0aW9uLlxuICAgICAgICBjb25zdCBmYWxsYmFja0NvbmZpZyA9IHVzZVNXUkNvbmZpZygpO1xuICAgICAgICAvLyBOb3JtYWxpemUgYXJndW1lbnRzLlxuICAgICAgICBjb25zdCBba2V5LCBmbiwgX2NvbmZpZ10gPSBub3JtYWxpemUoYXJncyk7XG4gICAgICAgIC8vIE1lcmdlIGNvbmZpZ3VyYXRpb25zLlxuICAgICAgICBjb25zdCBjb25maWcgPSBtZXJnZUNvbmZpZ3MoZmFsbGJhY2tDb25maWcsIF9jb25maWcpO1xuICAgICAgICAvLyBBcHBseSBtaWRkbGV3YXJlXG4gICAgICAgIGxldCBuZXh0ID0gaG9vaztcbiAgICAgICAgY29uc3QgeyB1c2UgIH0gPSBjb25maWc7XG4gICAgICAgIGNvbnN0IG1pZGRsZXdhcmUgPSAodXNlIHx8IFtdKS5jb25jYXQoQlVJTFRfSU5fTUlERExFV0FSRSk7XG4gICAgICAgIGZvcihsZXQgaSA9IG1pZGRsZXdhcmUubGVuZ3RoOyBpLS07KXtcbiAgICAgICAgICAgIG5leHQgPSBtaWRkbGV3YXJlW2ldKG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXh0KGtleSwgZm4gfHwgY29uZmlnLmZldGNoZXIgfHwgbnVsbCwgY29uZmlnKTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBzdGF0ZSB3aXRoIGRlcGVuZGVuY3ktdHJhY2tpbmcuXG4gKi8gY29uc3QgdXNlU3RhdGVXaXRoRGVwcyA9IChzdGF0ZSk9PntcbiAgICBjb25zdCByZXJlbmRlciA9IHVzZVN0YXRlKHt9KVsxXTtcbiAgICBjb25zdCB1bm1vdW50ZWRSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICAgIGNvbnN0IHN0YXRlUmVmID0gdXNlUmVmKHN0YXRlKTtcbiAgICAvLyBJZiBhIHN0YXRlIHByb3BlcnR5IChkYXRhLCBlcnJvciwgb3IgaXNWYWxpZGF0aW5nKSBpcyBhY2Nlc3NlZCBieSB0aGUgcmVuZGVyXG4gICAgLy8gZnVuY3Rpb24sIHdlIG1hcmsgdGhlIHByb3BlcnR5IGFzIGEgZGVwZW5kZW5jeSBzbyBpZiBpdCBpcyB1cGRhdGVkIGFnYWluXG4gICAgLy8gaW4gdGhlIGZ1dHVyZSwgd2UgdHJpZ2dlciBhIHJlcmVuZGVyLlxuICAgIC8vIFRoaXMgaXMgYWxzbyBrbm93biBhcyBkZXBlbmRlbmN5LXRyYWNraW5nLlxuICAgIGNvbnN0IHN0YXRlRGVwZW5kZW5jaWVzUmVmID0gdXNlUmVmKHtcbiAgICAgICAgZGF0YTogZmFsc2UsXG4gICAgICAgIGVycm9yOiBmYWxzZSxcbiAgICAgICAgaXNWYWxpZGF0aW5nOiBmYWxzZVxuICAgIH0pO1xuICAgIC8qKlxuICAgKiBAcGFyYW0gcGF5bG9hZCBUbyBjaGFuZ2Ugc3RhdGVSZWYsIHBhc3MgdGhlIHZhbHVlcyBleHBsaWNpdGx5IHRvIHNldFN0YXRlOlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBzZXRTdGF0ZSh7XG4gICAqICAgaXNWYWxpZGF0aW5nOiBmYWxzZVxuICAgKiAgIGRhdGE6IG5ld0RhdGEgLy8gc2V0IGRhdGEgdG8gbmV3RGF0YVxuICAgKiAgIGVycm9yOiB1bmRlZmluZWQgLy8gc2V0IGVycm9yIHRvIHVuZGVmaW5lZFxuICAgKiB9KVxuICAgKlxuICAgKiBzZXRTdGF0ZSh7XG4gICAqICAgaXNWYWxpZGF0aW5nOiBmYWxzZVxuICAgKiAgIGRhdGE6IHVuZGVmaW5lZCAvLyBzZXQgZGF0YSB0byB1bmRlZmluZWRcbiAgICogICBlcnJvcjogZXJyIC8vIHNldCBlcnJvciB0byBlcnJcbiAgICogfSlcbiAgICogYGBgXG4gICAqLyBjb25zdCBzZXRTdGF0ZSA9IHVzZUNhbGxiYWNrKChwYXlsb2FkKT0+e1xuICAgICAgICBsZXQgc2hvdWxkUmVyZW5kZXIgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgY3VycmVudFN0YXRlID0gc3RhdGVSZWYuY3VycmVudDtcbiAgICAgICAgZm9yKGNvbnN0IF8gaW4gcGF5bG9hZCl7XG4gICAgICAgICAgICBjb25zdCBrID0gXztcbiAgICAgICAgICAgIC8vIElmIHRoZSBwcm9wZXJ0eSBoYXMgY2hhbmdlZCwgdXBkYXRlIHRoZSBzdGF0ZSBhbmQgbWFyayByZXJlbmRlciBhc1xuICAgICAgICAgICAgLy8gbmVlZGVkLlxuICAgICAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZVtrXSAhPT0gcGF5bG9hZFtrXSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZVtrXSA9IHBheWxvYWRba107XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHByb3BlcnR5IGlzIGFjY2Vzc2VkIGJ5IHRoZSBjb21wb25lbnQsIGEgcmVyZW5kZXIgc2hvdWxkIGJlXG4gICAgICAgICAgICAgICAgLy8gdHJpZ2dlcmVkLlxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZURlcGVuZGVuY2llc1JlZi5jdXJyZW50W2tdKSB7XG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFJlcmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZFJlcmVuZGVyICYmICF1bm1vdW50ZWRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgaWYgKElTX1JFQUNUX0xFR0FDWSkge1xuICAgICAgICAgICAgICAgIHJlcmVuZGVyKHt9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgUmVhY3Quc3RhcnRUcmFuc2l0aW9uKCgpPT5yZXJlbmRlcih7fSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICByZXJlbmRlclxuICAgIF0pO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCk9PntcbiAgICAgICAgdW5tb3VudGVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICB1bm1vdW50ZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgc3RhdGVSZWYsXG4gICAgICAgIHN0YXRlRGVwZW5kZW5jaWVzUmVmLmN1cnJlbnQsXG4gICAgICAgIHNldFN0YXRlXG4gICAgXTtcbn07XG5cbi8vIEFkZCBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGEgbGlzdCBvZiBrZXllZCBjYWxsYmFjayBmdW5jdGlvbnMgYW5kIHJldHVyblxuLy8gdGhlIHVuc3Vic2NyaWJlIGZ1bmN0aW9uLlxuY29uc3Qgc3Vic2NyaWJlQ2FsbGJhY2sgPSAoa2V5LCBjYWxsYmFja3MsIGNhbGxiYWNrKT0+e1xuICAgIGNvbnN0IGtleWVkUmV2YWxpZGF0b3JzID0gY2FsbGJhY2tzW2tleV0gfHwgKGNhbGxiYWNrc1trZXldID0gW10pO1xuICAgIGtleWVkUmV2YWxpZGF0b3JzLnB1c2goY2FsbGJhY2spO1xuICAgIHJldHVybiAoKT0+e1xuICAgICAgICBjb25zdCBpbmRleCA9IGtleWVkUmV2YWxpZGF0b3JzLmluZGV4T2YoY2FsbGJhY2spO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgLy8gTygxKTogZmFzdGVyIHRoYW4gc3BsaWNlXG4gICAgICAgICAgICBrZXllZFJldmFsaWRhdG9yc1tpbmRleF0gPSBrZXllZFJldmFsaWRhdG9yc1trZXllZFJldmFsaWRhdG9ycy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGtleWVkUmV2YWxpZGF0b3JzLnBvcCgpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbi8vIENyZWF0ZSBhIGN1c3RvbSBob29rIHdpdGggYSBtaWRkbGV3YXJlXG5jb25zdCB3aXRoTWlkZGxld2FyZSA9ICh1c2VTV1IsIG1pZGRsZXdhcmUpPT57XG4gICAgcmV0dXJuICguLi5hcmdzKT0+e1xuICAgICAgICBjb25zdCBba2V5LCBmbiwgY29uZmlnXSA9IG5vcm1hbGl6ZShhcmdzKTtcbiAgICAgICAgY29uc3QgdXNlcyA9IChjb25maWcudXNlIHx8IFtdKS5jb25jYXQobWlkZGxld2FyZSk7XG4gICAgICAgIHJldHVybiB1c2VTV1Ioa2V5LCBmbiwge1xuICAgICAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICAgICAgdXNlOiB1c2VzXG4gICAgICAgIH0pO1xuICAgIH07XG59O1xuXG5zZXR1cERldlRvb2xzKCk7XG5cbmV4cG9ydCB7IElTX1JFQUNUX0xFR0FDWSwgSVNfU0VSVkVSLCBPQkpFQ1QsIFNXUkNvbmZpZywgU1dSR2xvYmFsU3RhdGUsIFVOREVGSU5FRCwgY2FjaGUsIGNvbXBhcmUsIGNyZWF0ZUNhY2hlSGVscGVyLCBkZWZhdWx0Q29uZmlnLCBkZWZhdWx0Q29uZmlnT3B0aW9ucywgZ2V0VGltZXN0YW1wLCBoYXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIGluaXRDYWNoZSwgaW50ZXJuYWxNdXRhdGUsIGlzRG9jdW1lbnREZWZpbmVkLCBpc0Z1bmN0aW9uLCBpc1Byb21pc2VMaWtlLCBpc1VuZGVmaW5lZCwgaXNXaW5kb3dEZWZpbmVkLCBtZXJnZUNvbmZpZ3MsIG1lcmdlT2JqZWN0cywgbXV0YXRlLCBub29wLCBub3JtYWxpemUsIHByZWxvYWQsIHByZXNldCwgckFGLCBjb25zdGFudHMgYXMgcmV2YWxpZGF0ZUV2ZW50cywgc2VyaWFsaXplLCBzbG93Q29ubmVjdGlvbiwgc3RhYmxlSGFzaCwgc3Vic2NyaWJlQ2FsbGJhY2ssIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QsIHVzZVNXUkNvbmZpZywgdXNlU3RhdGVXaXRoRGVwcywgd2l0aEFyZ3MsIHdpdGhNaWRkbGV3YXJlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/swr/_internal/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/swr/core/dist/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/swr/core/dist/index.mjs ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SWRConfig: function() { return /* binding */ SWRConfig; },\n/* harmony export */   \"default\": function() { return /* binding */ useSWR; },\n/* harmony export */   mutate: function() { return /* reexport safe */ swr_internal__WEBPACK_IMPORTED_MODULE_2__.mutate; },\n/* harmony export */   preload: function() { return /* reexport safe */ swr_internal__WEBPACK_IMPORTED_MODULE_2__.preload; },\n/* harmony export */   unstable_serialize: function() { return /* binding */ unstable_serialize; },\n/* harmony export */   useSWRConfig: function() { return /* reexport safe */ swr_internal__WEBPACK_IMPORTED_MODULE_2__.useSWRConfig; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! use-sync-external-store/shim/index.js */ \"(app-pages-browser)/./node_modules/use-sync-external-store/shim/index.js\");\n/* harmony import */ var swr_internal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! swr/_internal */ \"(app-pages-browser)/./node_modules/swr/_internal/dist/index.mjs\");\n\n\n\n\n\nconst unstable_serialize = (key)=>(0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.serialize)(key)[0];\n\n/// <reference types=\"react/experimental\" />\nconst use = react__WEBPACK_IMPORTED_MODULE_0__.use || ((promise)=>{\n    if (promise.status === 'pending') {\n        throw promise;\n    } else if (promise.status === 'fulfilled') {\n        return promise.value;\n    } else if (promise.status === 'rejected') {\n        throw promise.reason;\n    } else {\n        promise.status = 'pending';\n        promise.then((v)=>{\n            promise.status = 'fulfilled';\n            promise.value = v;\n        }, (e)=>{\n            promise.status = 'rejected';\n            promise.reason = e;\n        });\n        throw promise;\n    }\n});\nconst WITH_DEDUPE = {\n    dedupe: true\n};\nconst useSWRHandler = (_key, fetcher, config)=>{\n    const { cache , compare , suspense , fallbackData , revalidateOnMount , revalidateIfStale , refreshInterval , refreshWhenHidden , refreshWhenOffline , keepPreviousData  } = config;\n    const [EVENT_REVALIDATORS, MUTATION, FETCH, PRELOAD] = swr_internal__WEBPACK_IMPORTED_MODULE_2__.SWRGlobalState.get(cache);\n    // `key` is the identifier of the SWR internal state,\n    // `fnArg` is the argument/arguments parsed from the key, which will be passed\n    // to the fetcher.\n    // All of them are derived from `_key`.\n    const [key, fnArg] = (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.serialize)(_key);\n    // If it's the initial render of this hook.\n    const initialMountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // If the hook is unmounted already. This will be used to prevent some effects\n    // to be called after unmounting.\n    const unmountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // Refs to keep the key and config.\n    const keyRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(key);\n    const fetcherRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(fetcher);\n    const configRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(config);\n    const getConfig = ()=>configRef.current;\n    const isActive = ()=>getConfig().isVisible() && getConfig().isOnline();\n    const [getCache, setCache, subscribeCache, getInitialCache] = (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.createCacheHelper)(cache, key);\n    const stateDependencies = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({}).current;\n    const fallback = (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(fallbackData) ? config.fallback[key] : fallbackData;\n    const isEqual = (prev, current)=>{\n        for(const _ in stateDependencies){\n            const t = _;\n            if (t === 'data') {\n                if (!compare(prev[t], current[t])) {\n                    if (!(0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(prev[t])) {\n                        return false;\n                    }\n                    if (!compare(returnedData, current[t])) {\n                        return false;\n                    }\n                }\n            } else {\n                if (current[t] !== prev[t]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    };\n    const getSnapshot = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        const shouldStartRequest = (()=>{\n            if (!key) return false;\n            if (!fetcher) return false;\n            // If `revalidateOnMount` is set, we take the value directly.\n            if (!(0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(revalidateOnMount)) return revalidateOnMount;\n            // If it's paused, we skip revalidation.\n            if (getConfig().isPaused()) return false;\n            if (suspense) return false;\n            if (!(0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(revalidateIfStale)) return revalidateIfStale;\n            return true;\n        })();\n        // Get the cache and merge it with expected states.\n        const getSelectedCache = (state)=>{\n            // We only select the needed fields from the state.\n            const snapshot = (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.mergeObjects)(state);\n            delete snapshot._k;\n            if (!shouldStartRequest) {\n                return snapshot;\n            }\n            return {\n                isValidating: true,\n                isLoading: true,\n                ...snapshot\n            };\n        };\n        const cachedData = getCache();\n        const initialData = getInitialCache();\n        const clientSnapshot = getSelectedCache(cachedData);\n        const serverSnapshot = cachedData === initialData ? clientSnapshot : getSelectedCache(initialData);\n        // To make sure that we are returning the same object reference to avoid\n        // unnecessary re-renders, we keep the previous snapshot and use deep\n        // comparison to check if we need to return a new one.\n        let memorizedSnapshot = clientSnapshot;\n        return [\n            ()=>{\n                const newSnapshot = getSelectedCache(getCache());\n                const compareResult = isEqual(newSnapshot, memorizedSnapshot);\n                if (compareResult) {\n                    // Mentally, we should always return the `memorizedSnapshot` here\n                    // as there's no change between the new and old snapshots.\n                    // However, since the `isEqual` function only compares selected fields,\n                    // the values of the unselected fields might be changed. That's\n                    // simply because we didn't track them.\n                    // To support the case in https://github.com/vercel/swr/pull/2576,\n                    // we need to update these fields in the `memorizedSnapshot` too\n                    // with direct mutations to ensure the snapshot is always up-to-date\n                    // even for the unselected fields, but only trigger re-renders when\n                    // the selected fields are changed.\n                    memorizedSnapshot.data = newSnapshot.data;\n                    memorizedSnapshot.isLoading = newSnapshot.isLoading;\n                    memorizedSnapshot.isValidating = newSnapshot.isValidating;\n                    memorizedSnapshot.error = newSnapshot.error;\n                    return memorizedSnapshot;\n                } else {\n                    memorizedSnapshot = newSnapshot;\n                    return newSnapshot;\n                }\n            },\n            ()=>serverSnapshot\n        ];\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        cache,\n        key\n    ]);\n    // Get the current state that SWR should return.\n    const cached = (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStore)((0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((callback)=>subscribeCache(key, (current, prev)=>{\n            if (!isEqual(prev, current)) callback();\n        }), // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        cache,\n        key\n    ]), getSnapshot[0], getSnapshot[1]);\n    const isInitialMount = !initialMountedRef.current;\n    const hasRevalidator = EVENT_REVALIDATORS[key] && EVENT_REVALIDATORS[key].length > 0;\n    const cachedData = cached.data;\n    const data = (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(cachedData) ? fallback : cachedData;\n    const error = cached.error;\n    // Use a ref to store previously returned data. Use the initial data as its initial value.\n    const laggyDataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(data);\n    const returnedData = keepPreviousData ? (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(cachedData) ? laggyDataRef.current : cachedData : data;\n    // - Suspense mode and there's stale data for the initial render.\n    // - Not suspense mode and there is no fallback data and `revalidateIfStale` is enabled.\n    // - `revalidateIfStale` is enabled but `data` is not defined.\n    const shouldDoInitialRevalidation = (()=>{\n        // if a key already has revalidators and also has error, we should not trigger revalidation\n        if (hasRevalidator && !(0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(error)) return false;\n        // If `revalidateOnMount` is set, we take the value directly.\n        if (isInitialMount && !(0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(revalidateOnMount)) return revalidateOnMount;\n        // If it's paused, we skip revalidation.\n        if (getConfig().isPaused()) return false;\n        // Under suspense mode, it will always fetch on render if there is no\n        // stale data so no need to revalidate immediately mount it again.\n        // If data exists, only revalidate if `revalidateIfStale` is true.\n        if (suspense) return (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(data) ? false : revalidateIfStale;\n        // If there is no stale data, we need to revalidate when mount;\n        // If `revalidateIfStale` is set to true, we will always revalidate.\n        return (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(data) || revalidateIfStale;\n    })();\n    // Resolve the default validating state:\n    // If it's able to validate, and it should revalidate when mount, this will be true.\n    const defaultValidatingState = !!(key && fetcher && isInitialMount && shouldDoInitialRevalidation);\n    const isValidating = (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(cached.isValidating) ? defaultValidatingState : cached.isValidating;\n    const isLoading = (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(cached.isLoading) ? defaultValidatingState : cached.isLoading;\n    // The revalidation function is a carefully crafted wrapper of the original\n    // `fetcher`, to correctly handle the many edge cases.\n    const revalidate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (revalidateOpts)=>{\n        const currentFetcher = fetcherRef.current;\n        if (!key || !currentFetcher || unmountedRef.current || getConfig().isPaused()) {\n            return false;\n        }\n        let newData;\n        let startAt;\n        let loading = true;\n        const opts = revalidateOpts || {};\n        // If there is no ongoing concurrent request, or `dedupe` is not set, a\n        // new request should be initiated.\n        const shouldStartNewRequest = !FETCH[key] || !opts.dedupe;\n        /*\n         For React 17\n         Do unmount check for calls:\n         If key has changed during the revalidation, or the component has been\n         unmounted, old dispatch and old event callbacks should not take any\n         effect\n\n        For React 18\n        only check if key has changed\n        https://github.com/reactwg/react-18/discussions/82\n      */ const callbackSafeguard = ()=>{\n            if (swr_internal__WEBPACK_IMPORTED_MODULE_2__.IS_REACT_LEGACY) {\n                return !unmountedRef.current && key === keyRef.current && initialMountedRef.current;\n            }\n            return key === keyRef.current;\n        };\n        // The final state object when the request finishes.\n        const finalState = {\n            isValidating: false,\n            isLoading: false\n        };\n        const finishRequestAndUpdateState = ()=>{\n            setCache(finalState);\n        };\n        const cleanupState = ()=>{\n            // Check if it's still the same request before deleting it.\n            const requestInfo = FETCH[key];\n            if (requestInfo && requestInfo[1] === startAt) {\n                delete FETCH[key];\n            }\n        };\n        // Start fetching. Change the `isValidating` state, update the cache.\n        const initialState = {\n            isValidating: true\n        };\n        // It is in the `isLoading` state, if and only if there is no cached data.\n        // This bypasses fallback data and laggy data.\n        if ((0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(getCache().data)) {\n            initialState.isLoading = true;\n        }\n        try {\n            if (shouldStartNewRequest) {\n                setCache(initialState);\n                // If no cache is being rendered currently (it shows a blank page),\n                // we trigger the loading slow event.\n                if (config.loadingTimeout && (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(getCache().data)) {\n                    setTimeout(()=>{\n                        if (loading && callbackSafeguard()) {\n                            getConfig().onLoadingSlow(key, config);\n                        }\n                    }, config.loadingTimeout);\n                }\n                // Start the request and save the timestamp.\n                // Key must be truthy if entering here.\n                FETCH[key] = [\n                    currentFetcher(fnArg),\n                    (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.getTimestamp)()\n                ];\n            }\n            [newData, startAt] = FETCH[key];\n            newData = await newData;\n            if (shouldStartNewRequest) {\n                // If the request isn't interrupted, clean it up after the\n                // deduplication interval.\n                setTimeout(cleanupState, config.dedupingInterval);\n            }\n            // If there're other ongoing request(s), started after the current one,\n            // we need to ignore the current one to avoid possible race conditions:\n            //   req1------------------>res1        (current one)\n            //        req2---------------->res2\n            // the request that fired later will always be kept.\n            // The timestamp maybe be `undefined` or a number\n            if (!FETCH[key] || FETCH[key][1] !== startAt) {\n                if (shouldStartNewRequest) {\n                    if (callbackSafeguard()) {\n                        getConfig().onDiscarded(key);\n                    }\n                }\n                return false;\n            }\n            // Clear error.\n            finalState.error = swr_internal__WEBPACK_IMPORTED_MODULE_2__.UNDEFINED;\n            // If there're other mutations(s), that overlapped with the current revalidation:\n            // case 1:\n            //   req------------------>res\n            //       mutate------>end\n            // case 2:\n            //         req------------>res\n            //   mutate------>end\n            // case 3:\n            //   req------------------>res\n            //       mutate-------...---------->\n            // we have to ignore the revalidation result (res) because it's no longer fresh.\n            // meanwhile, a new revalidation should be triggered when the mutation ends.\n            const mutationInfo = MUTATION[key];\n            if (!(0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(mutationInfo) && // case 1\n            (startAt <= mutationInfo[0] || // case 2\n            startAt <= mutationInfo[1] || // case 3\n            mutationInfo[1] === 0)) {\n                finishRequestAndUpdateState();\n                if (shouldStartNewRequest) {\n                    if (callbackSafeguard()) {\n                        getConfig().onDiscarded(key);\n                    }\n                }\n                return false;\n            }\n            // Deep compare with the latest state to avoid extra re-renders.\n            // For local state, compare and assign.\n            const cacheData = getCache().data;\n            // Since the compare fn could be custom fn\n            // cacheData might be different from newData even when compare fn returns True\n            finalState.data = compare(cacheData, newData) ? cacheData : newData;\n            // Trigger the successful callback if it's the original request.\n            if (shouldStartNewRequest) {\n                if (callbackSafeguard()) {\n                    getConfig().onSuccess(newData, key, config);\n                }\n            }\n        } catch (err) {\n            cleanupState();\n            const currentConfig = getConfig();\n            const { shouldRetryOnError  } = currentConfig;\n            // Not paused, we continue handling the error. Otherwise, discard it.\n            if (!currentConfig.isPaused()) {\n                // Get a new error, don't use deep comparison for errors.\n                finalState.error = err;\n                // Error event and retry logic. Only for the actual request, not\n                // deduped ones.\n                if (shouldStartNewRequest && callbackSafeguard()) {\n                    currentConfig.onError(err, key, currentConfig);\n                    if (shouldRetryOnError === true || (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isFunction)(shouldRetryOnError) && shouldRetryOnError(err)) {\n                        if (isActive()) {\n                            // If it's inactive, stop. It will auto-revalidate when\n                            // refocusing or reconnecting.\n                            // When retrying, deduplication is always enabled.\n                            currentConfig.onErrorRetry(err, key, currentConfig, (_opts)=>{\n                                const revalidators = EVENT_REVALIDATORS[key];\n                                if (revalidators && revalidators[0]) {\n                                    revalidators[0](swr_internal__WEBPACK_IMPORTED_MODULE_2__.revalidateEvents.ERROR_REVALIDATE_EVENT, _opts);\n                                }\n                            }, {\n                                retryCount: (opts.retryCount || 0) + 1,\n                                dedupe: true\n                            });\n                        }\n                    }\n                }\n            }\n        }\n        // Mark loading as stopped.\n        loading = false;\n        // Update the current hook's state.\n        finishRequestAndUpdateState();\n        return true;\n    }, // `setState` is immutable, and `eventsCallback`, `fnArg`, and\n    // `keyValidating` are depending on `key`, so we can exclude them from\n    // the deps array.\n    //\n    // FIXME:\n    // `fn` and `config` might be changed during the lifecycle,\n    // but they might be changed every render like this.\n    // `useSWR('key', () => fetch('/api/'), { suspense: true })`\n    // So we omit the values from the deps array\n    // even though it might cause unexpected behaviors.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        key,\n        cache\n    ]);\n    // Similar to the global mutate but bound to the current cache and key.\n    // `cache` isn't allowed to change during the lifecycle.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    const boundMutate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(// Use callback to make sure `keyRef.current` returns latest result every time\n    (...args)=>{\n        return (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.internalMutate)(cache, keyRef.current, ...args);\n    }, // eslint-disable-next-line react-hooks/exhaustive-deps\n    []);\n    // The logic for updating refs.\n    (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        fetcherRef.current = fetcher;\n        configRef.current = config;\n        // Handle laggy data updates. If there's cached data of the current key,\n        // it'll be the correct reference.\n        if (!(0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(cachedData)) {\n            laggyDataRef.current = cachedData;\n        }\n    });\n    // After mounted or key changed.\n    (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        if (!key) return;\n        const softRevalidate = revalidate.bind(swr_internal__WEBPACK_IMPORTED_MODULE_2__.UNDEFINED, WITH_DEDUPE);\n        // Expose revalidators to global event listeners. So we can trigger\n        // revalidation from the outside.\n        let nextFocusRevalidatedAt = 0;\n        const onRevalidate = (type, opts = {})=>{\n            if (type == swr_internal__WEBPACK_IMPORTED_MODULE_2__.revalidateEvents.FOCUS_EVENT) {\n                const now = Date.now();\n                if (getConfig().revalidateOnFocus && now > nextFocusRevalidatedAt && isActive()) {\n                    nextFocusRevalidatedAt = now + getConfig().focusThrottleInterval;\n                    softRevalidate();\n                }\n            } else if (type == swr_internal__WEBPACK_IMPORTED_MODULE_2__.revalidateEvents.RECONNECT_EVENT) {\n                if (getConfig().revalidateOnReconnect && isActive()) {\n                    softRevalidate();\n                }\n            } else if (type == swr_internal__WEBPACK_IMPORTED_MODULE_2__.revalidateEvents.MUTATE_EVENT) {\n                return revalidate();\n            } else if (type == swr_internal__WEBPACK_IMPORTED_MODULE_2__.revalidateEvents.ERROR_REVALIDATE_EVENT) {\n                return revalidate(opts);\n            }\n            return;\n        };\n        const unsubEvents = (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.subscribeCallback)(key, EVENT_REVALIDATORS, onRevalidate);\n        // Mark the component as mounted and update corresponding refs.\n        unmountedRef.current = false;\n        keyRef.current = key;\n        initialMountedRef.current = true;\n        // Keep the original key in the cache.\n        setCache({\n            _k: fnArg\n        });\n        // Trigger a revalidation\n        if (shouldDoInitialRevalidation) {\n            if ((0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(data) || swr_internal__WEBPACK_IMPORTED_MODULE_2__.IS_SERVER) {\n                // Revalidate immediately.\n                softRevalidate();\n            } else {\n                // Delay the revalidate if we have data to return so we won't block\n                // rendering.\n                (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.rAF)(softRevalidate);\n            }\n        }\n        return ()=>{\n            // Mark it as unmounted.\n            unmountedRef.current = true;\n            unsubEvents();\n        };\n    }, [\n        key\n    ]);\n    // Polling\n    (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        let timer;\n        function next() {\n            // Use the passed interval\n            // ...or invoke the function with the updated data to get the interval\n            const interval = (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isFunction)(refreshInterval) ? refreshInterval(getCache().data) : refreshInterval;\n            // We only start the next interval if `refreshInterval` is not 0, and:\n            // - `force` is true, which is the start of polling\n            // - or `timer` is not 0, which means the effect wasn't canceled\n            if (interval && timer !== -1) {\n                timer = setTimeout(execute, interval);\n            }\n        }\n        function execute() {\n            // Check if it's OK to execute:\n            // Only revalidate when the page is visible, online, and not errored.\n            if (!getCache().error && (refreshWhenHidden || getConfig().isVisible()) && (refreshWhenOffline || getConfig().isOnline())) {\n                revalidate(WITH_DEDUPE).then(next);\n            } else {\n                // Schedule the next interval to check again.\n                next();\n            }\n        }\n        next();\n        return ()=>{\n            if (timer) {\n                clearTimeout(timer);\n                timer = -1;\n            }\n        };\n    }, [\n        refreshInterval,\n        refreshWhenHidden,\n        refreshWhenOffline,\n        key\n    ]);\n    // Display debug info in React DevTools.\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(returnedData);\n    // In Suspense mode, we can't return the empty `data` state.\n    // If there is an `error`, the `error` needs to be thrown to the error boundary.\n    // If there is no `error`, the `revalidation` promise needs to be thrown to\n    // the suspense boundary.\n    if (suspense && (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(data) && key) {\n        // SWR should throw when trying to use Suspense on the server with React 18,\n        // without providing any initial data. See:\n        // https://github.com/vercel/swr/issues/1832\n        if (!swr_internal__WEBPACK_IMPORTED_MODULE_2__.IS_REACT_LEGACY && swr_internal__WEBPACK_IMPORTED_MODULE_2__.IS_SERVER) {\n            throw new Error('Fallback data is required when using suspense in SSR.');\n        }\n        // Always update fetcher and config refs even with the Suspense mode.\n        fetcherRef.current = fetcher;\n        configRef.current = config;\n        unmountedRef.current = false;\n        const req = PRELOAD[key];\n        if (!(0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(req)) {\n            const promise = boundMutate(req);\n            use(promise);\n        }\n        if ((0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(error)) {\n            const promise = revalidate(WITH_DEDUPE);\n            if (!(0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(returnedData)) {\n                promise.status = 'fulfilled';\n                promise.value = true;\n            }\n            use(promise);\n        } else {\n            throw error;\n        }\n    }\n    return {\n        mutate: boundMutate,\n        get data () {\n            stateDependencies.data = true;\n            return returnedData;\n        },\n        get error () {\n            stateDependencies.error = true;\n            return error;\n        },\n        get isValidating () {\n            stateDependencies.isValidating = true;\n            return isValidating;\n        },\n        get isLoading () {\n            stateDependencies.isLoading = true;\n            return isLoading;\n        }\n    };\n};\nconst SWRConfig = swr_internal__WEBPACK_IMPORTED_MODULE_2__.OBJECT.defineProperty(swr_internal__WEBPACK_IMPORTED_MODULE_2__.SWRConfig, 'defaultValue', {\n    value: swr_internal__WEBPACK_IMPORTED_MODULE_2__.defaultConfig\n});\n/**\n * A hook to fetch data.\n *\n * @link https://swr.vercel.app\n * @example\n * ```jsx\n * import useSWR from 'swr'\n * function Profile() {\n *   const { data, error } = useSWR('/api/user', fetcher)\n *   if (error) return <div>failed to load</div>\n *   if (!data) return <div>loading...</div>\n *   return <div>hello {data.name}!</div>\n * }\n * ```\n */ const useSWR = (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.withArgs)(useSWRHandler);\n\n// useSWR\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zd3IvY29yZS9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBa0Y7QUFDTDtBQUM0TztBQUMzUDs7QUFFOUQsa0NBQWtDLHVEQUFTOztBQUUzQztBQUNBLFlBQVksc0NBQWdCO0FBQzVCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtS0FBbUs7QUFDL0ssMkRBQTJELHdEQUFjO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVEQUFTO0FBQ2xDO0FBQ0EsOEJBQThCLDZDQUFNO0FBQ3BDO0FBQ0E7QUFDQSx5QkFBeUIsNkNBQU07QUFDL0I7QUFDQSxtQkFBbUIsNkNBQU07QUFDekIsdUJBQXVCLDZDQUFNO0FBQzdCLHNCQUFzQiw2Q0FBTTtBQUM1QjtBQUNBO0FBQ0Esa0VBQWtFLCtEQUFpQjtBQUNuRiw4QkFBOEIsNkNBQU0sR0FBRztBQUN2QyxxQkFBcUIseURBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix5REFBVztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsOENBQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseURBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHlEQUFXO0FBQzVCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwwREFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdEQUFNLGdCQUFnQixtREFBVztBQUNuRCxXQUFXLHVEQUFhO0FBQ3hCLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0EsbUJBQW1CLHNEQUFROztBQUUzQjs7QUFFNEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3N3ci9jb3JlL2Rpc3QvaW5kZXgubWpzPzljMjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0RXhwb3J0cywgeyB1c2VSZWYsIHVzZU1lbW8sIHVzZUNhbGxiYWNrLCB1c2VEZWJ1Z1ZhbHVlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlU3luY0V4dGVybmFsU3RvcmUgfSBmcm9tICd1c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL2luZGV4LmpzJztcbmltcG9ydCB7IHNlcmlhbGl6ZSwgT0JKRUNULCBTV1JDb25maWcgYXMgU1dSQ29uZmlnJDEsIGRlZmF1bHRDb25maWcsIHdpdGhBcmdzLCBTV1JHbG9iYWxTdGF0ZSwgY3JlYXRlQ2FjaGVIZWxwZXIsIGlzVW5kZWZpbmVkLCBnZXRUaW1lc3RhbXAsIFVOREVGSU5FRCwgaXNGdW5jdGlvbiwgcmV2YWxpZGF0ZUV2ZW50cywgaW50ZXJuYWxNdXRhdGUsIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QsIHN1YnNjcmliZUNhbGxiYWNrLCBJU19TRVJWRVIsIHJBRiwgSVNfUkVBQ1RfTEVHQUNZLCBtZXJnZU9iamVjdHMgfSBmcm9tICdzd3IvX2ludGVybmFsJztcbmV4cG9ydCB7IG11dGF0ZSwgcHJlbG9hZCwgdXNlU1dSQ29uZmlnIH0gZnJvbSAnc3dyL19pbnRlcm5hbCc7XG5cbmNvbnN0IHVuc3RhYmxlX3NlcmlhbGl6ZSA9IChrZXkpPT5zZXJpYWxpemUoa2V5KVswXTtcblxuLy8vIDxyZWZlcmVuY2UgdHlwZXM9XCJyZWFjdC9leHBlcmltZW50YWxcIiAvPlxuY29uc3QgdXNlID0gUmVhY3RFeHBvcnRzLnVzZSB8fCAoKHByb21pc2UpPT57XG4gICAgaWYgKHByb21pc2Uuc3RhdHVzID09PSAncGVuZGluZycpIHtcbiAgICAgICAgdGhyb3cgcHJvbWlzZTtcbiAgICB9IGVsc2UgaWYgKHByb21pc2Uuc3RhdHVzID09PSAnZnVsZmlsbGVkJykge1xuICAgICAgICByZXR1cm4gcHJvbWlzZS52YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHByb21pc2Uuc3RhdHVzID09PSAncmVqZWN0ZWQnKSB7XG4gICAgICAgIHRocm93IHByb21pc2UucmVhc29uO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2Uuc3RhdHVzID0gJ3BlbmRpbmcnO1xuICAgICAgICBwcm9taXNlLnRoZW4oKHYpPT57XG4gICAgICAgICAgICBwcm9taXNlLnN0YXR1cyA9ICdmdWxmaWxsZWQnO1xuICAgICAgICAgICAgcHJvbWlzZS52YWx1ZSA9IHY7XG4gICAgICAgIH0sIChlKT0+e1xuICAgICAgICAgICAgcHJvbWlzZS5zdGF0dXMgPSAncmVqZWN0ZWQnO1xuICAgICAgICAgICAgcHJvbWlzZS5yZWFzb24gPSBlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhyb3cgcHJvbWlzZTtcbiAgICB9XG59KTtcbmNvbnN0IFdJVEhfREVEVVBFID0ge1xuICAgIGRlZHVwZTogdHJ1ZVxufTtcbmNvbnN0IHVzZVNXUkhhbmRsZXIgPSAoX2tleSwgZmV0Y2hlciwgY29uZmlnKT0+e1xuICAgIGNvbnN0IHsgY2FjaGUgLCBjb21wYXJlICwgc3VzcGVuc2UgLCBmYWxsYmFja0RhdGEgLCByZXZhbGlkYXRlT25Nb3VudCAsIHJldmFsaWRhdGVJZlN0YWxlICwgcmVmcmVzaEludGVydmFsICwgcmVmcmVzaFdoZW5IaWRkZW4gLCByZWZyZXNoV2hlbk9mZmxpbmUgLCBrZWVwUHJldmlvdXNEYXRhICB9ID0gY29uZmlnO1xuICAgIGNvbnN0IFtFVkVOVF9SRVZBTElEQVRPUlMsIE1VVEFUSU9OLCBGRVRDSCwgUFJFTE9BRF0gPSBTV1JHbG9iYWxTdGF0ZS5nZXQoY2FjaGUpO1xuICAgIC8vIGBrZXlgIGlzIHRoZSBpZGVudGlmaWVyIG9mIHRoZSBTV1IgaW50ZXJuYWwgc3RhdGUsXG4gICAgLy8gYGZuQXJnYCBpcyB0aGUgYXJndW1lbnQvYXJndW1lbnRzIHBhcnNlZCBmcm9tIHRoZSBrZXksIHdoaWNoIHdpbGwgYmUgcGFzc2VkXG4gICAgLy8gdG8gdGhlIGZldGNoZXIuXG4gICAgLy8gQWxsIG9mIHRoZW0gYXJlIGRlcml2ZWQgZnJvbSBgX2tleWAuXG4gICAgY29uc3QgW2tleSwgZm5BcmddID0gc2VyaWFsaXplKF9rZXkpO1xuICAgIC8vIElmIGl0J3MgdGhlIGluaXRpYWwgcmVuZGVyIG9mIHRoaXMgaG9vay5cbiAgICBjb25zdCBpbml0aWFsTW91bnRlZFJlZiA9IHVzZVJlZihmYWxzZSk7XG4gICAgLy8gSWYgdGhlIGhvb2sgaXMgdW5tb3VudGVkIGFscmVhZHkuIFRoaXMgd2lsbCBiZSB1c2VkIHRvIHByZXZlbnQgc29tZSBlZmZlY3RzXG4gICAgLy8gdG8gYmUgY2FsbGVkIGFmdGVyIHVubW91bnRpbmcuXG4gICAgY29uc3QgdW5tb3VudGVkUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgICAvLyBSZWZzIHRvIGtlZXAgdGhlIGtleSBhbmQgY29uZmlnLlxuICAgIGNvbnN0IGtleVJlZiA9IHVzZVJlZihrZXkpO1xuICAgIGNvbnN0IGZldGNoZXJSZWYgPSB1c2VSZWYoZmV0Y2hlcik7XG4gICAgY29uc3QgY29uZmlnUmVmID0gdXNlUmVmKGNvbmZpZyk7XG4gICAgY29uc3QgZ2V0Q29uZmlnID0gKCk9PmNvbmZpZ1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IGlzQWN0aXZlID0gKCk9PmdldENvbmZpZygpLmlzVmlzaWJsZSgpICYmIGdldENvbmZpZygpLmlzT25saW5lKCk7XG4gICAgY29uc3QgW2dldENhY2hlLCBzZXRDYWNoZSwgc3Vic2NyaWJlQ2FjaGUsIGdldEluaXRpYWxDYWNoZV0gPSBjcmVhdGVDYWNoZUhlbHBlcihjYWNoZSwga2V5KTtcbiAgICBjb25zdCBzdGF0ZURlcGVuZGVuY2llcyA9IHVzZVJlZih7fSkuY3VycmVudDtcbiAgICBjb25zdCBmYWxsYmFjayA9IGlzVW5kZWZpbmVkKGZhbGxiYWNrRGF0YSkgPyBjb25maWcuZmFsbGJhY2tba2V5XSA6IGZhbGxiYWNrRGF0YTtcbiAgICBjb25zdCBpc0VxdWFsID0gKHByZXYsIGN1cnJlbnQpPT57XG4gICAgICAgIGZvcihjb25zdCBfIGluIHN0YXRlRGVwZW5kZW5jaWVzKXtcbiAgICAgICAgICAgIGNvbnN0IHQgPSBfO1xuICAgICAgICAgICAgaWYgKHQgPT09ICdkYXRhJykge1xuICAgICAgICAgICAgICAgIGlmICghY29tcGFyZShwcmV2W3RdLCBjdXJyZW50W3RdKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHByZXZbdF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21wYXJlKHJldHVybmVkRGF0YSwgY3VycmVudFt0XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRbdF0gIT09IHByZXZbdF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIGNvbnN0IGdldFNuYXBzaG90ID0gdXNlTWVtbygoKT0+e1xuICAgICAgICBjb25zdCBzaG91bGRTdGFydFJlcXVlc3QgPSAoKCk9PntcbiAgICAgICAgICAgIGlmICgha2V5KSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIWZldGNoZXIpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIC8vIElmIGByZXZhbGlkYXRlT25Nb3VudGAgaXMgc2V0LCB3ZSB0YWtlIHRoZSB2YWx1ZSBkaXJlY3RseS5cbiAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQocmV2YWxpZGF0ZU9uTW91bnQpKSByZXR1cm4gcmV2YWxpZGF0ZU9uTW91bnQ7XG4gICAgICAgICAgICAvLyBJZiBpdCdzIHBhdXNlZCwgd2Ugc2tpcCByZXZhbGlkYXRpb24uXG4gICAgICAgICAgICBpZiAoZ2V0Q29uZmlnKCkuaXNQYXVzZWQoKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKHN1c3BlbnNlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHJldmFsaWRhdGVJZlN0YWxlKSkgcmV0dXJuIHJldmFsaWRhdGVJZlN0YWxlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIC8vIEdldCB0aGUgY2FjaGUgYW5kIG1lcmdlIGl0IHdpdGggZXhwZWN0ZWQgc3RhdGVzLlxuICAgICAgICBjb25zdCBnZXRTZWxlY3RlZENhY2hlID0gKHN0YXRlKT0+e1xuICAgICAgICAgICAgLy8gV2Ugb25seSBzZWxlY3QgdGhlIG5lZWRlZCBmaWVsZHMgZnJvbSB0aGUgc3RhdGUuXG4gICAgICAgICAgICBjb25zdCBzbmFwc2hvdCA9IG1lcmdlT2JqZWN0cyhzdGF0ZSk7XG4gICAgICAgICAgICBkZWxldGUgc25hcHNob3QuX2s7XG4gICAgICAgICAgICBpZiAoIXNob3VsZFN0YXJ0UmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzbmFwc2hvdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaXNWYWxpZGF0aW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgIGlzTG9hZGluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAuLi5zbmFwc2hvdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2FjaGVkRGF0YSA9IGdldENhY2hlKCk7XG4gICAgICAgIGNvbnN0IGluaXRpYWxEYXRhID0gZ2V0SW5pdGlhbENhY2hlKCk7XG4gICAgICAgIGNvbnN0IGNsaWVudFNuYXBzaG90ID0gZ2V0U2VsZWN0ZWRDYWNoZShjYWNoZWREYXRhKTtcbiAgICAgICAgY29uc3Qgc2VydmVyU25hcHNob3QgPSBjYWNoZWREYXRhID09PSBpbml0aWFsRGF0YSA/IGNsaWVudFNuYXBzaG90IDogZ2V0U2VsZWN0ZWRDYWNoZShpbml0aWFsRGF0YSk7XG4gICAgICAgIC8vIFRvIG1ha2Ugc3VyZSB0aGF0IHdlIGFyZSByZXR1cm5pbmcgdGhlIHNhbWUgb2JqZWN0IHJlZmVyZW5jZSB0byBhdm9pZFxuICAgICAgICAvLyB1bm5lY2Vzc2FyeSByZS1yZW5kZXJzLCB3ZSBrZWVwIHRoZSBwcmV2aW91cyBzbmFwc2hvdCBhbmQgdXNlIGRlZXBcbiAgICAgICAgLy8gY29tcGFyaXNvbiB0byBjaGVjayBpZiB3ZSBuZWVkIHRvIHJldHVybiBhIG5ldyBvbmUuXG4gICAgICAgIGxldCBtZW1vcml6ZWRTbmFwc2hvdCA9IGNsaWVudFNuYXBzaG90O1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgKCk9PntcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdTbmFwc2hvdCA9IGdldFNlbGVjdGVkQ2FjaGUoZ2V0Q2FjaGUoKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcGFyZVJlc3VsdCA9IGlzRXF1YWwobmV3U25hcHNob3QsIG1lbW9yaXplZFNuYXBzaG90KTtcbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyZVJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBNZW50YWxseSwgd2Ugc2hvdWxkIGFsd2F5cyByZXR1cm4gdGhlIGBtZW1vcml6ZWRTbmFwc2hvdGAgaGVyZVxuICAgICAgICAgICAgICAgICAgICAvLyBhcyB0aGVyZSdzIG5vIGNoYW5nZSBiZXR3ZWVuIHRoZSBuZXcgYW5kIG9sZCBzbmFwc2hvdHMuXG4gICAgICAgICAgICAgICAgICAgIC8vIEhvd2V2ZXIsIHNpbmNlIHRoZSBgaXNFcXVhbGAgZnVuY3Rpb24gb25seSBjb21wYXJlcyBzZWxlY3RlZCBmaWVsZHMsXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSB2YWx1ZXMgb2YgdGhlIHVuc2VsZWN0ZWQgZmllbGRzIG1pZ2h0IGJlIGNoYW5nZWQuIFRoYXQnc1xuICAgICAgICAgICAgICAgICAgICAvLyBzaW1wbHkgYmVjYXVzZSB3ZSBkaWRuJ3QgdHJhY2sgdGhlbS5cbiAgICAgICAgICAgICAgICAgICAgLy8gVG8gc3VwcG9ydCB0aGUgY2FzZSBpbiBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL3N3ci9wdWxsLzI1NzYsXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gdXBkYXRlIHRoZXNlIGZpZWxkcyBpbiB0aGUgYG1lbW9yaXplZFNuYXBzaG90YCB0b29cbiAgICAgICAgICAgICAgICAgICAgLy8gd2l0aCBkaXJlY3QgbXV0YXRpb25zIHRvIGVuc3VyZSB0aGUgc25hcHNob3QgaXMgYWx3YXlzIHVwLXRvLWRhdGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZXZlbiBmb3IgdGhlIHVuc2VsZWN0ZWQgZmllbGRzLCBidXQgb25seSB0cmlnZ2VyIHJlLXJlbmRlcnMgd2hlblxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgc2VsZWN0ZWQgZmllbGRzIGFyZSBjaGFuZ2VkLlxuICAgICAgICAgICAgICAgICAgICBtZW1vcml6ZWRTbmFwc2hvdC5kYXRhID0gbmV3U25hcHNob3QuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgbWVtb3JpemVkU25hcHNob3QuaXNMb2FkaW5nID0gbmV3U25hcHNob3QuaXNMb2FkaW5nO1xuICAgICAgICAgICAgICAgICAgICBtZW1vcml6ZWRTbmFwc2hvdC5pc1ZhbGlkYXRpbmcgPSBuZXdTbmFwc2hvdC5pc1ZhbGlkYXRpbmc7XG4gICAgICAgICAgICAgICAgICAgIG1lbW9yaXplZFNuYXBzaG90LmVycm9yID0gbmV3U25hcHNob3QuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZW1vcml6ZWRTbmFwc2hvdDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZW1vcml6ZWRTbmFwc2hvdCA9IG5ld1NuYXBzaG90O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3U25hcHNob3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICgpPT5zZXJ2ZXJTbmFwc2hvdFxuICAgICAgICBdO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICB9LCBbXG4gICAgICAgIGNhY2hlLFxuICAgICAgICBrZXlcbiAgICBdKTtcbiAgICAvLyBHZXQgdGhlIGN1cnJlbnQgc3RhdGUgdGhhdCBTV1Igc2hvdWxkIHJldHVybi5cbiAgICBjb25zdCBjYWNoZWQgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZSh1c2VDYWxsYmFjaygoY2FsbGJhY2spPT5zdWJzY3JpYmVDYWNoZShrZXksIChjdXJyZW50LCBwcmV2KT0+e1xuICAgICAgICAgICAgaWYgKCFpc0VxdWFsKHByZXYsIGN1cnJlbnQpKSBjYWxsYmFjaygpO1xuICAgICAgICB9KSwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIFtcbiAgICAgICAgY2FjaGUsXG4gICAgICAgIGtleVxuICAgIF0pLCBnZXRTbmFwc2hvdFswXSwgZ2V0U25hcHNob3RbMV0pO1xuICAgIGNvbnN0IGlzSW5pdGlhbE1vdW50ID0gIWluaXRpYWxNb3VudGVkUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgaGFzUmV2YWxpZGF0b3IgPSBFVkVOVF9SRVZBTElEQVRPUlNba2V5XSAmJiBFVkVOVF9SRVZBTElEQVRPUlNba2V5XS5sZW5ndGggPiAwO1xuICAgIGNvbnN0IGNhY2hlZERhdGEgPSBjYWNoZWQuZGF0YTtcbiAgICBjb25zdCBkYXRhID0gaXNVbmRlZmluZWQoY2FjaGVkRGF0YSkgPyBmYWxsYmFjayA6IGNhY2hlZERhdGE7XG4gICAgY29uc3QgZXJyb3IgPSBjYWNoZWQuZXJyb3I7XG4gICAgLy8gVXNlIGEgcmVmIHRvIHN0b3JlIHByZXZpb3VzbHkgcmV0dXJuZWQgZGF0YS4gVXNlIHRoZSBpbml0aWFsIGRhdGEgYXMgaXRzIGluaXRpYWwgdmFsdWUuXG4gICAgY29uc3QgbGFnZ3lEYXRhUmVmID0gdXNlUmVmKGRhdGEpO1xuICAgIGNvbnN0IHJldHVybmVkRGF0YSA9IGtlZXBQcmV2aW91c0RhdGEgPyBpc1VuZGVmaW5lZChjYWNoZWREYXRhKSA/IGxhZ2d5RGF0YVJlZi5jdXJyZW50IDogY2FjaGVkRGF0YSA6IGRhdGE7XG4gICAgLy8gLSBTdXNwZW5zZSBtb2RlIGFuZCB0aGVyZSdzIHN0YWxlIGRhdGEgZm9yIHRoZSBpbml0aWFsIHJlbmRlci5cbiAgICAvLyAtIE5vdCBzdXNwZW5zZSBtb2RlIGFuZCB0aGVyZSBpcyBubyBmYWxsYmFjayBkYXRhIGFuZCBgcmV2YWxpZGF0ZUlmU3RhbGVgIGlzIGVuYWJsZWQuXG4gICAgLy8gLSBgcmV2YWxpZGF0ZUlmU3RhbGVgIGlzIGVuYWJsZWQgYnV0IGBkYXRhYCBpcyBub3QgZGVmaW5lZC5cbiAgICBjb25zdCBzaG91bGREb0luaXRpYWxSZXZhbGlkYXRpb24gPSAoKCk9PntcbiAgICAgICAgLy8gaWYgYSBrZXkgYWxyZWFkeSBoYXMgcmV2YWxpZGF0b3JzIGFuZCBhbHNvIGhhcyBlcnJvciwgd2Ugc2hvdWxkIG5vdCB0cmlnZ2VyIHJldmFsaWRhdGlvblxuICAgICAgICBpZiAoaGFzUmV2YWxpZGF0b3IgJiYgIWlzVW5kZWZpbmVkKGVycm9yKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBJZiBgcmV2YWxpZGF0ZU9uTW91bnRgIGlzIHNldCwgd2UgdGFrZSB0aGUgdmFsdWUgZGlyZWN0bHkuXG4gICAgICAgIGlmIChpc0luaXRpYWxNb3VudCAmJiAhaXNVbmRlZmluZWQocmV2YWxpZGF0ZU9uTW91bnQpKSByZXR1cm4gcmV2YWxpZGF0ZU9uTW91bnQ7XG4gICAgICAgIC8vIElmIGl0J3MgcGF1c2VkLCB3ZSBza2lwIHJldmFsaWRhdGlvbi5cbiAgICAgICAgaWYgKGdldENvbmZpZygpLmlzUGF1c2VkKCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gVW5kZXIgc3VzcGVuc2UgbW9kZSwgaXQgd2lsbCBhbHdheXMgZmV0Y2ggb24gcmVuZGVyIGlmIHRoZXJlIGlzIG5vXG4gICAgICAgIC8vIHN0YWxlIGRhdGEgc28gbm8gbmVlZCB0byByZXZhbGlkYXRlIGltbWVkaWF0ZWx5IG1vdW50IGl0IGFnYWluLlxuICAgICAgICAvLyBJZiBkYXRhIGV4aXN0cywgb25seSByZXZhbGlkYXRlIGlmIGByZXZhbGlkYXRlSWZTdGFsZWAgaXMgdHJ1ZS5cbiAgICAgICAgaWYgKHN1c3BlbnNlKSByZXR1cm4gaXNVbmRlZmluZWQoZGF0YSkgPyBmYWxzZSA6IHJldmFsaWRhdGVJZlN0YWxlO1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBzdGFsZSBkYXRhLCB3ZSBuZWVkIHRvIHJldmFsaWRhdGUgd2hlbiBtb3VudDtcbiAgICAgICAgLy8gSWYgYHJldmFsaWRhdGVJZlN0YWxlYCBpcyBzZXQgdG8gdHJ1ZSwgd2Ugd2lsbCBhbHdheXMgcmV2YWxpZGF0ZS5cbiAgICAgICAgcmV0dXJuIGlzVW5kZWZpbmVkKGRhdGEpIHx8IHJldmFsaWRhdGVJZlN0YWxlO1xuICAgIH0pKCk7XG4gICAgLy8gUmVzb2x2ZSB0aGUgZGVmYXVsdCB2YWxpZGF0aW5nIHN0YXRlOlxuICAgIC8vIElmIGl0J3MgYWJsZSB0byB2YWxpZGF0ZSwgYW5kIGl0IHNob3VsZCByZXZhbGlkYXRlIHdoZW4gbW91bnQsIHRoaXMgd2lsbCBiZSB0cnVlLlxuICAgIGNvbnN0IGRlZmF1bHRWYWxpZGF0aW5nU3RhdGUgPSAhIShrZXkgJiYgZmV0Y2hlciAmJiBpc0luaXRpYWxNb3VudCAmJiBzaG91bGREb0luaXRpYWxSZXZhbGlkYXRpb24pO1xuICAgIGNvbnN0IGlzVmFsaWRhdGluZyA9IGlzVW5kZWZpbmVkKGNhY2hlZC5pc1ZhbGlkYXRpbmcpID8gZGVmYXVsdFZhbGlkYXRpbmdTdGF0ZSA6IGNhY2hlZC5pc1ZhbGlkYXRpbmc7XG4gICAgY29uc3QgaXNMb2FkaW5nID0gaXNVbmRlZmluZWQoY2FjaGVkLmlzTG9hZGluZykgPyBkZWZhdWx0VmFsaWRhdGluZ1N0YXRlIDogY2FjaGVkLmlzTG9hZGluZztcbiAgICAvLyBUaGUgcmV2YWxpZGF0aW9uIGZ1bmN0aW9uIGlzIGEgY2FyZWZ1bGx5IGNyYWZ0ZWQgd3JhcHBlciBvZiB0aGUgb3JpZ2luYWxcbiAgICAvLyBgZmV0Y2hlcmAsIHRvIGNvcnJlY3RseSBoYW5kbGUgdGhlIG1hbnkgZWRnZSBjYXNlcy5cbiAgICBjb25zdCByZXZhbGlkYXRlID0gdXNlQ2FsbGJhY2soYXN5bmMgKHJldmFsaWRhdGVPcHRzKT0+e1xuICAgICAgICBjb25zdCBjdXJyZW50RmV0Y2hlciA9IGZldGNoZXJSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKCFrZXkgfHwgIWN1cnJlbnRGZXRjaGVyIHx8IHVubW91bnRlZFJlZi5jdXJyZW50IHx8IGdldENvbmZpZygpLmlzUGF1c2VkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV3RGF0YTtcbiAgICAgICAgbGV0IHN0YXJ0QXQ7XG4gICAgICAgIGxldCBsb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHJldmFsaWRhdGVPcHRzIHx8IHt9O1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBvbmdvaW5nIGNvbmN1cnJlbnQgcmVxdWVzdCwgb3IgYGRlZHVwZWAgaXMgbm90IHNldCwgYVxuICAgICAgICAvLyBuZXcgcmVxdWVzdCBzaG91bGQgYmUgaW5pdGlhdGVkLlxuICAgICAgICBjb25zdCBzaG91bGRTdGFydE5ld1JlcXVlc3QgPSAhRkVUQ0hba2V5XSB8fCAhb3B0cy5kZWR1cGU7XG4gICAgICAgIC8qXG4gICAgICAgICBGb3IgUmVhY3QgMTdcbiAgICAgICAgIERvIHVubW91bnQgY2hlY2sgZm9yIGNhbGxzOlxuICAgICAgICAgSWYga2V5IGhhcyBjaGFuZ2VkIGR1cmluZyB0aGUgcmV2YWxpZGF0aW9uLCBvciB0aGUgY29tcG9uZW50IGhhcyBiZWVuXG4gICAgICAgICB1bm1vdW50ZWQsIG9sZCBkaXNwYXRjaCBhbmQgb2xkIGV2ZW50IGNhbGxiYWNrcyBzaG91bGQgbm90IHRha2UgYW55XG4gICAgICAgICBlZmZlY3RcblxuICAgICAgICBGb3IgUmVhY3QgMThcbiAgICAgICAgb25seSBjaGVjayBpZiBrZXkgaGFzIGNoYW5nZWRcbiAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0d2cvcmVhY3QtMTgvZGlzY3Vzc2lvbnMvODJcbiAgICAgICovIGNvbnN0IGNhbGxiYWNrU2FmZWd1YXJkID0gKCk9PntcbiAgICAgICAgICAgIGlmIChJU19SRUFDVF9MRUdBQ1kpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXVubW91bnRlZFJlZi5jdXJyZW50ICYmIGtleSA9PT0ga2V5UmVmLmN1cnJlbnQgJiYgaW5pdGlhbE1vdW50ZWRSZWYuY3VycmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBrZXkgPT09IGtleVJlZi5jdXJyZW50O1xuICAgICAgICB9O1xuICAgICAgICAvLyBUaGUgZmluYWwgc3RhdGUgb2JqZWN0IHdoZW4gdGhlIHJlcXVlc3QgZmluaXNoZXMuXG4gICAgICAgIGNvbnN0IGZpbmFsU3RhdGUgPSB7XG4gICAgICAgICAgICBpc1ZhbGlkYXRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgaXNMb2FkaW5nOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBmaW5pc2hSZXF1ZXN0QW5kVXBkYXRlU3RhdGUgPSAoKT0+e1xuICAgICAgICAgICAgc2V0Q2FjaGUoZmluYWxTdGF0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNsZWFudXBTdGF0ZSA9ICgpPT57XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBpdCdzIHN0aWxsIHRoZSBzYW1lIHJlcXVlc3QgYmVmb3JlIGRlbGV0aW5nIGl0LlxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdEluZm8gPSBGRVRDSFtrZXldO1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RJbmZvICYmIHJlcXVlc3RJbmZvWzFdID09PSBzdGFydEF0KSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIEZFVENIW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIFN0YXJ0IGZldGNoaW5nLiBDaGFuZ2UgdGhlIGBpc1ZhbGlkYXRpbmdgIHN0YXRlLCB1cGRhdGUgdGhlIGNhY2hlLlxuICAgICAgICBjb25zdCBpbml0aWFsU3RhdGUgPSB7XG4gICAgICAgICAgICBpc1ZhbGlkYXRpbmc6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgLy8gSXQgaXMgaW4gdGhlIGBpc0xvYWRpbmdgIHN0YXRlLCBpZiBhbmQgb25seSBpZiB0aGVyZSBpcyBubyBjYWNoZWQgZGF0YS5cbiAgICAgICAgLy8gVGhpcyBieXBhc3NlcyBmYWxsYmFjayBkYXRhIGFuZCBsYWdneSBkYXRhLlxuICAgICAgICBpZiAoaXNVbmRlZmluZWQoZ2V0Q2FjaGUoKS5kYXRhKSkge1xuICAgICAgICAgICAgaW5pdGlhbFN0YXRlLmlzTG9hZGluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChzaG91bGRTdGFydE5ld1JlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICBzZXRDYWNoZShpbml0aWFsU3RhdGUpO1xuICAgICAgICAgICAgICAgIC8vIElmIG5vIGNhY2hlIGlzIGJlaW5nIHJlbmRlcmVkIGN1cnJlbnRseSAoaXQgc2hvd3MgYSBibGFuayBwYWdlKSxcbiAgICAgICAgICAgICAgICAvLyB3ZSB0cmlnZ2VyIHRoZSBsb2FkaW5nIHNsb3cgZXZlbnQuXG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5sb2FkaW5nVGltZW91dCAmJiBpc1VuZGVmaW5lZChnZXRDYWNoZSgpLmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2FkaW5nICYmIGNhbGxiYWNrU2FmZWd1YXJkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRDb25maWcoKS5vbkxvYWRpbmdTbG93KGtleSwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgY29uZmlnLmxvYWRpbmdUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgdGhlIHJlcXVlc3QgYW5kIHNhdmUgdGhlIHRpbWVzdGFtcC5cbiAgICAgICAgICAgICAgICAvLyBLZXkgbXVzdCBiZSB0cnV0aHkgaWYgZW50ZXJpbmcgaGVyZS5cbiAgICAgICAgICAgICAgICBGRVRDSFtrZXldID0gW1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RmV0Y2hlcihmbkFyZyksXG4gICAgICAgICAgICAgICAgICAgIGdldFRpbWVzdGFtcCgpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFtuZXdEYXRhLCBzdGFydEF0XSA9IEZFVENIW2tleV07XG4gICAgICAgICAgICBuZXdEYXRhID0gYXdhaXQgbmV3RGF0YTtcbiAgICAgICAgICAgIGlmIChzaG91bGRTdGFydE5ld1JlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcmVxdWVzdCBpc24ndCBpbnRlcnJ1cHRlZCwgY2xlYW4gaXQgdXAgYWZ0ZXIgdGhlXG4gICAgICAgICAgICAgICAgLy8gZGVkdXBsaWNhdGlvbiBpbnRlcnZhbC5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNsZWFudXBTdGF0ZSwgY29uZmlnLmRlZHVwaW5nSW50ZXJ2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlcmUncmUgb3RoZXIgb25nb2luZyByZXF1ZXN0KHMpLCBzdGFydGVkIGFmdGVyIHRoZSBjdXJyZW50IG9uZSxcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gaWdub3JlIHRoZSBjdXJyZW50IG9uZSB0byBhdm9pZCBwb3NzaWJsZSByYWNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgICAvLyAgIHJlcTEtLS0tLS0tLS0tLS0tLS0tLS0+cmVzMSAgICAgICAgKGN1cnJlbnQgb25lKVxuICAgICAgICAgICAgLy8gICAgICAgIHJlcTItLS0tLS0tLS0tLS0tLS0tPnJlczJcbiAgICAgICAgICAgIC8vIHRoZSByZXF1ZXN0IHRoYXQgZmlyZWQgbGF0ZXIgd2lsbCBhbHdheXMgYmUga2VwdC5cbiAgICAgICAgICAgIC8vIFRoZSB0aW1lc3RhbXAgbWF5YmUgYmUgYHVuZGVmaW5lZGAgb3IgYSBudW1iZXJcbiAgICAgICAgICAgIGlmICghRkVUQ0hba2V5XSB8fCBGRVRDSFtrZXldWzFdICE9PSBzdGFydEF0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFN0YXJ0TmV3UmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2tTYWZlZ3VhcmQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29uZmlnKCkub25EaXNjYXJkZWQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDbGVhciBlcnJvci5cbiAgICAgICAgICAgIGZpbmFsU3RhdGUuZXJyb3IgPSBVTkRFRklORUQ7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdyZSBvdGhlciBtdXRhdGlvbnMocyksIHRoYXQgb3ZlcmxhcHBlZCB3aXRoIHRoZSBjdXJyZW50IHJldmFsaWRhdGlvbjpcbiAgICAgICAgICAgIC8vIGNhc2UgMTpcbiAgICAgICAgICAgIC8vICAgcmVxLS0tLS0tLS0tLS0tLS0tLS0tPnJlc1xuICAgICAgICAgICAgLy8gICAgICAgbXV0YXRlLS0tLS0tPmVuZFxuICAgICAgICAgICAgLy8gY2FzZSAyOlxuICAgICAgICAgICAgLy8gICAgICAgICByZXEtLS0tLS0tLS0tLS0+cmVzXG4gICAgICAgICAgICAvLyAgIG11dGF0ZS0tLS0tLT5lbmRcbiAgICAgICAgICAgIC8vIGNhc2UgMzpcbiAgICAgICAgICAgIC8vICAgcmVxLS0tLS0tLS0tLS0tLS0tLS0tPnJlc1xuICAgICAgICAgICAgLy8gICAgICAgbXV0YXRlLS0tLS0tLS4uLi0tLS0tLS0tLS0+XG4gICAgICAgICAgICAvLyB3ZSBoYXZlIHRvIGlnbm9yZSB0aGUgcmV2YWxpZGF0aW9uIHJlc3VsdCAocmVzKSBiZWNhdXNlIGl0J3Mgbm8gbG9uZ2VyIGZyZXNoLlxuICAgICAgICAgICAgLy8gbWVhbndoaWxlLCBhIG5ldyByZXZhbGlkYXRpb24gc2hvdWxkIGJlIHRyaWdnZXJlZCB3aGVuIHRoZSBtdXRhdGlvbiBlbmRzLlxuICAgICAgICAgICAgY29uc3QgbXV0YXRpb25JbmZvID0gTVVUQVRJT05ba2V5XTtcbiAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQobXV0YXRpb25JbmZvKSAmJiAvLyBjYXNlIDFcbiAgICAgICAgICAgIChzdGFydEF0IDw9IG11dGF0aW9uSW5mb1swXSB8fCAvLyBjYXNlIDJcbiAgICAgICAgICAgIHN0YXJ0QXQgPD0gbXV0YXRpb25JbmZvWzFdIHx8IC8vIGNhc2UgM1xuICAgICAgICAgICAgbXV0YXRpb25JbmZvWzFdID09PSAwKSkge1xuICAgICAgICAgICAgICAgIGZpbmlzaFJlcXVlc3RBbmRVcGRhdGVTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRTdGFydE5ld1JlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrU2FmZWd1YXJkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldENvbmZpZygpLm9uRGlzY2FyZGVkKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRGVlcCBjb21wYXJlIHdpdGggdGhlIGxhdGVzdCBzdGF0ZSB0byBhdm9pZCBleHRyYSByZS1yZW5kZXJzLlxuICAgICAgICAgICAgLy8gRm9yIGxvY2FsIHN0YXRlLCBjb21wYXJlIGFuZCBhc3NpZ24uXG4gICAgICAgICAgICBjb25zdCBjYWNoZURhdGEgPSBnZXRDYWNoZSgpLmRhdGE7XG4gICAgICAgICAgICAvLyBTaW5jZSB0aGUgY29tcGFyZSBmbiBjb3VsZCBiZSBjdXN0b20gZm5cbiAgICAgICAgICAgIC8vIGNhY2hlRGF0YSBtaWdodCBiZSBkaWZmZXJlbnQgZnJvbSBuZXdEYXRhIGV2ZW4gd2hlbiBjb21wYXJlIGZuIHJldHVybnMgVHJ1ZVxuICAgICAgICAgICAgZmluYWxTdGF0ZS5kYXRhID0gY29tcGFyZShjYWNoZURhdGEsIG5ld0RhdGEpID8gY2FjaGVEYXRhIDogbmV3RGF0YTtcbiAgICAgICAgICAgIC8vIFRyaWdnZXIgdGhlIHN1Y2Nlc3NmdWwgY2FsbGJhY2sgaWYgaXQncyB0aGUgb3JpZ2luYWwgcmVxdWVzdC5cbiAgICAgICAgICAgIGlmIChzaG91bGRTdGFydE5ld1JlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2tTYWZlZ3VhcmQoKSkge1xuICAgICAgICAgICAgICAgICAgICBnZXRDb25maWcoKS5vblN1Y2Nlc3MobmV3RGF0YSwga2V5LCBjb25maWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjbGVhbnVwU3RhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRDb25maWcgPSBnZXRDb25maWcoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgc2hvdWxkUmV0cnlPbkVycm9yICB9ID0gY3VycmVudENvbmZpZztcbiAgICAgICAgICAgIC8vIE5vdCBwYXVzZWQsIHdlIGNvbnRpbnVlIGhhbmRsaW5nIHRoZSBlcnJvci4gT3RoZXJ3aXNlLCBkaXNjYXJkIGl0LlxuICAgICAgICAgICAgaWYgKCFjdXJyZW50Q29uZmlnLmlzUGF1c2VkKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgYSBuZXcgZXJyb3IsIGRvbid0IHVzZSBkZWVwIGNvbXBhcmlzb24gZm9yIGVycm9ycy5cbiAgICAgICAgICAgICAgICBmaW5hbFN0YXRlLmVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgIC8vIEVycm9yIGV2ZW50IGFuZCByZXRyeSBsb2dpYy4gT25seSBmb3IgdGhlIGFjdHVhbCByZXF1ZXN0LCBub3RcbiAgICAgICAgICAgICAgICAvLyBkZWR1cGVkIG9uZXMuXG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFN0YXJ0TmV3UmVxdWVzdCAmJiBjYWxsYmFja1NhZmVndWFyZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb25maWcub25FcnJvcihlcnIsIGtleSwgY3VycmVudENvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRSZXRyeU9uRXJyb3IgPT09IHRydWUgfHwgaXNGdW5jdGlvbihzaG91bGRSZXRyeU9uRXJyb3IpICYmIHNob3VsZFJldHJ5T25FcnJvcihlcnIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGl0J3MgaW5hY3RpdmUsIHN0b3AuIEl0IHdpbGwgYXV0by1yZXZhbGlkYXRlIHdoZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZWZvY3VzaW5nIG9yIHJlY29ubmVjdGluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHJldHJ5aW5nLCBkZWR1cGxpY2F0aW9uIGlzIGFsd2F5cyBlbmFibGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb25maWcub25FcnJvclJldHJ5KGVyciwga2V5LCBjdXJyZW50Q29uZmlnLCAoX29wdHMpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldmFsaWRhdG9ycyA9IEVWRU5UX1JFVkFMSURBVE9SU1trZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV2YWxpZGF0b3JzICYmIHJldmFsaWRhdG9yc1swXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2YWxpZGF0b3JzWzBdKHJldmFsaWRhdGVFdmVudHMuRVJST1JfUkVWQUxJREFURV9FVkVOVCwgX29wdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXRyeUNvdW50OiAob3B0cy5yZXRyeUNvdW50IHx8IDApICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVkdXBlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFyayBsb2FkaW5nIGFzIHN0b3BwZWQuXG4gICAgICAgIGxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBjdXJyZW50IGhvb2sncyBzdGF0ZS5cbiAgICAgICAgZmluaXNoUmVxdWVzdEFuZFVwZGF0ZVN0YXRlKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sIC8vIGBzZXRTdGF0ZWAgaXMgaW1tdXRhYmxlLCBhbmQgYGV2ZW50c0NhbGxiYWNrYCwgYGZuQXJnYCwgYW5kXG4gICAgLy8gYGtleVZhbGlkYXRpbmdgIGFyZSBkZXBlbmRpbmcgb24gYGtleWAsIHNvIHdlIGNhbiBleGNsdWRlIHRoZW0gZnJvbVxuICAgIC8vIHRoZSBkZXBzIGFycmF5LlxuICAgIC8vXG4gICAgLy8gRklYTUU6XG4gICAgLy8gYGZuYCBhbmQgYGNvbmZpZ2AgbWlnaHQgYmUgY2hhbmdlZCBkdXJpbmcgdGhlIGxpZmVjeWNsZSxcbiAgICAvLyBidXQgdGhleSBtaWdodCBiZSBjaGFuZ2VkIGV2ZXJ5IHJlbmRlciBsaWtlIHRoaXMuXG4gICAgLy8gYHVzZVNXUigna2V5JywgKCkgPT4gZmV0Y2goJy9hcGkvJyksIHsgc3VzcGVuc2U6IHRydWUgfSlgXG4gICAgLy8gU28gd2Ugb21pdCB0aGUgdmFsdWVzIGZyb20gdGhlIGRlcHMgYXJyYXlcbiAgICAvLyBldmVuIHRob3VnaCBpdCBtaWdodCBjYXVzZSB1bmV4cGVjdGVkIGJlaGF2aW9ycy5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW1xuICAgICAgICBrZXksXG4gICAgICAgIGNhY2hlXG4gICAgXSk7XG4gICAgLy8gU2ltaWxhciB0byB0aGUgZ2xvYmFsIG11dGF0ZSBidXQgYm91bmQgdG8gdGhlIGN1cnJlbnQgY2FjaGUgYW5kIGtleS5cbiAgICAvLyBgY2FjaGVgIGlzbid0IGFsbG93ZWQgdG8gY2hhbmdlIGR1cmluZyB0aGUgbGlmZWN5Y2xlLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBjb25zdCBib3VuZE11dGF0ZSA9IHVzZUNhbGxiYWNrKC8vIFVzZSBjYWxsYmFjayB0byBtYWtlIHN1cmUgYGtleVJlZi5jdXJyZW50YCByZXR1cm5zIGxhdGVzdCByZXN1bHQgZXZlcnkgdGltZVxuICAgICguLi5hcmdzKT0+e1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxNdXRhdGUoY2FjaGUsIGtleVJlZi5jdXJyZW50LCAuLi5hcmdzKTtcbiAgICB9LCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW10pO1xuICAgIC8vIFRoZSBsb2dpYyBmb3IgdXBkYXRpbmcgcmVmcy5cbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpPT57XG4gICAgICAgIGZldGNoZXJSZWYuY3VycmVudCA9IGZldGNoZXI7XG4gICAgICAgIGNvbmZpZ1JlZi5jdXJyZW50ID0gY29uZmlnO1xuICAgICAgICAvLyBIYW5kbGUgbGFnZ3kgZGF0YSB1cGRhdGVzLiBJZiB0aGVyZSdzIGNhY2hlZCBkYXRhIG9mIHRoZSBjdXJyZW50IGtleSxcbiAgICAgICAgLy8gaXQnbGwgYmUgdGhlIGNvcnJlY3QgcmVmZXJlbmNlLlxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGNhY2hlZERhdGEpKSB7XG4gICAgICAgICAgICBsYWdneURhdGFSZWYuY3VycmVudCA9IGNhY2hlZERhdGE7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBBZnRlciBtb3VudGVkIG9yIGtleSBjaGFuZ2VkLlxuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCk9PntcbiAgICAgICAgaWYgKCFrZXkpIHJldHVybjtcbiAgICAgICAgY29uc3Qgc29mdFJldmFsaWRhdGUgPSByZXZhbGlkYXRlLmJpbmQoVU5ERUZJTkVELCBXSVRIX0RFRFVQRSk7XG4gICAgICAgIC8vIEV4cG9zZSByZXZhbGlkYXRvcnMgdG8gZ2xvYmFsIGV2ZW50IGxpc3RlbmVycy4gU28gd2UgY2FuIHRyaWdnZXJcbiAgICAgICAgLy8gcmV2YWxpZGF0aW9uIGZyb20gdGhlIG91dHNpZGUuXG4gICAgICAgIGxldCBuZXh0Rm9jdXNSZXZhbGlkYXRlZEF0ID0gMDtcbiAgICAgICAgY29uc3Qgb25SZXZhbGlkYXRlID0gKHR5cGUsIG9wdHMgPSB7fSk9PntcbiAgICAgICAgICAgIGlmICh0eXBlID09IHJldmFsaWRhdGVFdmVudHMuRk9DVVNfRVZFTlQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIGlmIChnZXRDb25maWcoKS5yZXZhbGlkYXRlT25Gb2N1cyAmJiBub3cgPiBuZXh0Rm9jdXNSZXZhbGlkYXRlZEF0ICYmIGlzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dEZvY3VzUmV2YWxpZGF0ZWRBdCA9IG5vdyArIGdldENvbmZpZygpLmZvY3VzVGhyb3R0bGVJbnRlcnZhbDtcbiAgICAgICAgICAgICAgICAgICAgc29mdFJldmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gcmV2YWxpZGF0ZUV2ZW50cy5SRUNPTk5FQ1RfRVZFTlQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0Q29uZmlnKCkucmV2YWxpZGF0ZU9uUmVjb25uZWN0ICYmIGlzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc29mdFJldmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gcmV2YWxpZGF0ZUV2ZW50cy5NVVRBVEVfRVZFTlQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV2YWxpZGF0ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09IHJldmFsaWRhdGVFdmVudHMuRVJST1JfUkVWQUxJREFURV9FVkVOVCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXZhbGlkYXRlKG9wdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB1bnN1YkV2ZW50cyA9IHN1YnNjcmliZUNhbGxiYWNrKGtleSwgRVZFTlRfUkVWQUxJREFUT1JTLCBvblJldmFsaWRhdGUpO1xuICAgICAgICAvLyBNYXJrIHRoZSBjb21wb25lbnQgYXMgbW91bnRlZCBhbmQgdXBkYXRlIGNvcnJlc3BvbmRpbmcgcmVmcy5cbiAgICAgICAgdW5tb3VudGVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAga2V5UmVmLmN1cnJlbnQgPSBrZXk7XG4gICAgICAgIGluaXRpYWxNb3VudGVkUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAvLyBLZWVwIHRoZSBvcmlnaW5hbCBrZXkgaW4gdGhlIGNhY2hlLlxuICAgICAgICBzZXRDYWNoZSh7XG4gICAgICAgICAgICBfazogZm5BcmdcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRyaWdnZXIgYSByZXZhbGlkYXRpb25cbiAgICAgICAgaWYgKHNob3VsZERvSW5pdGlhbFJldmFsaWRhdGlvbikge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGRhdGEpIHx8IElTX1NFUlZFUikge1xuICAgICAgICAgICAgICAgIC8vIFJldmFsaWRhdGUgaW1tZWRpYXRlbHkuXG4gICAgICAgICAgICAgICAgc29mdFJldmFsaWRhdGUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRGVsYXkgdGhlIHJldmFsaWRhdGUgaWYgd2UgaGF2ZSBkYXRhIHRvIHJldHVybiBzbyB3ZSB3b24ndCBibG9ja1xuICAgICAgICAgICAgICAgIC8vIHJlbmRlcmluZy5cbiAgICAgICAgICAgICAgICByQUYoc29mdFJldmFsaWRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgLy8gTWFyayBpdCBhcyB1bm1vdW50ZWQuXG4gICAgICAgICAgICB1bm1vdW50ZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgICB1bnN1YkV2ZW50cygpO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAga2V5XG4gICAgXSk7XG4gICAgLy8gUG9sbGluZ1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCk9PntcbiAgICAgICAgbGV0IHRpbWVyO1xuICAgICAgICBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgICAgLy8gVXNlIHRoZSBwYXNzZWQgaW50ZXJ2YWxcbiAgICAgICAgICAgIC8vIC4uLm9yIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgdXBkYXRlZCBkYXRhIHRvIGdldCB0aGUgaW50ZXJ2YWxcbiAgICAgICAgICAgIGNvbnN0IGludGVydmFsID0gaXNGdW5jdGlvbihyZWZyZXNoSW50ZXJ2YWwpID8gcmVmcmVzaEludGVydmFsKGdldENhY2hlKCkuZGF0YSkgOiByZWZyZXNoSW50ZXJ2YWw7XG4gICAgICAgICAgICAvLyBXZSBvbmx5IHN0YXJ0IHRoZSBuZXh0IGludGVydmFsIGlmIGByZWZyZXNoSW50ZXJ2YWxgIGlzIG5vdCAwLCBhbmQ6XG4gICAgICAgICAgICAvLyAtIGBmb3JjZWAgaXMgdHJ1ZSwgd2hpY2ggaXMgdGhlIHN0YXJ0IG9mIHBvbGxpbmdcbiAgICAgICAgICAgIC8vIC0gb3IgYHRpbWVyYCBpcyBub3QgMCwgd2hpY2ggbWVhbnMgdGhlIGVmZmVjdCB3YXNuJ3QgY2FuY2VsZWRcbiAgICAgICAgICAgIGlmIChpbnRlcnZhbCAmJiB0aW1lciAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZXhlY3V0ZSwgaW50ZXJ2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGV4ZWN1dGUoKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBpdCdzIE9LIHRvIGV4ZWN1dGU6XG4gICAgICAgICAgICAvLyBPbmx5IHJldmFsaWRhdGUgd2hlbiB0aGUgcGFnZSBpcyB2aXNpYmxlLCBvbmxpbmUsIGFuZCBub3QgZXJyb3JlZC5cbiAgICAgICAgICAgIGlmICghZ2V0Q2FjaGUoKS5lcnJvciAmJiAocmVmcmVzaFdoZW5IaWRkZW4gfHwgZ2V0Q29uZmlnKCkuaXNWaXNpYmxlKCkpICYmIChyZWZyZXNoV2hlbk9mZmxpbmUgfHwgZ2V0Q29uZmlnKCkuaXNPbmxpbmUoKSkpIHtcbiAgICAgICAgICAgICAgICByZXZhbGlkYXRlKFdJVEhfREVEVVBFKS50aGVuKG5leHQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTY2hlZHVsZSB0aGUgbmV4dCBpbnRlcnZhbCB0byBjaGVjayBhZ2Fpbi5cbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCgpO1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICAgICAgdGltZXIgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIHJlZnJlc2hJbnRlcnZhbCxcbiAgICAgICAgcmVmcmVzaFdoZW5IaWRkZW4sXG4gICAgICAgIHJlZnJlc2hXaGVuT2ZmbGluZSxcbiAgICAgICAga2V5XG4gICAgXSk7XG4gICAgLy8gRGlzcGxheSBkZWJ1ZyBpbmZvIGluIFJlYWN0IERldlRvb2xzLlxuICAgIHVzZURlYnVnVmFsdWUocmV0dXJuZWREYXRhKTtcbiAgICAvLyBJbiBTdXNwZW5zZSBtb2RlLCB3ZSBjYW4ndCByZXR1cm4gdGhlIGVtcHR5IGBkYXRhYCBzdGF0ZS5cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBgZXJyb3JgLCB0aGUgYGVycm9yYCBuZWVkcyB0byBiZSB0aHJvd24gdG8gdGhlIGVycm9yIGJvdW5kYXJ5LlxuICAgIC8vIElmIHRoZXJlIGlzIG5vIGBlcnJvcmAsIHRoZSBgcmV2YWxpZGF0aW9uYCBwcm9taXNlIG5lZWRzIHRvIGJlIHRocm93biB0b1xuICAgIC8vIHRoZSBzdXNwZW5zZSBib3VuZGFyeS5cbiAgICBpZiAoc3VzcGVuc2UgJiYgaXNVbmRlZmluZWQoZGF0YSkgJiYga2V5KSB7XG4gICAgICAgIC8vIFNXUiBzaG91bGQgdGhyb3cgd2hlbiB0cnlpbmcgdG8gdXNlIFN1c3BlbnNlIG9uIHRoZSBzZXJ2ZXIgd2l0aCBSZWFjdCAxOCxcbiAgICAgICAgLy8gd2l0aG91dCBwcm92aWRpbmcgYW55IGluaXRpYWwgZGF0YS4gU2VlOlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL3N3ci9pc3N1ZXMvMTgzMlxuICAgICAgICBpZiAoIUlTX1JFQUNUX0xFR0FDWSAmJiBJU19TRVJWRVIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFsbGJhY2sgZGF0YSBpcyByZXF1aXJlZCB3aGVuIHVzaW5nIHN1c3BlbnNlIGluIFNTUi4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbHdheXMgdXBkYXRlIGZldGNoZXIgYW5kIGNvbmZpZyByZWZzIGV2ZW4gd2l0aCB0aGUgU3VzcGVuc2UgbW9kZS5cbiAgICAgICAgZmV0Y2hlclJlZi5jdXJyZW50ID0gZmV0Y2hlcjtcbiAgICAgICAgY29uZmlnUmVmLmN1cnJlbnQgPSBjb25maWc7XG4gICAgICAgIHVubW91bnRlZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHJlcSA9IFBSRUxPQURba2V5XTtcbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChyZXEpKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gYm91bmRNdXRhdGUocmVxKTtcbiAgICAgICAgICAgIHVzZShwcm9taXNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNVbmRlZmluZWQoZXJyb3IpKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gcmV2YWxpZGF0ZShXSVRIX0RFRFVQRSk7XG4gICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHJldHVybmVkRGF0YSkpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLnN0YXR1cyA9ICdmdWxmaWxsZWQnO1xuICAgICAgICAgICAgICAgIHByb21pc2UudmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXNlKHByb21pc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbXV0YXRlOiBib3VuZE11dGF0ZSxcbiAgICAgICAgZ2V0IGRhdGEgKCkge1xuICAgICAgICAgICAgc3RhdGVEZXBlbmRlbmNpZXMuZGF0YSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuZWREYXRhO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgZXJyb3IgKCkge1xuICAgICAgICAgICAgc3RhdGVEZXBlbmRlbmNpZXMuZXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgaXNWYWxpZGF0aW5nICgpIHtcbiAgICAgICAgICAgIHN0YXRlRGVwZW5kZW5jaWVzLmlzVmFsaWRhdGluZyA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gaXNWYWxpZGF0aW5nO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgaXNMb2FkaW5nICgpIHtcbiAgICAgICAgICAgIHN0YXRlRGVwZW5kZW5jaWVzLmlzTG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gaXNMb2FkaW5nO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5jb25zdCBTV1JDb25maWcgPSBPQkpFQ1QuZGVmaW5lUHJvcGVydHkoU1dSQ29uZmlnJDEsICdkZWZhdWx0VmFsdWUnLCB7XG4gICAgdmFsdWU6IGRlZmF1bHRDb25maWdcbn0pO1xuLyoqXG4gKiBBIGhvb2sgdG8gZmV0Y2ggZGF0YS5cbiAqXG4gKiBAbGluayBodHRwczovL3N3ci52ZXJjZWwuYXBwXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKiBpbXBvcnQgdXNlU1dSIGZyb20gJ3N3cidcbiAqIGZ1bmN0aW9uIFByb2ZpbGUoKSB7XG4gKiAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHVzZVNXUignL2FwaS91c2VyJywgZmV0Y2hlcilcbiAqICAgaWYgKGVycm9yKSByZXR1cm4gPGRpdj5mYWlsZWQgdG8gbG9hZDwvZGl2PlxuICogICBpZiAoIWRhdGEpIHJldHVybiA8ZGl2PmxvYWRpbmcuLi48L2Rpdj5cbiAqICAgcmV0dXJuIDxkaXY+aGVsbG8ge2RhdGEubmFtZX0hPC9kaXY+XG4gKiB9XG4gKiBgYGBcbiAqLyBjb25zdCB1c2VTV1IgPSB3aXRoQXJncyh1c2VTV1JIYW5kbGVyKTtcblxuLy8gdXNlU1dSXG5cbmV4cG9ydCB7IFNXUkNvbmZpZywgdXNlU1dSIGFzIGRlZmF1bHQsIHVuc3RhYmxlX3NlcmlhbGl6ZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/swr/core/dist/index.mjs\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fgabriellemia%2FWeb%20Dev%2Fprojects%2Fmy-chatbot%2Fmy-chatbot%2Fmy-ai-bot%2Fsrc%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);